import { S as SvelteComponent, i as init, s as safe_not_equal, a as space, e as empty$2, c as claim_space, b as insert_hydration, g as group_outros, t as transition_out, d as check_outros, f as transition_in, h as detach, j as afterUpdate, o as onMount, k as element, l as claim_element, m as children, n as attr, p as set_style, q as text, r as claim_text, u as set_data, v as binding_callbacks, w as construct_svelte_component, x as create_component, y as claim_component, z as mount_component, A as destroy_component, B as tick } from "./index-64643071.js";
import { S as SCROLL_KEY, a as SNAPSHOT_KEY, I as INDEX_KEY, g as get_base_uri, f as find_anchor, b as get_link_info, c as get_router_options, s as stores, i as is_external_url, d as scroll_state, P as PRELOAD_PRIORITIES, e as init$1, h as set_version } from "./singletons-8a040551.js";
import { r as require$$0$1, c as commonjsGlobal, W as Wallet$1, g as getDefaultExportFromCjs, a as commonjsRequire$1, B as BigNumber$1, n as naclFastExports, d as dist, E as Ethereum, T as Tezos, b as TON } from "./bignumber-d04f630d.js";
import { b as base$4, s as set_assets } from "./paths-51e4d197.js";
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
const tracked_url_properties = ["href", "pathname", "search", "searchParams", "toString", "toJSON"];
function make_trackable(url, callback) {
  const tracked = new URL(url);
  for (const property of tracked_url_properties) {
    let value = tracked[property];
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return value;
      },
      enumerable: true,
      configurable: true
    });
  }
  disable_hash(tracked);
  return tracked;
}
function disable_hash(url) {
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
const DATA_SUFFIX = "/__data.json";
function add_data_suffix(pathname) {
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function get(key2) {
  try {
    return JSON.parse(sessionStorage[key2]);
  } catch {
  }
}
function set(key2, value) {
  const json = JSON.stringify(value);
  try {
    sessionStorage[key2] = json;
  } catch {
  }
}
function hash$4(...values) {
  let hash3 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i2 = value.length;
      while (i2)
        hash3 = hash3 * 33 ^ value.charCodeAt(--i2);
    } else if (ArrayBuffer.isView(value)) {
      const buffer2 = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i2 = buffer2.length;
      while (i2)
        hash3 = hash3 * 33 ^ buffer2[--i2];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash3 >>> 0).toString(36);
}
const native_fetch = window.fetch;
{
  window.fetch = (input, init5) => {
    const method = input instanceof Request ? input.method : (init5 == null ? void 0 : init5.method) || "GET";
    if (method !== "GET") {
      cache.delete(build_selector(input));
    }
    return native_fetch(input, init5);
  };
}
const cache = /* @__PURE__ */ new Map();
function initial_fetch(resource, opts) {
  const selector = build_selector(resource, opts);
  const script = document.querySelector(selector);
  if (script == null ? void 0 : script.textContent) {
    const { body, ...init5 } = JSON.parse(script.textContent);
    const ttl = script.getAttribute("data-ttl");
    if (ttl)
      cache.set(selector, { body, init: init5, ttl: 1e3 * Number(ttl) });
    return Promise.resolve(new Response(body, init5));
  }
  return native_fetch(resource, opts);
}
function subsequent_fetch(resource, resolved, opts) {
  if (cache.size > 0) {
    const selector = build_selector(resource, opts);
    const cached = cache.get(selector);
    if (cached) {
      if (performance.now() < cached.ttl && ["default", "force-cache", "only-if-cached", void 0].includes(opts == null ? void 0 : opts.cache)) {
        return new Response(cached.body, cached.init);
      }
      cache.delete(selector);
    }
  }
  return native_fetch(resolved, opts);
}
function build_selector(resource, opts) {
  const url = JSON.stringify(resource instanceof Request ? resource.url : resource);
  let selector = `script[data-sveltekit-fetched][data-url=${url}]`;
  if ((opts == null ? void 0 : opts.headers) || (opts == null ? void 0 : opts.body)) {
    const values = [];
    if (opts.headers) {
      values.push([...new Headers(opts.headers)].join(","));
    }
    if (opts.body && (typeof opts.body === "string" || ArrayBuffer.isView(opts.body))) {
      values.push(opts.body);
    }
    selector += `[data-hash="${hash$4(...values)}"]`;
  }
  return selector;
}
const param_pattern = /^(\[)?(\.\.\.)?(\w+)(?:=(\w+))?(\])?$/;
function parse_route_id(id2) {
  const params = [];
  const pattern = id2 === "/" ? /^\/$/ : new RegExp(
    `^${get_route_segments(id2).map((segment) => {
      const rest_match = /^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(segment);
      if (rest_match) {
        params.push({
          name: rest_match[1],
          matcher: rest_match[2],
          optional: false,
          rest: true,
          chained: true
        });
        return "(?:/(.*))?";
      }
      const optional_match = /^\[\[(\w+)(?:=(\w+))?\]\]$/.exec(segment);
      if (optional_match) {
        params.push({
          name: optional_match[1],
          matcher: optional_match[2],
          optional: true,
          rest: false,
          chained: true
        });
        return "(?:/([^/]+))?";
      }
      if (!segment) {
        return;
      }
      const parts = segment.split(/\[(.+?)\](?!\])/);
      const result = parts.map((content, i2) => {
        if (i2 % 2) {
          if (content.startsWith("x+")) {
            return escape$1(String.fromCharCode(parseInt(content.slice(2), 16)));
          }
          if (content.startsWith("u+")) {
            return escape$1(
              String.fromCharCode(
                ...content.slice(2).split("-").map((code2) => parseInt(code2, 16))
              )
            );
          }
          const match = param_pattern.exec(content);
          if (!match) {
            throw new Error(
              `Invalid param: ${content}. Params and matcher names can only have underscores and alphanumeric characters.`
            );
          }
          const [, is_optional, is_rest, name2, matcher] = match;
          params.push({
            name: name2,
            matcher,
            optional: !!is_optional,
            rest: !!is_rest,
            chained: is_rest ? i2 === 1 && parts[0] === "" : false
          });
          return is_rest ? "(.*?)" : is_optional ? "([^/]*)?" : "([^/]+?)";
        }
        return escape$1(content);
      }).join("");
      return "/" + result;
    }).join("")}/?$`
  );
  return { pattern, params };
}
function affects_path(segment) {
  return !/^\([^)]+\)$/.test(segment);
}
function get_route_segments(route) {
  return route.slice(1).split("/").filter(affects_path);
}
function exec(match, params, matchers2) {
  const result = {};
  const values = match.slice(1);
  let buffered = 0;
  for (let i2 = 0; i2 < params.length; i2 += 1) {
    const param = params[i2];
    const value = values[i2 - buffered];
    if (param.chained && param.rest && buffered) {
      result[param.name] = values.slice(i2 - buffered, i2 + 1).filter((s2) => s2).join("/");
      buffered = 0;
      continue;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers2[param.matcher](value)) {
      result[param.name] = value;
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function escape$1(str) {
  return str.normalize().replace(/[[\]]/g, "\\$&").replace(/%/g, "%25").replace(/\//g, "%2[Ff]").replace(/\?/g, "%3[Ff]").replace(/#/g, "%23").replace(/[.*+?^${}()|\\]/g, "\\$&");
}
function parse$1(nodes2, server_loads2, dictionary2, matchers2) {
  const layouts_with_server_load = new Set(server_loads2);
  return Object.entries(dictionary2).map(([id2, [leaf, layouts, errors]]) => {
    const { pattern, params } = parse_route_id(id2);
    const route = {
      id: id2,
      /** @param {string} path */
      exec: (path) => {
        const match = pattern.exec(path);
        if (match)
          return exec(match, params, matchers2);
      },
      errors: [1, ...errors || []].map((n) => nodes2[n]),
      layouts: [0, ...layouts || []].map(create_layout_loader),
      leaf: create_leaf_loader(leaf)
    };
    route.errors.length = route.layouts.length = Math.max(
      route.errors.length,
      route.layouts.length
    );
    return route;
  });
  function create_leaf_loader(id2) {
    const uses_server_data = id2 < 0;
    if (uses_server_data)
      id2 = ~id2;
    return [uses_server_data, nodes2[id2]];
  }
  function create_layout_loader(id2) {
    return id2 === void 0 ? id2 : [layouts_with_server_load.has(id2), nodes2[id2]];
  }
}
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*constructors*/
    ctx[1][0]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      data: (
        /*data_0*/
        ctx2[3]
      ),
      form: (
        /*form*/
        ctx2[2]
      )
    };
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    ctx[12](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty$2();
    },
    l(nodes2) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes2);
      switch_instance_anchor = empty$2();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*data_0*/
      8)
        switch_instance_changes.data = /*data_0*/
        ctx2[3];
      if (dirty & /*form*/
      4)
        switch_instance_changes.form = /*form*/
        ctx2[2];
      if (switch_value !== (switch_value = /*constructors*/
      ctx2[1][0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          ctx2[12](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[12](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*constructors*/
    ctx[1][0]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      data: (
        /*data_0*/
        ctx2[3]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    ctx[11](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty$2();
    },
    l(nodes2) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes2);
      switch_instance_anchor = empty$2();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*data_0*/
      8)
        switch_instance_changes.data = /*data_0*/
        ctx2[3];
      if (dirty & /*$$scope, constructors, data_1, form, components*/
      8215) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = /*constructors*/
      ctx2[1][0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          ctx2[11](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[11](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*constructors*/
    ctx[1][1]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      data: (
        /*data_1*/
        ctx2[4]
      ),
      form: (
        /*form*/
        ctx2[2]
      )
    };
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    ctx[10](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty$2();
    },
    l(nodes2) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes2);
      switch_instance_anchor = empty$2();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*data_1*/
      16)
        switch_instance_changes.data = /*data_1*/
        ctx2[4];
      if (dirty & /*form*/
      4)
        switch_instance_changes.form = /*form*/
        ctx2[2];
      if (switch_value !== (switch_value = /*constructors*/
      ctx2[1][1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          ctx2[10](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[10](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let if_block = (
    /*navigated*/
    ctx[6] && create_if_block_1(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes2) {
      div = claim_element(nodes2, "DIV", {
        id: true,
        "aria-live": true,
        "aria-atomic": true,
        style: true
      });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "id", "svelte-announcer");
      attr(div, "aria-live", "assertive");
      attr(div, "aria-atomic", "true");
      set_style(div, "position", "absolute");
      set_style(div, "left", "0");
      set_style(div, "top", "0");
      set_style(div, "clip", "rect(0 0 0 0)");
      set_style(div, "clip-path", "inset(50%)");
      set_style(div, "overflow", "hidden");
      set_style(div, "white-space", "nowrap");
      set_style(div, "width", "1px");
      set_style(div, "height", "1px");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (/*navigated*/
      ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*title*/
        ctx[7]
      );
    },
    l(nodes2) {
      t = claim_text(
        nodes2,
        /*title*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      128)
        set_data(
          t,
          /*title*/
          ctx2[7]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (/*constructors*/
    ctx2[1][1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*mounted*/
    ctx[5] && create_if_block(ctx)
  );
  return {
    c() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty$2();
    },
    l(nodes2) {
      if_block0.l(nodes2);
      t = claim_space(nodes2);
      if (if_block1)
        if_block1.l(nodes2);
      if_block1_anchor = empty$2();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (/*mounted*/
      ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { stores: stores2 } = $$props;
  let { page } = $$props;
  let { constructors } = $$props;
  let { components = [] } = $$props;
  let { form } = $$props;
  let { data_0 = null } = $$props;
  let { data_1 = null } = $$props;
  afterUpdate(stores2.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores2.page.subscribe(() => {
      if (mounted) {
        $$invalidate(6, navigated = true);
        $$invalidate(7, title = document.title || "untitled page");
      }
    });
    $$invalidate(5, mounted = true);
    return unsubscribe;
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      components[1] = $$value;
      $$invalidate(0, components);
    });
  }
  function switch_instance_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      components[0] = $$value;
      $$invalidate(0, components);
    });
  }
  function switch_instance_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      components[0] = $$value;
      $$invalidate(0, components);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("stores" in $$props2)
      $$invalidate(8, stores2 = $$props2.stores);
    if ("page" in $$props2)
      $$invalidate(9, page = $$props2.page);
    if ("constructors" in $$props2)
      $$invalidate(1, constructors = $$props2.constructors);
    if ("components" in $$props2)
      $$invalidate(0, components = $$props2.components);
    if ("form" in $$props2)
      $$invalidate(2, form = $$props2.form);
    if ("data_0" in $$props2)
      $$invalidate(3, data_0 = $$props2.data_0);
    if ("data_1" in $$props2)
      $$invalidate(4, data_1 = $$props2.data_1);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*stores, page*/
    768) {
      stores2.page.set(page);
    }
  };
  return [
    components,
    constructors,
    form,
    data_0,
    data_1,
    mounted,
    navigated,
    title,
    stores2,
    page,
    switch_instance_binding,
    switch_instance_binding_1,
    switch_instance_binding_2
  ];
}
class Root extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      stores: 8,
      page: 9,
      constructors: 1,
      components: 0,
      form: 2,
      data_0: 3,
      data_1: 4
    });
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
var bnExports$1 = {};
var bn$1 = {
  get exports() {
    return bnExports$1;
  },
  set exports(v2) {
    bnExports$1 = v2;
  }
};
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base2, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$1.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init5(number, base2, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base2, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start2 = 0;
      if (number[0] === "-") {
        start2++;
        this.negative = 1;
      }
      if (start2 < number.length) {
        if (base2 === 16) {
          this._parseHex(number, start2, endian);
        } else {
          this._parseBase(number, base2, start2);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base2, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
          w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c2 = string.charCodeAt(index);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r2 = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string, index - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start2, endian) {
      this.length = Math.ceil((number.length - start2) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number.length - 1; i2 >= start2; i2 -= 2) {
          w2 = parseHexByte(number, start2, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start2;
        for (i2 = parseLength % 2 === 0 ? start2 + 1 : start2; i2 < number.length; i2 += 2) {
          w2 = parseHexByte(number, start2, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start2, end, mul7) {
      var r2 = 0;
      var b2 = 0;
      var len2 = Math.min(str.length, end);
      for (var i2 = start2; i2 < len2; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul7;
        if (c2 >= 49) {
          b2 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b2 = c2 - 17 + 10;
        } else {
          b2 = c2;
        }
        assert2(c2 >= 0 && b2 < mul7, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base2, start2) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number.length - start2;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start2;
      var word = 0;
      for (var i2 = start2; i2 < end; i2 += limbLen) {
        word = parseBase(number, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i2, number.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect9;
      } catch (e) {
        BN2.prototype.inspect = inspect9;
      }
    } else {
      BN2.prototype.inspect = inspect9;
    }
    function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t = w2;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t = w2;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len2; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j2 = Math.max(0, k - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c2 !== 0) {
        o[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j2 = Math.max(0, k - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q = res.sqr(); i2 < w2.length; i2++, q = q.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul7;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m2 + 1;
        q.words = new Array(q.length);
        for (var i2 = 0; i2 < q.length; i2++) {
          q.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q) {
          q.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q) {
          q.words[j2] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a2._strip();
      if (mode !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B.isOdd()) {
              A2.iadd(yp);
              B.isub(xp);
            }
            A2.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C);
          B.isub(D);
        } else {
          y2.isub(x2);
          C.isub(A2);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t = a2;
          a2 = b2;
          b2 = t;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg6(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add7(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul7(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q);
      var r2 = this.pow(a2, q.addn(1).iushrn(1));
      var t = this.pow(a2, q);
      var m2 = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t = t.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start2 = num.bitLength() % 26;
      if (start2 === 0) {
        start2 = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j2 = start2 - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start2 = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t = a2.imul(b2);
      var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t = a2.mul(b2);
      var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$1);
const BN$9 = bnExports$1;
const version$j = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX[value[i2] >> 4];
            hex += HEX[value[i2] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$j);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$i = "bytes/5.7.0";
const logger$p = new Logger(version$i);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes$1(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes$1(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$p.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger$p.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes$1(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$p.throwArgumentError("invalid arrayify value", "value", value);
}
function concat$1(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start2 = 0;
  while (start2 < result.length && result[start2] === 0) {
    start2++;
  }
  if (start2) {
    result = result.slice(start2);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger$p.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$p.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$p.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes$1(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$p.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data2) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    return null;
  }
  return (data2.length - 2) / 2;
}
function hexDataSlice(data2, offset, endOffset) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    logger$p.throwArgumentError("invalid hexData", "value", data2);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data2.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data2.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$p.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$p.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger$p.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger$p.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$p.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$p.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$p.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$p.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$p.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$p.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$p.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$p.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$p.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$p.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
const version$h = "bignumber/5.7.0";
var BN$8 = BN$9.BN;
const logger$o = new Logger(version$h);
const _constructorGuard$3 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes$1(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$o.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger$o.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$o.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$o.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$o.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$3, toHex$2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$3, toHex$2(new BN$8(value)));
      }
      return logger$o.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes$1(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger$o.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$2(value) {
  if (typeof value !== "string") {
    return toHex$2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$o.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$2(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN$8("-" + hex.substring(3), 16);
  }
  return new BN$8(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$o.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN$8(value, 36).toString(16);
}
const logger$n = new Logger(version$h);
const _constructorGuard$2 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$n.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
let zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger$n.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$n.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$n.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$n.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$n.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$n.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key2, type, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type) {
          logger$n.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$n.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$n.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$2, signed2, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex, value, format2) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$n.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format2;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$n.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$n.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$n.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format2) {
    return FixedNumber.fromString(this._value, format2);
  }
  static fromValue(value, decimals, format2) {
    if (format2 == null && decimals != null && !isBigNumberish(decimals)) {
      format2 = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format2 == null) {
      format2 = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format2));
  }
  static fromString(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex, decimal, fixedFormat);
  }
  static from(value, format2) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format2);
    }
    if (isBytes$1(value)) {
      return FixedNumber.fromBytes(value, format2);
    }
    try {
      return FixedNumber.fromValue(value, 0, format2);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$n.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$g = "properties/5.7.0";
var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$m = new Logger(version$g);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$j(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v2) => ({ key: key2, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger$m.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger$m.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$m.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$m.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
const version$f = "abi/5.7.0";
const logger$l = new Logger(version$f);
const _constructorGuard$1 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$l.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i2) {
    logger$l.throwArgumentError(`unexpected character at position ${i2}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node3 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node3.indexed = false;
    }
    return node3;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node2 = parent;
  for (let i2 = 0; i2 < param.length; i2++) {
    let c2 = param[i2];
    switch (c2) {
      case "(":
        if (node2.state.allowType && node2.type === "") {
          node2.type = "tuple";
        } else if (!node2.state.allowParams) {
          throwError2(i2);
        }
        node2.state.allowType = false;
        node2.type = verifyType(node2.type);
        node2.components = [newNode(node2)];
        node2 = node2.components[0];
        break;
      case ")":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let child = node2;
        node2 = node2.parent;
        if (!node2) {
          throwError2(i2);
        }
        delete child.parent;
        node2.state.allowParams = false;
        node2.state.allowName = true;
        node2.state.allowArray = true;
        break;
      case ",":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let sibling = newNode(node2.parent);
        node2.parent.components.push(sibling);
        delete node2.parent;
        node2 = sibling;
        break;
      case " ":
        if (node2.state.allowType) {
          if (node2.type !== "") {
            node2.type = verifyType(node2.type);
            delete node2.state.allowType;
            node2.state.allowName = true;
            node2.state.allowParams = true;
          }
        }
        if (node2.state.allowName) {
          if (node2.name !== "") {
            if (node2.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i2);
              }
              if (node2.indexed) {
                throwError2(i2);
              }
              node2.indexed = true;
              node2.name = "";
            } else if (checkModifier(node2.type, node2.name)) {
              node2.name = "";
            } else {
              node2.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node2.state.allowArray) {
          throwError2(i2);
        }
        node2.type += c2;
        node2.state.allowArray = false;
        node2.state.allowName = false;
        node2.state.readArray = true;
        break;
      case "]":
        if (!node2.state.readArray) {
          throwError2(i2);
        }
        node2.type += c2;
        node2.state.readArray = false;
        node2.state.allowArray = true;
        node2.state.allowName = true;
        break;
      default:
        if (node2.state.allowType) {
          node2.type += c2;
          node2.state.allowParams = true;
          node2.state.allowArray = true;
        } else if (node2.state.allowName) {
          node2.name += c2;
          delete node2.state.allowArray;
        } else if (node2.state.readArray) {
          node2.type += c2;
        } else {
          throwError2(i2);
        }
    }
  }
  if (node2.parent) {
    logger$l.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node2.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node2.indexed) {
      throwError2(originalParam.length - 7);
    }
    node2.indexed = true;
    node2.name = "";
  } else if (checkModifier(node2.type, node2.name)) {
    node2.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$l.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$l.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format2);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format2 !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$1, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node2) {
      return ParamType.fromObject({
        name: node2.name,
        type: node2.type,
        indexed: node2.indexed,
        components: node2.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$l.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$l.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$l.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$l.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$l.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$l.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$l.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$l.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$l.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$l.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$l.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$l.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$l.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$l.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$l.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    if (format2 === FormatTypes.sighash) {
      logger$l.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$l.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger$l.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$l.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$l.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format2)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$l.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$l.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$l.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$l.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$l.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$l.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$l.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$1, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$l.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$l.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$l.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$k = new Logger(version$f);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$k.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data2) {
    this._data.push(data2);
    this._dataLength += data2.length;
    return data2.length;
  }
  appendWriter(writer) {
    return this._writeData(concat$1(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes = arrayify(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat$1([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify(BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger$k.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat$1([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
}
let Reader$1 = class Reader2 {
  constructor(data2, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data2));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader$1.coerce(name2, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger$k.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader$1(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes = this._peekBytes(0, length, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
};
var sha3Exports = {};
var sha3$1 = {
  get exports() {
    return sha3Exports;
  },
  set exports(v2) {
    sha3Exports = v2;
  }
};
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
        var type = OUTPUT_TYPES[i3];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n, s2) {
        if (!n && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding2, outputBits).bytepad([n, s2], w2);
        }
      };
      method.update = function(message, outputBits, n, s2) {
        return method.create(outputBits, n, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i2 = 0; i2 < algorithms.length; ++i2) {
      var algorithm = algorithms[i2];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i3 = 0; i3 < 50; ++i3) {
        this.s[i3] = 0;
      }
    }
    Keccak.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i3, code2;
      while (index < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        if (notString) {
          for (i3 = this.start; index < length && i3 < byteCount; ++index) {
            blocks[i3 >> 2] |= message[index] << SHIFT[i3++ & 3];
          }
        } else {
          for (i3 = this.start; index < length && i3 < byteCount; ++index) {
            code2 = message.charCodeAt(index);
            if (code2 < 128) {
              blocks[i3 >> 2] |= code2 << SHIFT[i3++ & 3];
            } else if (code2 < 2048) {
              blocks[i3 >> 2] |= (192 | code2 >> 6) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i3 >> 2] |= (224 | code2 >> 12) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks[i3 >> 2] |= (240 | code2 >> 18) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            }
          }
        }
        this.lastByteIndex = i3;
        if (i3 >= byteCount) {
          this.start = i3 - byteCount;
          this.block = blocks[blockCount];
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks[i3];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i3;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x2, right) {
      var o = x2 & 255, n = 1;
      var bytes = [o];
      x2 = x2 >> 8;
      o = x2 & 255;
      while (o > 0) {
        bytes.unshift(o);
        x2 = x2 >> 8;
        o = x2 & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i3 = 0; i3 < str.length; ++i3) {
          var code2 = str.charCodeAt(i3);
          if (code2 < 128) {
            bytes += 1;
          } else if (code2 < 2048) {
            bytes += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i3) & 1023);
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w2) {
      var bytes = this.encode(w2);
      for (var i3 = 0; i3 < strs.length; ++i3) {
        bytes += this.encodeString(strs[i3]);
      }
      var paddingBytes = w2 - bytes % w2;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i3 >> 2] |= this.padding[i3 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i3 = 1; i3 < blockCount + 1; ++i3) {
          blocks[i3] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i3 = 0; i3 < blockCount; ++i3) {
        s2[i3] ^= blocks[i3];
      }
      f2(s2);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var hex = "", block;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          block = s2[i3];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
          i3 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i3];
        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var bytes = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          array[j3] = s2[i3];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i3] = s2[i3];
        buffer2 = buffer2.slice(0, bytes);
      }
      return buffer2;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var array = [], offset, block;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          offset = j3 << 2;
          block = s2[i3];
          array[offset] = block & 255;
          array[offset + 1] = block >> 8 & 255;
          array[offset + 2] = block >> 16 & 255;
          array[offset + 3] = block >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset = j3 << 2;
        block = s2[i3];
        array[offset] = block & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n];
        s2[1] ^= RC[n + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        root[methodNames[i2]] = methods[methodNames[i2]];
      }
    }
  })();
})(sha3$1);
const sha3 = sha3Exports;
function keccak256(data2) {
  return "0x" + sha3.keccak_256(arrayify(data2));
}
const version$e = "rlp/5.7.0";
const logger$j = new Logger(version$e);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data2, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data2[offset + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$j.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data2 = Array.prototype.slice.call(arrayify(object));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length = arrayifyInteger(data2.length);
  length.unshift(183 + length.length);
  return length.concat(data2);
}
function encode$4(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data2, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger$j.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data2, offset) {
  if (data2.length === 0) {
    logger$j.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    if (offset + 1 + lengthLength > data2.length) {
      logger$j.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data2.length) {
      logger$j.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data2[offset] >= 192) {
    const length = data2[offset] - 192;
    if (offset + 1 + length > data2.length) {
      logger$j.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1, length);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    if (offset + 1 + lengthLength > data2.length) {
      logger$j.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data2.length) {
      logger$j.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data2[offset] >= 128) {
    const length = data2[offset] - 128;
    if (offset + 1 + length > data2.length) {
      logger$j.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data2[offset]) };
}
function decode$3(data2) {
  const bytes = arrayify(data2);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger$j.throwArgumentError("invalid rlp data", "data", data2);
  }
  return decoded.result;
}
const version$d = "address/5.7.0";
const logger$i = new Logger(version$d);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$i.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$i.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$i.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$i.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$i.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger$i.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode$4([from2, nonce])), 12));
}
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
const logger$h = new Logger(version$f);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$h.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger$h.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger$h.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$h.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i2 = 0; i2 < values.length; i2++) {
    const value = values[i2];
    if (value instanceof Error) {
      Object.defineProperty(values, i2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger$h.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger$h.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i2 = 0; i2 < count; i2++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name2 = "bytes" + String(size);
    super(name2, name2, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data2 = arrayify(value);
    if (data2.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data2);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size * 8;
    super(name2, name2, localName, false);
    this.size = size;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v2 = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v2.lt(Zero$1) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v2);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
}
const version$c = "strings/5.7.0";
const logger$g = new Logger(version$c);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger$g.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$g.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}
const logger$f = new Logger(version$f);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger$f.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger$f.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger$f.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data2, allowLoose) {
    return new Reader$1(data2, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger$f.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data2, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data2), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(text2) {
  return keccak256(toUtf8Bytes(text2));
}
const version$b = "hash/5.7.0";
function decode$2(textData) {
  textData = atob(textData);
  const data2 = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data2.push(textData.charCodeAt(i2));
  }
  return arrayify(data2);
}
function encode$3(data2) {
  data2 = arrayify(data2);
  let textData = "";
  for (let i2 = 0; i2 < data2.length; i2++) {
    textData += String.fromCharCode(data2[i2]);
  }
  return btoa(textData);
}
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach3 = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach3.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i2 = 0; i2 < array.length; i2++) {
    const value = array[i2];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N2; i2++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range2);
    let start2 = 0;
    let end = symbol_count;
    while (end - start2 > 1) {
      let mid = start2 + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start2 = mid;
      }
    }
    if (start2 == 0)
      break;
    symbols.push(start2);
    let a2 = low + Math.floor(range2 * acc[start2] / total);
    let b2 = low + Math.floor(range2 * acc[start2 + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range2 = 1 + b2 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
function signed(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
function read_counts(n, next) {
  let v2 = Array(n);
  for (let i2 = 0; i2 < n; i2++)
    v2[i2] = 1 + next();
  return v2;
}
function read_ascending(n, next) {
  let v2 = Array(n);
  for (let i2 = 0, x2 = -1; i2 < n; i2++)
    v2[i2] = x2 += 1 + next();
  return v2;
}
function read_deltas(n, next) {
  let v2 = Array(n);
  for (let i2 = 0, x2 = 0; i2 < n; i2++)
    v2[i2] = x2 += signed(next());
  return v2;
}
function read_member_array(next, lookup2) {
  let v2 = read_ascending(next(), next);
  let n = next();
  let vX = read_ascending(n, next);
  let vN = read_counts(n, next);
  for (let i2 = 0; i2 < n; i2++) {
    for (let j2 = 0; j2 < vN[i2]; j2++) {
      v2.push(vX[i2] + j2);
    }
  }
  return lookup2 ? v2.map((x2) => lookup2[x2]) : v2;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v2 = [];
  while (true) {
    let i2 = next();
    if (i2 == 0)
      break;
    v2.push(i2);
  }
  return v2;
}
function read_transposed(n, w2, next) {
  let m2 = Array(n).fill(void 0).map(() => []);
  for (let i2 = 0; i2 < w2; i2++) {
    read_deltas(n, next).forEach((x2, j2) => m2[j2].push(x2));
  }
  return m2;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m2 = read_transposed(vN.length, 1 + w2, next);
  return flat(m2.map((v2, i2) => {
    const x2 = v2[0], ys = v2.slice(1);
    return Array(vN[i2]).fill(void 0).map((_2, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y2) => y2 + j_dy)];
    });
  }));
}
function read_replacement_table(w2, next) {
  let n = 1 + next();
  let m2 = read_transposed(n, 1 + w2, next);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a2, b2) => a2 - b2);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read() });
    }
    branches.sort((a2, b2) => b2.set.size - a2.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}
function getData() {
  return read_compressed_payload(decode$2("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$2 = getData();
const VALID = new Set(read_member_array(r$2));
const IGNORED = new Set(read_member_array(r$2));
const MAPPED = read_mapped_map(r$2);
const EMOJI_ROOT = read_emoji_trie(r$2);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i2 = cps.lastIndexOf(UNDERSCORE) - 1; i2 >= 0; i2--) {
        if (cps[i2] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize(name2, filter_fe0f));
}
function normalize(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a2;
  let node2 = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node2 = (_a2 = node2.branches.find((x2) => x2.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
    if (!node2)
      break;
    if (node2.save) {
      saved = cp;
    } else if (node2.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node2.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node2.valid) {
      emoji = stack.slice();
      if (node2.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$e = new Logger(version$b);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i2 = 0; i2 < bytes.length; i2++) {
    const d2 = bytes[i2];
    if (d2 === 46) {
      comps.push(checkComponent(bytes.slice(last, i2)));
      last = i2 + 1;
    }
  }
  if (last >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger$e.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256(concat$1([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat$1(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$d = new Logger(version$b);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$d.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$d.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger$d.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error) {
    }
    return logger$d.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$d.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$d.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$d.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger$d.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$d.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$d.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$d.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger$d.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger$d.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$d.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types[name2]) + st.map((t) => encodeType(t, types[t])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger$d.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$d.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$d.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak256(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger$d.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$d.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger$d.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak256(TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types, value, resolveName2) {
    return __awaiter$i(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger$d.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$d.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$d.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const logger$c = new Logger(version$f);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
class Interface {
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$c.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$c.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.full;
    }
    if (format2 === FormatTypes.sighash) {
      logger$c.throwArgumentError("interface does not support formatting sighash", "format", format2);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format2));
    if (format2 === FormatTypes.json) {
      return JSON.stringify(abi.map((j2) => JSON.parse(j2)));
    }
    return abi;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$c.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$c.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$c.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$c.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$c.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$c.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$c.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$c.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger$c.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$c.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$c.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$c.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_2) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data2) {
    return this._abiCoder.decode(params, data2);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data2) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify(data2);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$c.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat$1([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify(data2);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$c.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat$1([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify(data2);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$c.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data2),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$c.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger$c.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$c.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$c.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data2, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$c.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat$1(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index]) {
          result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i2 = 0; i2 < result.length; i2++) {
      const value = result[i2];
      if (value instanceof Error) {
        Object.defineProperty(result, i2, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i2}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data2) {
    const hexData = hexlify(data2);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const version$a = "abstract-provider/5.7.0";
var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$b = new Logger(version$a);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$b.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$h(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$9 = "abstract-signer/5.7.0";
var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger(version$9);
const allowedTransactionKeys$1 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$a.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$g(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$1.indexOf(key2) === -1) {
        logger$a.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$a.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter$g(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$g(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$a.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$a.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$a.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$a.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$a.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$a.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$a.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$a.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$a.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}
var hash$3 = {};
var utils$w = {};
var minimalisticAssert$1 = assert$g;
function assert$g(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$g.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browserExports = {};
var inherits_browser$1 = {
  get exports() {
    return inherits_browserExports;
  },
  set exports(v2) {
    inherits_browserExports = v2;
  }
};
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var assert$f = minimalisticAssert$1;
var inherits$e = inherits_browserExports;
utils$w.inherits = inherits$e;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$w.toArray = toArray;
function toHex$1(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$w.toHex = toHex$1;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$w.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w2 = msg[i2];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$w.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$w.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$w.zero8 = zero8;
function join32(msg, start2, end, endian) {
  var len2 = end - start2;
  assert$f(len2 % 4 === 0);
  var res = new Array(len2 / 4);
  for (var i2 = 0, k = start2; i2 < res.length; i2++, k += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
    else
      w2 = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i2] = w2 >>> 0;
  }
  return res;
}
utils$w.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k = 0; i2 < msg.length; i2++, k += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k] = m2 >>> 24;
      res[k + 1] = m2 >>> 16 & 255;
      res[k + 2] = m2 >>> 8 & 255;
      res[k + 3] = m2 & 255;
    } else {
      res[k + 3] = m2 >>> 24;
      res[k + 2] = m2 >>> 16 & 255;
      res[k + 1] = m2 >>> 8 & 255;
      res[k] = m2 & 255;
    }
  }
  return res;
}
utils$w.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$w.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$w.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$w.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$w.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$w.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e) {
  return a2 + b2 + c2 + d2 + e >>> 0;
}
utils$w.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$w.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$w.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$w.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch2, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch2 + dh + carry;
  return hi >>> 0;
}
utils$w.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch2, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$w.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch2 + dh + eh + carry;
  return hi >>> 0;
}
utils$w.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$w.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$w.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$w.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$w.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$w.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$v = utils$w;
var assert$e = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$v.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$v.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$e(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad2() {
  var len2 = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len2 + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k; i2++)
    res[i2] = 0;
  len2 <<= 3;
  if (this.endian === "big") {
    for (var t = 8; t < this.padLength; t++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 & 255;
  } else {
    res[i2++] = len2 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t = 8; t < this.padLength; t++)
      res[i2++] = 0;
  }
  return res;
};
var sha$2 = {};
var common$4 = {};
var utils$u = utils$w;
var rotr32 = utils$u.rotr32;
function ft_1$1(s2, x2, y2, z2) {
  if (s2 === 0)
    return ch32$1(x2, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y2, z2);
  if (s2 === 2)
    return maj32$1(x2, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$t = utils$w;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$t.rotl32;
var sum32$2 = utils$t.sum32;
var sum32_5$1 = utils$t.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$t.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start2) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start2 + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e = this.h[4];
  for (i2 = 0; i2 < W2.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e, W2[i2], sha1_K[s2]);
    e = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$t.toHex32(this.h, "big");
  else
    return utils$t.split32(this.h, "big");
};
var utils$s = utils$w;
var common$2 = common$5;
var shaCommon = common$4;
var assert$d = minimalisticAssert$1;
var sum32$1 = utils$s.sum32;
var sum32_4$1 = utils$s.sum32_4;
var sum32_5 = utils$s.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$s.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start2) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start2 + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$d(this.k.length === W2.length);
  for (i2 = 0; i2 < W2.length; i2++) {
    var T1 = sum32_5(h2, s1_256(e), ch32(e, f2, g2), this.k[i2], W2[i2]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e;
    e = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$s.toHex32(this.h, "big");
  else
    return utils$s.split32(this.h, "big");
};
var utils$r = utils$w;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$r.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$r.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$r.split32(this.h.slice(0, 7), "big");
};
var utils$q = utils$w;
var common$1 = common$5;
var assert$c = minimalisticAssert$1;
var rotr64_hi = utils$q.rotr64_hi;
var rotr64_lo = utils$q.rotr64_lo;
var shr64_hi = utils$q.shr64_hi;
var shr64_lo = utils$q.shr64_lo;
var sum64 = utils$q.sum64;
var sum64_hi = utils$q.sum64_hi;
var sum64_lo = utils$q.sum64_lo;
var sum64_4_hi = utils$q.sum64_4_hi;
var sum64_4_lo = utils$q.sum64_4_lo;
var sum64_5_hi = utils$q.sum64_5_hi;
var sum64_5_lo = utils$q.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$q.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start2) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W2[i2] = msg[start2 + i2];
  for (; i2 < W2.length; i2 += 2) {
    var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
    var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
    var c1_hi = W2[i2 - 14];
    var c1_lo = W2[i2 - 13];
    var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
    var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
    var c3_hi = W2[i2 - 32];
    var c3_lo = W2[i2 - 31];
    W2[i2] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i2 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$2.prototype._update = function _update3(msg, start2) {
  this._prepareBlock(msg, start2);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch2 = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl2 = this.h[15];
  assert$c(this.k.length === W2.length);
  for (var i2 = 0; i2 < W2.length; i2 += 2) {
    var c0_hi = hh;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W2[i2];
    var c4_lo = W2[i2 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch2);
    c1_lo = maj64_lo(ah, al, bh, bl, ch2, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl2 = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch2, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl2);
};
SHA512$2.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$q.toHex32(this.h, "big");
  else
    return utils$q.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ ~xh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh, zl2) {
  var r2 = xl & yl ^ ~xl & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ xh & zh ^ yh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh, zl2) {
  var r2 = xl & yl ^ xl & zl2 ^ yl & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$p = utils$w;
var SHA512$1 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$p.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$p.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$p.split32(this.h.slice(0, 12), "big");
};
sha$2.sha1 = _1;
sha$2.sha224 = _224;
sha$2.sha256 = _256;
sha$2.sha384 = _384;
sha$2.sha512 = _512;
var ripemd = {};
var utils$o = utils$w;
var common = common$5;
var rotl32 = utils$o.rotl32;
var sum32 = utils$o.sum32;
var sum32_3 = utils$o.sum32_3;
var sum32_4 = utils$o.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160$2() {
  if (!(this instanceof RIPEMD160$2))
    return new RIPEMD160$2();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$o.inherits(RIPEMD160$2, BlockHash);
ripemd.ripemd160 = RIPEMD160$2;
RIPEMD160$2.blockSize = 512;
RIPEMD160$2.outSize = 160;
RIPEMD160$2.hmacStrength = 192;
RIPEMD160$2.padLength = 64;
RIPEMD160$2.prototype._update = function update2(msg, start2) {
  var A2 = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E2 = this.h[4];
  var Ah = A2;
  var Bh = B;
  var Ch2 = C;
  var Dh = D;
  var Eh = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$1(j2, B, C, D), msg[r$1[j2] + start2], K$5(j2)),
        s$1[j2]
      ),
      E2
    );
    A2 = E2;
    E2 = D;
    D = rotl32(C, 10);
    C = B;
    B = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah, f$1(79 - j2, Bh, Ch2, Dh), msg[rh[j2] + start2], Kh(j2)),
        sh[j2]
      ),
      Eh
    );
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch2, 10);
    Ch2 = Bh;
    Bh = T2;
  }
  T2 = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E2, Ah);
  this.h[3] = sum32_3(this.h[4], A2, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch2);
  this.h[0] = T2;
};
RIPEMD160$2.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$o.toHex32(this.h, "little");
  else
    return utils$o.split32(this.h, "little");
};
function f$1(j2, x2, y2, z2) {
  if (j2 <= 15)
    return x2 ^ y2 ^ z2;
  else if (j2 <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$5(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$n = utils$w;
var assert$b = minimalisticAssert$1;
function Hmac(hash3, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash3, key2, enc);
  this.Hash = hash3;
  this.blockSize = hash3.blockSize / 8;
  this.outSize = hash3.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$n.toArray(key2, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init2(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$b(key2.length <= this.blockSize);
  for (var i2 = key2.length; i2 < this.blockSize; i2++)
    key2.push(0);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports2) {
  var hash3 = exports2;
  hash3.utils = utils$w;
  hash3.common = common$5;
  hash3.sha = sha$2;
  hash3.ripemd = ripemd;
  hash3.hmac = hmac;
  hash3.sha1 = hash3.sha.sha1;
  hash3.sha256 = hash3.sha.sha256;
  hash3.sha224 = hash3.sha.sha224;
  hash3.sha384 = hash3.sha.sha384;
  hash3.sha512 = hash3.sha.sha512;
  hash3.ripemd160 = hash3.ripemd.ripemd160;
})(hash$3);
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$a;
function assert$a(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$a.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module, exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode4(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports2) {
  var utils2 = exports2;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z2;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i2] = z2;
      k.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes) {
    return new BN$9(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF$1 = utils_1$1.getNAF;
var getJSF$1 = utils_1$1.getJSF;
var assert$1$1 = utils_1$1.assert;
function BaseCurve$1(type, conf) {
  this.type = type;
  this.p = new BN$9(conf.p, 16);
  this.red = conf.prime ? BN$9.red(conf.prime) : BN$9.mont(this.p);
  this.zero = new BN$9(0).toRed(this.red);
  this.one = new BN$9(1).toRed(this.red);
  this.two = new BN$9(2).toRed(this.red);
  this.n = conf.n && new BN$9(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$3 = BaseCurve$1;
BaseCurve$1.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function _fixedNafMul(p2, k) {
  assert$1$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF$1(k, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve$1.prototype._wnafMul = function _wnafMul(p2, k) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF$1(k, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z2 = naf[i2];
    assert$1$1(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve$1.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len2; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF$1(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF$1(coeffs[b2], wndWidth[b2], this._bitLength);
      max = Math.max(naf[a2].length, max);
      max = Math.max(naf[b2].length, max);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b2]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF$1(coeffs[a2], coeffs[b2]);
    max = Math.max(jsf[0].length, max);
    naf[a2] = new Array(max);
    naf[b2] = new Array(max);
    for (j2 = 0; j2 < max; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max; i2 >= 0; i2--) {
    var k = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len2; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i2--;
    }
    if (i2 >= 0)
      k++;
    acc = acc.dblp(k);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len2; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len2; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint$1(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len2 = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
    if (bytes[0] === 6)
      assert$1$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len2),
      bytes.slice(1 + len2, 1 + 2 * len2)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2) {
    return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint$1.prototype._encode = function _encode2(compact2) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact2)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint$1.prototype.encode = function encode2(enc, compact2) {
  return utils_1$1.encode(this._encode(compact2), enc);
};
BasePoint$1.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint$1.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint$1.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint$1.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl7 = max === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max; i2++)
    res[i2] = res[i2 - 1].add(dbl7);
  return {
    wnd,
    points: res
  };
};
BasePoint$1.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint$1.prototype.dblp = function dblp(k) {
  var r2 = this;
  for (var i2 = 0; i2 < k; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2$1 = utils_1$1.assert;
function ShortCurve$1(conf) {
  base$3.call(this, "short", conf);
  this.a = new BN$9(conf.a, 16).toRed(this.red);
  this.b = new BN$9(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve$1, base$3);
var short_1 = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$9(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$9(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2$1(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$9(vec.a, 16),
        b: new BN$9(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve$1.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$9.mont(num);
  var tinv = new BN$9(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$9(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve$1.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$9(1);
  var y1 = new BN$9(0);
  var x2 = new BN$9(0);
  var y2 = new BN$9(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q = v2.div(u2);
    r2 = v2.sub(q.mul(u2));
    x3 = x2.sub(q.mul(x1));
    var y3 = y2.sub(q.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve$1.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve$1.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$9(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve$1.prototype.validate = function validate3(point7) {
  if (point7.inf)
    return true;
  var x2 = point7.x;
  var y2 = point7.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point$3(curve2, x2, y2, isRed) {
  base$3.BasePoint.call(this, curve2, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$9(x2, 16);
    this.y = new BN$9(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point$3, base$3.BasePoint);
ShortCurve$1.prototype.point = function point2(x2, y2, isRed) {
  return new Point$3(this, x2, y2, isRed);
};
ShortCurve$1.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$3.fromJSON(this, obj, red);
};
Point$3.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p2) {
      return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$3.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$3.fromJSON = function fromJSON(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$3.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point$3.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$3.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$3.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point$3.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point$3.prototype.mul = function mul(k) {
  k = new BN$9(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point$3.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$3.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$3.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point$3.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$3.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint$1(curve2, x2, y2, z2) {
  base$3.BasePoint.call(this, curve2, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$9(0);
  } else {
    this.x = new BN$9(x2, 16);
    this.y = new BN$9(y2, 16);
    this.z = new BN$9(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint$1, base$3.BasePoint);
ShortCurve$1.prototype.jpoint = function jpoint(x2, y2, z2) {
  return new JPoint$1(this, x2, y2, z2);
};
JPoint$1.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint$1.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint$1.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint$1.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m2.redSqr().redISub(s2).redISub(s2);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t.redISub(u2)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.mul = function mul2(k, kbase) {
  k = new BN$9(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint$1.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint$1.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports2) {
  var curve2 = exports2;
  curve2.base = base$3;
  curve2.short = short_1;
  curve2.mont = null;
  curve2.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports2) {
  var curves2 = exports2;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG$2(options) {
  if (!(this instanceof HmacDRBG$2))
    return new HmacDRBG$2(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg$1 = HmacDRBG$2;
HmacDRBG$2.prototype._init = function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG$2.prototype._hmac = function hmac2() {
  return new hash$3.hmac(this.hash, this.K);
};
HmacDRBG$2.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG$2.prototype.reseed = function reseed(entropy, entropyEnc, add7, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add7;
    add7 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add7 = utils_1.toArray(add7, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add7 || []));
  this._reseed = 1;
};
HmacDRBG$2.prototype.generate = function generate(len2, enc, add7, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add7;
    add7 = enc;
    enc = null;
  }
  if (add7) {
    add7 = utils_1.toArray(add7, addEnc || "hex");
    this._update(add7);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add7);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3$1 = utils_1$1.assert;
function KeyPair$4(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$2 = KeyPair$4;
KeyPair$4.fromPublic = function fromPublic(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$4)
    return pub2;
  return new KeyPair$4(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$4.fromPrivate = function fromPrivate(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$4)
    return priv2;
  return new KeyPair$4(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$4.prototype.validate = function validate4() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$4.prototype.getPublic = function getPublic(compact2, enc) {
  if (typeof compact2 === "string") {
    enc = compact2;
    compact2 = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact2);
};
KeyPair$4.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$4.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$9(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$4.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3$1(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3$1(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$4.prototype.derive = function derive(pub2) {
  if (!pub2.validate()) {
    assert$3$1(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$4.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$4.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair$4.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4$1 = utils_1$1.assert;
function Signature$4(options, enc) {
  if (options instanceof Signature$4)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4$1(options.r && options.s, "Signature without r or s");
  this.r = new BN$9(options.r, 16);
  this.s = new BN$9(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$2 = Signature$4;
function Position$1() {
  this.place = 0;
}
function getLength$1(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding$1(buf) {
  var i2 = 0;
  var len2 = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature$4.prototype._importDER = function _importDER(data2, enc) {
  data2 = utils_1$1.toArray(data2, enc);
  var p2 = new Position$1();
  if (data2[p2.place++] !== 48) {
    return false;
  }
  var len2 = getLength$1(data2, p2);
  if (len2 === false) {
    return false;
  }
  if (len2 + p2.place !== data2.length) {
    return false;
  }
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength$1(data2, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength$1(data2, p2);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p2.place) {
    return false;
  }
  var s2 = data2.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$9(r2);
  this.s = new BN$9(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength$1(arr, len2) {
  if (len2 < 128) {
    arr.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len2 >>> (octets << 3) & 255);
  }
  arr.push(len2);
}
Signature$4.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding$1(r2);
  s2 = rmPadding$1(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength$1(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength$1(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength$1(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand$1 = function() {
  throw new Error("unsupported");
};
var assert$5$1 = utils_1$1.assert;
function EC$1(options) {
  if (!(this instanceof EC$1))
    return new EC$1(options);
  if (typeof options === "string") {
    assert$5$1(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec$1 = EC$1;
EC$1.prototype.keyPair = function keyPair(options) {
  return new key$2(this, options);
};
EC$1.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
  return key$2.fromPrivate(this, priv2, enc);
};
EC$1.prototype.keyFromPublic = function keyFromPublic(pub2, enc) {
  return key$2.fromPublic(this, pub2, enc);
};
EC$1.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg$1({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand$1(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$9(2));
  for (; ; ) {
    var priv2 = new BN$9(drbg.generate(bytes));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC$1.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC$1.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$9(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg$1({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$9(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new BN$9(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature$2({ r: r2, s: s2, recoveryParam });
  }
};
EC$1.prototype.verify = function verify2(msg, signature$12, key2, enc) {
  msg = this._truncateToN(new BN$9(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$12 = new signature$2(signature$12, "hex");
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC$1.prototype.recoverPubKey = function(msg, signature$12, j2, enc) {
  assert$5$1((3 & j2) === j2, "The recovery param is more than two bits");
  signature$12 = new signature$2(signature$12, enc);
  var n = this.n;
  var e = new BN$9(msg);
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$12.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC$1.prototype.getKeyRecoveryParam = function(e, signature$12, Q, enc) {
  signature$12 = new signature$2(signature$12, enc);
  if (signature$12.recoveryParam !== null)
    return signature$12.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$12, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports2) {
  var elliptic2 = exports2;
  elliptic2.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic2.utils = utils_1$1;
  elliptic2.rand = function() {
    throw new Error("unsupported");
  };
  elliptic2.curve = curve_1;
  elliptic2.curves = curves_1;
  elliptic2.ec = ec$1;
  elliptic2.eddsa = null;
});
var EC$1$1 = elliptic_1.ec;
const version$8 = "signing-key/5.7.0";
const logger$9 = new Logger(version$8);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$9.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair3.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair3.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$9.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair3.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair3.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger$9.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$7 = "transactions/5.7.0";
const logger$8 = new Logger(version$7);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest9), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$8.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$8.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index) => {
      if (Array.isArray(set2)) {
        if (set2.length > 2) {
          logger$8.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set2);
        }
        return accessSetify(set2[0], set2[1]);
      }
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$8.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$4(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$4(fields)]);
}
function _parseEipSignature(tx, fields, serialize) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$8.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256(serialize(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode$3(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$8.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$3(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$8.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$3(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$8.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256(encode$4(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$8.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const version$6 = "contracts/5.7.0";
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$7 = new Logger(version$6);
function resolveName(resolver, nameOrPromise) {
  return __awaiter$f(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger$7.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger$7.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger$7.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$f(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$7.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v2) => resolveAddresses(resolver, v2, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$f(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger$7.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter$f(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger$7.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data2,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data2);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        intrinsic += 4;
        if (bytes[i2]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$7.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger$7.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$f(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$7.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data2, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$f(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$f(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$7.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once3) {
    this._listeners.push({ listener, once: once3 });
  }
  removeListener(listener) {
    let done2 = false;
    this._listeners = this._listeners.filter((item) => {
      if (done2 || item.listener !== listener) {
        return true;
      }
      done2 = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i2) => i2.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount2 = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount2;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$7.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag$1(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data2, topics) => {
      return this.interface.decodeEventLog(this.fragment, data2, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data2, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger$7.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger$7.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$7.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger$7.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger$7.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger$7.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger$7.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger$7.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit2 = this._wrappedEmits[runningEvent.tag];
      if (emit2 && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit2);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once3) {
    if (!this.provider) {
      logger$7.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once3);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$7.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
let Contract$1 = class Contract2 extends BaseContract {
};
class BaseX {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    }
    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte = this._alphabetMap[value[i2]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j2 = 0; j2 < bytes.length; ++j2) {
        carry += bytes[j2] * this.base;
        bytes[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const version$5 = "sha2/5.7.0";
new Logger(version$5);
function sha256$2(data2) {
  return "0x" + hash$3.sha256().update(arrayify(data2)).digest("hex");
}
const version$4 = "networks/5.7.1";
const logger$6 = new Logger(version$4);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$6.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$6.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$3 = "web/5.7.1";
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$e(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request2 = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request2.mode = "cors";
      request2.cache = "no-cache";
      request2.credentials = "same-origin";
      request2.redirect = "follow";
      request2.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request2.mode = opts.mode;
      }
      if (opts.cache) {
        request2.cache = opts.cache;
      }
      if (opts.credentials) {
        request2.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request2.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request2.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request2);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$5 = new Logger(version$3);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$5.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$5.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$5.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$5.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$3(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode$2(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$5.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$5.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$d(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$5.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$5.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$5.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$5.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$5.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k) => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done2 = false;
    const cancel = () => {
      if (done2) {
        return false;
      }
      done2 = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done2) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var ALPHABET$1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET$1.length; z++) {
  var x = ALPHABET$1.charAt(z);
  if (ALPHABET_MAP[x] !== void 0)
    throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  var b2 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
}
function prefixChk(prefix2) {
  var chk = 1;
  for (var i2 = 0; i2 < prefix2.length; ++i2) {
    var c2 = prefix2.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix2 + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i2 = 0; i2 < prefix2.length; ++i2) {
    var v2 = prefix2.charCodeAt(i2);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function encode$2(prefix2, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix2.length + 7 + words.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix2 = prefix2.toLowerCase();
  var chk = prefixChk(prefix2);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix2 + "1";
  for (var i2 = 0; i2 < words.length; ++i2) {
    var x2 = words[i2];
    if (x2 >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET$1.charAt(x2);
  }
  for (i2 = 0; i2 < 6; ++i2) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i2 = 0; i2 < 6; ++i2) {
    var v2 = chk >> (5 - i2) * 5 & 31;
    result += ALPHABET$1.charAt(v2);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str;
  if (split === 0)
    return "Missing prefix for " + str;
  var prefix2 = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix2);
  if (typeof chk === "string")
    return chk;
  var words = [];
  for (var i2 = 0; i2 < wordChars.length; ++i2) {
    var c2 = wordChars.charAt(i2);
    var v2 = ALPHABET_MAP[c2];
    if (v2 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v2;
    if (i2 + 6 >= wordChars.length)
      continue;
    words.push(v2);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix: prefix2, words };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$1(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert(data2, inBits, outBits, pad3) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i2 = 0; i2 < data2.length; ++i2) {
    value = value << inBits | data2[i2];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad3) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$1,
  encode: encode$2,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const version$2 = "providers/5.7.2";
const logger$4 = new Logger(version$2);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data2 = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash3,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash3, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data: data2,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data2)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash3,
      address,
      topics: Formatter.arrayOf(hash3),
      data: data2,
      logIndex: number,
      blockHash: hash3
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data2),
      blockHash: hash3,
      transactionHash: hash3,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash3),
      parentHash: hash3,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data2,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash3, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash3),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data2, "0x"),
      topics: Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$4.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$4.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format2) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format2, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$4.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$4.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$4.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format2, object) {
    const result = {};
    for (const key2 in format2) {
      try {
        const value = format2[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format2, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format2(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format2, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format2(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format2) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format2(value));
      });
      return result;
    };
  }
}
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$3 = new Logger(version$2);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$3.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$3.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once3) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once3);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return Base58.encode(concat$1([data2, hexDataSlice(sha256$2(sha256$2(data2)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers$1 = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start2) {
  try {
    return toUtf8String(_parseBytes(result, start2));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start2) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start2, start2 + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$3.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i2 = 0; i2 < datas.length; i2++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i2 = 0; i2 < datas.length; i2++) {
    const data2 = arrayify(datas[i2]);
    result[i2] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes2 = false;
      if (yield this.supportsWildcard()) {
        parseBytes2 = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$3.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes2) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$3.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat$1([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat$1([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version2 = bytes[0];
      if (version2 === 0) {
        if (length !== 20 && length !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words = bech32.toWords(bytes.slice(2));
        words.unshift(version2);
        return bech32.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$3.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers$1.length; i2++) {
          const match = avatar.match(matchers$1[i2]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash3 = encode$3("0x" + skynet[1]).replace(/[=+\/]/g, (a2) => urlSafe[a2]);
          return "sia://" + hash3;
        }
      }
      return logger$3.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat$1([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat$1([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$3.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$3.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data2 = calldata.toLowerCase();
      const errorMessages = [];
      for (let i2 = 0; i2 < urls.length; i2++) {
        const url = urls[i2];
        const href = url.replace("{sender}", sender).replace("{data}", data2);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$3.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$3.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$3.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$3.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter2.fromBlock) {
                filter2.fromBlock = minFromBlock;
              }
              if (filter2.fromBlock < 0) {
                filter2.fromBlock = 0;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter2, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$c(this, void 0, void 0, function* () {
      return logger$3.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger$3.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$c(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done2 = false;
        const alreadyDone = function() {
          if (done2) {
            return true;
          }
          done2 = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$c(this, void 0, void 0, function* () {
            if (done2) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$c(this, void 0, void 0, function* () {
              if (done2) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done2) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done2) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$3.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done2) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$3.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$c(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger$3.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout) => __awaiter$c(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$3.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t) => hexlify(t));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$3.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data2 = hexDataSlice(result, 4);
          const sender = hexDataSlice(data2, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$3.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data2, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data2, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data2, urlsOffset + 32);
          for (let u2 = 0; u2 < urlsLength; u2++) {
            const url = _parseString(urlsData, u2 * 32);
            if (url == null) {
              logger$3.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data2, 64);
          if (!BigNumber.from(hexDataSlice(data2, 100, 128)).isZero()) {
            logger$3.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data2, 96, 100);
          const extraData = _parseBytes(data2, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger$3.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$3.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$c(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$3.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$3.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$3.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$c(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$c(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$c(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$3.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$3.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger$3.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$c(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node2, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node2).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$c(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node2, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node2);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node2).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$3.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once3) {
    const event = new Event(getEventTag(eventName), listener, once3);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$2 = new Logger(version$2);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData2) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data2 = isHexString(value.data) ? value.data : null;
    if (!requireData2 || data2) {
      return { message: value.message, data: data2 };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData2);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData2);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger$2.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger$2.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$2.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$2.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$2.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$2.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$2.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer$1(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$2.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$2.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$2.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter$b(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$2.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$2.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$2.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$2.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter$b(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash3;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$2.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$2.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$2.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield timer$1(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$2.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$2.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request2 = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request2),
      provider: this
    });
    const cache2 = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache2 && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request2), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request: request2,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request2,
        provider: this
      });
      throw error;
    });
    if (cache2) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$2.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer$1(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}
const logger$1 = new Logger(version$2);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request2 = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request2),
        provider: this
      });
      sendFunc(request2, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request: request2,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request: request2,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request2 = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request2),
      provider: this
    });
    return provider.request(request2).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request2,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request2,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger$1.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger$1.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
const version$1 = "units/5.7.0";
const logger = new Logger(version$1);
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
const bridgeABI = [];
const tokenABI = [];
class MetaMask extends Wallet$1 {
  constructor() {
    super();
    if (!window.ethereum) {
      this.available = false;
    } else {
      this.available = true;
      this.provider = new Web3Provider(window.ethereum);
    }
  }
  async connectInjected() {
    if (!this.available)
      throw new Error("MetaMask is not installed");
    await this.provider.send("eth_requestAccounts", []);
    const signer = this.provider.getSigner();
    this.address = await signer.getAddress();
    return this.address;
  }
  async connectExternal(cb) {
    throw new Error("External MetaMask is not supported.");
  }
  async lockCoins(destAddress, destCoinId, amount) {
    const signer = this.provider.getSigner();
    const bridgeContract = new Contract$1(BRIDGE_ADDRESS, bridgeABI, signer);
    await bridgeContract.lock(destAddress, destCoinId, { value: parseEther(amount) });
  }
  async burnTokens(token, amount) {
    const signer = this.provider.getSigner();
    const tokenContract = new Contract$1(token, tokenABI, signer);
    await tokenContract.burn(amount);
  }
}
var axiosExports$1 = {};
var axios$3 = {
  get exports() {
    return axiosExports$1;
  },
  set exports(v2) {
    axiosExports$1 = v2;
  }
};
var axiosExports = {};
var axios$2 = {
  get exports() {
    return axiosExports;
  },
  set exports(v2) {
    axiosExports = v2;
  }
};
var bind$2 = function bind2(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray$1(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return toString.call(val) === "[object FormData]";
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate$1(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction$2(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction$2(val.pipe);
}
function isURLSearchParams(val) {
  return toString.call(val) === "[object URLSearchParams]";
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key2) {
    if (isPlainObject(result[key2]) && isPlainObject(val)) {
      result[key2] = merge(result[key2], val);
    } else if (isPlainObject(val)) {
      result[key2] = merge({}, val);
    } else if (isArray$1(val)) {
      result[key2] = val.slice();
    } else {
      result[key2] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue);
  }
  return result;
}
function extend(a2, b2, thisArg) {
  forEach(b2, function assignValue(val, key2) {
    if (thisArg && typeof val === "function") {
      a2[key2] = bind$1(val, thisArg);
    } else {
      a2[key2] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$m = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim,
  stripBOM
};
var utils$l = utils$m;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$l.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$l.forEach(params, function serialize(val, key2) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$l.isArray(val)) {
        key2 = key2 + "[]";
      } else {
        val = [val];
      }
      utils$l.forEach(val, function parseValue(v2) {
        if (utils$l.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$l.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$1(key2) + "=" + encode$1(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$k = utils$m;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$k.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$j = utils$m;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$j.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$2 = function enhanceError2(error, config2, code2, request2, response) {
  error.config = config2;
  if (code2) {
    error.code = code2;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON3() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var enhanceError$1 = enhanceError$2;
var createError$1 = function createError2(message, config2, code2, request2, response) {
  var error = new Error(message);
  return enhanceError$1(error, config2, code2, request2, response);
};
var createError = createError$1;
var settle = function settle2(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      "Request failed with status code " + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$m;
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;
var buildFullPath = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$m;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key2;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line) {
      i2 = line.indexOf(":");
      key2 = utils2.trim(line.substr(0, i2)).toLowerCase();
      val = utils2.trim(line.substr(i2 + 1));
      if (key2) {
        if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
          return;
        }
        if (key2 === "set-cookie") {
          parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
        } else {
          parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$m;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel2(message) {
    this.message = message;
  }
  Cancel2.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel2.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel2;
  return Cancel_1;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$m;
  var settle$1 = settle;
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath$1 = buildFullPath;
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError3 = createError$1;
  var transitionalDefaults2 = transitional;
  var Cancel2 = requireCancel();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      var onCanceled;
      function done2() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath$1(config2.baseURL, config2.url);
      request2.open(config2.method.toUpperCase(), buildURL3(fullPath, config2.params, config2.paramsSerializer), true);
      request2.timeout = config2.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2
        };
        settle$1(function _resolve(value) {
          resolve(value);
          done2();
        }, function _reject(err) {
          reject(err);
          done2();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError3("Request aborted", config2, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(createError3("Network Error", config2, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config2.transitional || transitionalDefaults2;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(createError3(
          timeoutErrorMessage,
          config2,
          transitional3.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key2) {
          if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
            delete requestHeaders[key2];
          } else {
            request2.setRequestHeader(key2, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
          request2.abort();
          request2 = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var utils$i = utils$m;
var normalizeHeaderName = normalizeHeaderName$1;
var enhanceError = enhanceError$2;
var transitionalDefaults = transitional;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$i.isUndefined(headers) && utils$i.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$i.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$i.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils$i.isFormData(data2) || utils$i.isArrayBuffer(data2) || utils$i.isBuffer(data2) || utils$i.isStream(data2) || utils$i.isFile(data2) || utils$i.isBlob(data2)) {
      return data2;
    }
    if (utils$i.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$i.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$i.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional3 = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$i.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw enhanceError(e, this, "E_JSON_PARSE");
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$i.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$i.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$i.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$h = utils$m;
var defaults$2 = defaults_1;
var transformData$1 = function transformData2(data2, headers, fns) {
  var context = this || defaults$2;
  utils$h.forEach(fns, function transform(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$g = utils$m;
var transformData = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
var Cancel = requireCancel();
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new Cancel("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$g.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$g.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$f = utils$m;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  function getMergedValue(target, source) {
    if (utils$f.isPlainObject(target) && utils$f.isPlainObject(source)) {
      return utils$f.merge(target, source);
    } else if (utils$f.isPlainObject(source)) {
      return utils$f.merge({}, source);
    } else if (utils$f.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$f.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$f.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$f.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$f.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$f.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap2 = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$f.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap2[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$f.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.26.1"
  };
  return data;
}
var VERSION$1 = requireData().version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys = Object.keys(options);
  var i2 = keys.length;
  while (i2-- > 0) {
    var opt = keys[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$e = utils$m;
var buildURL = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config2) {
  if (typeof configOrUrl === "string") {
    config2 = config2 || {};
    config2.url = configOrUrl;
  } else {
    config2 = configOrUrl || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional3 = config2.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$e.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$e.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel2 = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i2;
      var l2 = token._listeners.length;
      for (i2 = 0; i2 < l2; i2++) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel2(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$m;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils$d = utils$m;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance2 = bind(Axios.prototype.request, context);
  utils$d.extend(instance2, Axios.prototype, context);
  utils$d.extend(instance2, context);
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.VERSION = requireData().version;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axiosExports.default = axios$1;
(function(module) {
  module.exports = axiosExports;
})(axios$3);
const axios = /* @__PURE__ */ getDefaultExportFromCjs(axiosExports$1);
function __awaiter$a(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var STATUS_CODE;
(function(STATUS_CODE2) {
  STATUS_CODE2[STATUS_CODE2["CONTINUE"] = 100] = "CONTINUE";
  STATUS_CODE2[STATUS_CODE2["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
  STATUS_CODE2[STATUS_CODE2["PROCESSING"] = 102] = "PROCESSING";
  STATUS_CODE2[STATUS_CODE2["OK"] = 200] = "OK";
  STATUS_CODE2[STATUS_CODE2["CREATED"] = 201] = "CREATED";
  STATUS_CODE2[STATUS_CODE2["ACCEPTED"] = 202] = "ACCEPTED";
  STATUS_CODE2[STATUS_CODE2["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
  STATUS_CODE2[STATUS_CODE2["NO_CONTENT"] = 204] = "NO_CONTENT";
  STATUS_CODE2[STATUS_CODE2["RESET_CONTENT"] = 205] = "RESET_CONTENT";
  STATUS_CODE2[STATUS_CODE2["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
  STATUS_CODE2[STATUS_CODE2["MULTI_STATUS"] = 207] = "MULTI_STATUS";
  STATUS_CODE2[STATUS_CODE2["ALREADY_REPORTED"] = 208] = "ALREADY_REPORTED";
  STATUS_CODE2[STATUS_CODE2["IM_USED"] = 226] = "IM_USED";
  STATUS_CODE2[STATUS_CODE2["MULTIPLE_CHOICES"] = 300] = "MULTIPLE_CHOICES";
  STATUS_CODE2[STATUS_CODE2["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
  STATUS_CODE2[STATUS_CODE2["FOUND"] = 302] = "FOUND";
  STATUS_CODE2[STATUS_CODE2["SEE_OTHER"] = 303] = "SEE_OTHER";
  STATUS_CODE2[STATUS_CODE2["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
  STATUS_CODE2[STATUS_CODE2["USE_PROXY"] = 305] = "USE_PROXY";
  STATUS_CODE2[STATUS_CODE2["SWITCH_PROXY"] = 306] = "SWITCH_PROXY";
  STATUS_CODE2[STATUS_CODE2["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
  STATUS_CODE2[STATUS_CODE2["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
  STATUS_CODE2[STATUS_CODE2["BAD_REQUEST"] = 400] = "BAD_REQUEST";
  STATUS_CODE2[STATUS_CODE2["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
  STATUS_CODE2[STATUS_CODE2["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["FORBIDDEN"] = 403] = "FORBIDDEN";
  STATUS_CODE2[STATUS_CODE2["NOT_FOUND"] = 404] = "NOT_FOUND";
  STATUS_CODE2[STATUS_CODE2["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
  STATUS_CODE2[STATUS_CODE2["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
  STATUS_CODE2[STATUS_CODE2["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
  STATUS_CODE2[STATUS_CODE2["CONFLICT"] = 409] = "CONFLICT";
  STATUS_CODE2[STATUS_CODE2["GONE"] = 410] = "GONE";
  STATUS_CODE2[STATUS_CODE2["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
  STATUS_CODE2[STATUS_CODE2["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
  STATUS_CODE2[STATUS_CODE2["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
  STATUS_CODE2[STATUS_CODE2["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
  STATUS_CODE2[STATUS_CODE2["RANGE_NOT_SATISFIABLE"] = 416] = "RANGE_NOT_SATISFIABLE";
  STATUS_CODE2[STATUS_CODE2["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
  STATUS_CODE2[STATUS_CODE2["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
  STATUS_CODE2[STATUS_CODE2["MISDIRECTED_REQUEST"] = 421] = "MISDIRECTED_REQUEST";
  STATUS_CODE2[STATUS_CODE2["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
  STATUS_CODE2[STATUS_CODE2["LOCKED"] = 423] = "LOCKED";
  STATUS_CODE2[STATUS_CODE2["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
  STATUS_CODE2[STATUS_CODE2["UPGRADE_REQUIRED"] = 426] = "UPGRADE_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  STATUS_CODE2[STATUS_CODE2["REQUEST_HEADER_FIELDS_TOO_LARGE"] = 431] = "REQUEST_HEADER_FIELDS_TOO_LARGE";
  STATUS_CODE2[STATUS_CODE2["UNAVAILABLE_FOR_LEGAL_REASONS"] = 451] = "UNAVAILABLE_FOR_LEGAL_REASONS";
  STATUS_CODE2[STATUS_CODE2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  STATUS_CODE2[STATUS_CODE2["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
  STATUS_CODE2[STATUS_CODE2["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
  STATUS_CODE2[STATUS_CODE2["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
  STATUS_CODE2[STATUS_CODE2["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
  STATUS_CODE2[STATUS_CODE2["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
  STATUS_CODE2[STATUS_CODE2["VARIANT_ALSO_NEGOTIATES"] = 506] = "VARIANT_ALSO_NEGOTIATES";
  STATUS_CODE2[STATUS_CODE2["INSUFFICIENT_STORAGE"] = 507] = "INSUFFICIENT_STORAGE";
  STATUS_CODE2[STATUS_CODE2["LOOP_DETECTED"] = 508] = "LOOP_DETECTED";
  STATUS_CODE2[STATUS_CODE2["NOT_EXTENDED"] = 510] = "NOT_EXTENDED";
  STATUS_CODE2[STATUS_CODE2["NETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NETWORK_AUTHENTICATION_REQUIRED";
})(STATUS_CODE || (STATUS_CODE = {}));
const isNode$1 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
const adapterPromise = isNode$1 ? void 0 : __vitePreload(() => import("./index-eda80c28.js"), true ? [] : void 0, import.meta.url).then((mod) => mod.default).catch(() => void 0);
var ResponseType;
(function(ResponseType2) {
  ResponseType2["TEXT"] = "text";
  ResponseType2["JSON"] = "json";
})(ResponseType || (ResponseType = {}));
class HttpResponseError extends Error {
  constructor(message, status, statusText, body, url) {
    super(message);
    this.message = message;
    this.status = status;
    this.statusText = statusText;
    this.body = body;
    this.url = url;
    this.name = "HttpResponse";
  }
}
class HttpRequestFailed extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "HttpRequestFailed";
  }
}
class HttpBackend {
  constructor(timeout = 3e4) {
    this.timeout = timeout;
  }
  serialize(obj) {
    if (!obj) {
      return "";
    }
    const str = [];
    for (const p2 in obj) {
      if (obj.hasOwnProperty(p2) && typeof obj[p2] !== "undefined") {
        const prop = typeof obj[p2].toJSON === "function" ? obj[p2].toJSON() : obj[p2];
        if (prop === null) {
          str.push(encodeURIComponent(p2));
          continue;
        }
        if (Array.isArray(prop)) {
          prop.forEach((item) => {
            str.push(encodeURIComponent(p2) + "=" + encodeURIComponent(item));
          });
          continue;
        }
        str.push(encodeURIComponent(p2) + "=" + encodeURIComponent(prop));
      }
    }
    const serialized = str.join("&");
    if (serialized) {
      return `?${serialized}`;
    } else {
      return "";
    }
  }
  /**
   *
   * @param options contains options to be passed for the HTTP request (url, method and timeout)
   */
  createRequest({ url, method, timeout = this.timeout, query, headers = {}, json = true }, data2) {
    return __awaiter$a(this, void 0, void 0, function* () {
      let resType;
      let transformResponse2 = void 0;
      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }
      if (!json) {
        resType = ResponseType.TEXT;
        transformResponse2 = [(v2) => v2];
      } else {
        resType = ResponseType.JSON;
      }
      try {
        const adapter = adapterPromise && (yield adapterPromise);
        const response = yield axios.request({
          url: url + this.serialize(query),
          method: method !== null && method !== void 0 ? method : "GET",
          headers,
          responseType: resType,
          transformResponse: transformResponse2,
          timeout,
          data: data2,
          adapter
        });
        return response.data;
      } catch (err) {
        if (axios.isAxiosError(err) && err.response) {
          let errorData;
          if (typeof err.response.data === "object") {
            errorData = JSON.stringify(err.response.data);
          } else {
            errorData = err.response.data;
          }
          throw new HttpResponseError(`Http error response: (${err.response.status}) ${errorData}`, err.response.status, err.response.statusText, errorData, url + this.serialize(query));
        } else {
          throw new HttpRequestFailed(`${method} ${url + this.serialize(query)} ${String(err)}`);
        }
      }
    });
  }
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start2, end) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from2(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding2(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len2 = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start2, end) {
    let loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start2 >>>= 0;
    if (end <= start2) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end);
        case "ascii":
          return asciiSlice(this, start2, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end);
        case "base64":
          return base64Slice(this, start2, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n, m2) {
    const i2 = b2[n];
    b2[n] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect9() {
    let str = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start2, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end) {
      return 1;
    }
    start2 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start2;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start2, end);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i2 + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON3() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end) {
    if (start2 === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end));
    }
  }
  function utf8Slice(buf, start2, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start2;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start2, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start2; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start2; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end) {
    const len2 = buf.length;
    if (!start2 || start2 < 0)
      start2 = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    let out = "";
    for (let i2 = start2; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end) {
    const bytes = buf.slice(start2, end);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start2, end) {
    const len2 = this.length;
    start2 = ~~start2;
    end = end === void 0 ? len2 : ~~end;
    if (start2 < 0) {
      start2 += len2;
      if (start2 < 0)
        start2 = 0;
    } else if (start2 > len2) {
      start2 = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start2)
      end = start2;
    const newBuf = this.subarray(start2, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul7 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul7 *= 256)) {
      val += this[offset + i2] * mul7;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul7 = 1;
    while (byteLength3 > 0 && (mul7 *= 256)) {
      val += this[offset + --byteLength3] * mul7;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul7 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul7 *= 256)) {
      val += this[offset + i2] * mul7;
    }
    mul7 *= 128;
    if (val >= mul7)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul7 = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul7 *= 256)) {
      val += this[offset + --i2] * mul7;
    }
    mul7 *= 128;
    if (val >= mul7)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul7 = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul7 *= 256)) {
      this[offset + i2] = value / mul7 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul7 = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul7 *= 256)) {
      this[offset + i2] = value / mul7 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul7 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul7 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul7 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul7 = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul7 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul7 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start2, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start2)
      start2 = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start2)
      end = start2;
    if (end === start2)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start2) {
      end = target.length - targetStart + start2;
    }
    const len2 = end - start2;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start2, end),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start2; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start2; ++i2) {
        this[i2 + start2] = bytes[i2 % len2];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base2) {
    errors[sym] = class NodeError extends Base2 {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start2 = val[0] === "-" ? 1 : 0;
    for (; i2 >= start2 + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range2 = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i2] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
var ed25519 = {};
var random = {};
var system = {};
var browser$2 = {};
Object.defineProperty(browser$2, "__esModule", { value: true });
browser$2.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length);
    for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
    }
    return out;
  }
}
browser$2.BrowserRandomSource = BrowserRandomSource;
var node = {};
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: true });
function wipe(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    array[i2] = 0;
  }
  return array;
}
wipe$1.wipe = wipe;
Object.defineProperty(node, "__esModule", { value: true });
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire$1 !== "undefined") {
      const nodeCrypto = require$$0$1;
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer2 = this._crypto.randomBytes(length);
    if (buffer2.length !== length) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length);
    for (let i2 = 0; i2 < out.length; i2++) {
      out[i2] = buffer2[i2];
    }
    (0, wipe_1.wipe)(buffer2);
    return out;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: true });
system.SystemRandomSource = void 0;
const browser_1 = browser$2;
const node_1 = node;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {};
var int = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  function imulShim(a2, b2) {
    var ah = a2 >>> 16 & 65535, al = a2 & 65535;
    var bh = b2 >>> 16 & 65535, bl = b2 & 65535;
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  }
  exports2.mul = Math.imul || imulShim;
  function add7(a2, b2) {
    return a2 + b2 | 0;
  }
  exports2.add = add7;
  function sub(a2, b2) {
    return a2 - b2 | 0;
  }
  exports2.sub = sub;
  function rotl2(x2, n) {
    return x2 << n | x2 >>> 32 - n;
  }
  exports2.rotl = rotl2;
  function rotr(x2, n) {
    return x2 << 32 - n | x2 >>> n;
  }
  exports2.rotr = rotr;
  function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
  }
  exports2.isInteger = Number.isInteger || isIntegerShim;
  exports2.MAX_SAFE_INTEGER = 9007199254740991;
  exports2.isSafeInteger = function(n) {
    return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: true });
var int_1 = int;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi * 4294967296 + lo;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi = readInt32LE(array, offset + 4);
  return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi = readUint32LE(array, offset + 4);
  return hi * 4294967296 + lo;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul7 = 1;
  for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
    result += array[i2] * mul7;
    mul7 *= 256;
  }
  return result;
}
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul7 = 1;
  for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
    result += array[i2] * mul7;
    mul7 *= 256;
  }
  return result;
}
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
    out[i2] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
    out[i2] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
binary.writeFloat64LE = writeFloat64LE;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.randomStringForEntropy = exports2.randomString = exports2.randomUint32 = exports2.randomBytes = exports2.defaultRandomSource = void 0;
  const system_1 = system;
  const binary_1 = binary;
  const wipe_12 = wipe$1;
  exports2.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length, prng = exports2.defaultRandomSource) {
    return prng.randomBytes(length);
  }
  exports2.randomBytes = randomBytes;
  function randomUint32(prng = exports2.defaultRandomSource) {
    const buf = randomBytes(4, prng);
    const result = (0, binary_1.readUint32LE)(buf);
    (0, wipe_12.wipe)(buf);
    return result;
  }
  exports2.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length > 0) {
      const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
      for (let i2 = 0; i2 < buf.length && length > 0; i2++) {
        const randomByte = buf[i2];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length--;
        }
      }
      (0, wipe_12.wipe)(buf);
    }
    return out;
  }
  exports2.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
  }
  exports2.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha512$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var binary_1 = binary;
  var wipe_12 = wipe$1;
  exports2.DIGEST_LENGTH = 64;
  exports2.BLOCK_SIZE = 128;
  var SHA5122 = function() {
    function SHA5123() {
      this.digestLength = exports2.DIGEST_LENGTH;
      this.blockSize = exports2.BLOCK_SIZE;
      this._stateHi = new Int32Array(8);
      this._stateLo = new Int32Array(8);
      this._tempHi = new Int32Array(16);
      this._tempLo = new Int32Array(16);
      this._buffer = new Uint8Array(256);
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      this.reset();
    }
    SHA5123.prototype._initState = function() {
      this._stateHi[0] = 1779033703;
      this._stateHi[1] = 3144134277;
      this._stateHi[2] = 1013904242;
      this._stateHi[3] = 2773480762;
      this._stateHi[4] = 1359893119;
      this._stateHi[5] = 2600822924;
      this._stateHi[6] = 528734635;
      this._stateHi[7] = 1541459225;
      this._stateLo[0] = 4089235720;
      this._stateLo[1] = 2227873595;
      this._stateLo[2] = 4271175723;
      this._stateLo[3] = 1595750129;
      this._stateLo[4] = 2917565137;
      this._stateLo[5] = 725511199;
      this._stateLo[6] = 4215389547;
      this._stateLo[7] = 327033209;
    };
    SHA5123.prototype.reset = function() {
      this._initState();
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      return this;
    };
    SHA5123.prototype.clean = function() {
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._tempHi);
      wipe_12.wipe(this._tempLo);
      this.reset();
    };
    SHA5123.prototype.update = function(data2, dataLength) {
      if (dataLength === void 0) {
        dataLength = data2.length;
      }
      if (this._finished) {
        throw new Error("SHA512: can't update because hash was finished.");
      }
      var dataPos = 0;
      this._bytesHashed += dataLength;
      if (this._bufferLength > 0) {
        while (this._bufferLength < exports2.BLOCK_SIZE && dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        if (this._bufferLength === this.blockSize) {
          hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
          this._bufferLength = 0;
        }
      }
      if (dataLength >= this.blockSize) {
        dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data2, dataPos, dataLength);
        dataLength %= this.blockSize;
      }
      while (dataLength > 0) {
        this._buffer[this._bufferLength++] = data2[dataPos++];
        dataLength--;
      }
      return this;
    };
    SHA5123.prototype.finish = function(out) {
      if (!this._finished) {
        var bytesHashed = this._bytesHashed;
        var left = this._bufferLength;
        var bitLenHi = bytesHashed / 536870912 | 0;
        var bitLenLo = bytesHashed << 3;
        var padLength = bytesHashed % 128 < 112 ? 128 : 256;
        this._buffer[left] = 128;
        for (var i2 = left + 1; i2 < padLength - 8; i2++) {
          this._buffer[i2] = 0;
        }
        binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
        binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
        hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
        this._finished = true;
      }
      for (var i2 = 0; i2 < this.digestLength / 8; i2++) {
        binary_1.writeUint32BE(this._stateHi[i2], out, i2 * 8);
        binary_1.writeUint32BE(this._stateLo[i2], out, i2 * 8 + 4);
      }
      return this;
    };
    SHA5123.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    SHA5123.prototype.saveState = function() {
      if (this._finished) {
        throw new Error("SHA256: cannot save finished state");
      }
      return {
        stateHi: new Int32Array(this._stateHi),
        stateLo: new Int32Array(this._stateLo),
        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
        bufferLength: this._bufferLength,
        bytesHashed: this._bytesHashed
      };
    };
    SHA5123.prototype.restoreState = function(savedState) {
      this._stateHi.set(savedState.stateHi);
      this._stateLo.set(savedState.stateLo);
      this._bufferLength = savedState.bufferLength;
      if (savedState.buffer) {
        this._buffer.set(savedState.buffer);
      }
      this._bytesHashed = savedState.bytesHashed;
      this._finished = false;
      return this;
    };
    SHA5123.prototype.cleanSavedState = function(savedState) {
      wipe_12.wipe(savedState.stateHi);
      wipe_12.wipe(savedState.stateLo);
      if (savedState.buffer) {
        wipe_12.wipe(savedState.buffer);
      }
      savedState.bufferLength = 0;
      savedState.bytesHashed = 0;
    };
    return SHA5123;
  }();
  exports2.SHA512 = SHA5122;
  var K2 = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function hashBlocks(wh, wl, hh, hl2, m2, pos, len2) {
    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
    var h2, l2;
    var th, tl;
    var a2, b2, c2, d2;
    while (len2 >= 128) {
      for (var i2 = 0; i2 < 16; i2++) {
        var j2 = 8 * i2 + pos;
        wh[i2] = binary_1.readUint32BE(m2, j2);
        wl[i2] = binary_1.readUint32BE(m2, j2 + 4);
      }
      for (var i2 = 0; i2 < 80; i2++) {
        var bh0 = ah0;
        var bh1 = ah1;
        var bh2 = ah2;
        var bh3 = ah3;
        var bh4 = ah4;
        var bh5 = ah5;
        var bh6 = ah6;
        var bh7 = ah7;
        var bl0 = al0;
        var bl1 = al1;
        var bl2 = al2;
        var bl3 = al3;
        var bl4 = al4;
        var bl5 = al5;
        var bl6 = al6;
        var bl7 = al7;
        h2 = ah7;
        l2 = al7;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
        l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        h2 = ah4 & ah5 ^ ~ah4 & ah6;
        l2 = al4 & al5 ^ ~al4 & al6;
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        h2 = K2[i2 * 2];
        l2 = K2[i2 * 2 + 1];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        h2 = wh[i2 % 16];
        l2 = wl[i2 % 16];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        th = c2 & 65535 | d2 << 16;
        tl = a2 & 65535 | b2 << 16;
        h2 = th;
        l2 = tl;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
        l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
        l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        bh7 = c2 & 65535 | d2 << 16;
        bl7 = a2 & 65535 | b2 << 16;
        h2 = bh3;
        l2 = bl3;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = th;
        l2 = tl;
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        bh3 = c2 & 65535 | d2 << 16;
        bl3 = a2 & 65535 | b2 << 16;
        ah1 = bh0;
        ah2 = bh1;
        ah3 = bh2;
        ah4 = bh3;
        ah5 = bh4;
        ah6 = bh5;
        ah7 = bh6;
        ah0 = bh7;
        al1 = bl0;
        al2 = bl1;
        al3 = bl2;
        al4 = bl3;
        al5 = bl4;
        al6 = bl5;
        al7 = bl6;
        al0 = bl7;
        if (i2 % 16 === 15) {
          for (var j2 = 0; j2 < 16; j2++) {
            h2 = wh[j2];
            l2 = wl[j2];
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = wh[(j2 + 9) % 16];
            l2 = wl[(j2 + 9) % 16];
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            th = wh[(j2 + 1) % 16];
            tl = wl[(j2 + 1) % 16];
            h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
            l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            th = wh[(j2 + 14) % 16];
            tl = wl[(j2 + 14) % 16];
            h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
            l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            wh[j2] = c2 & 65535 | d2 << 16;
            wl[j2] = a2 & 65535 | b2 << 16;
          }
        }
      }
      h2 = ah0;
      l2 = al0;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[0];
      l2 = hl2[0];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[0] = ah0 = c2 & 65535 | d2 << 16;
      hl2[0] = al0 = a2 & 65535 | b2 << 16;
      h2 = ah1;
      l2 = al1;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[1];
      l2 = hl2[1];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[1] = ah1 = c2 & 65535 | d2 << 16;
      hl2[1] = al1 = a2 & 65535 | b2 << 16;
      h2 = ah2;
      l2 = al2;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[2];
      l2 = hl2[2];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[2] = ah2 = c2 & 65535 | d2 << 16;
      hl2[2] = al2 = a2 & 65535 | b2 << 16;
      h2 = ah3;
      l2 = al3;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[3];
      l2 = hl2[3];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[3] = ah3 = c2 & 65535 | d2 << 16;
      hl2[3] = al3 = a2 & 65535 | b2 << 16;
      h2 = ah4;
      l2 = al4;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[4];
      l2 = hl2[4];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[4] = ah4 = c2 & 65535 | d2 << 16;
      hl2[4] = al4 = a2 & 65535 | b2 << 16;
      h2 = ah5;
      l2 = al5;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[5];
      l2 = hl2[5];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[5] = ah5 = c2 & 65535 | d2 << 16;
      hl2[5] = al5 = a2 & 65535 | b2 << 16;
      h2 = ah6;
      l2 = al6;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[6];
      l2 = hl2[6];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[6] = ah6 = c2 & 65535 | d2 << 16;
      hl2[6] = al6 = a2 & 65535 | b2 << 16;
      h2 = ah7;
      l2 = al7;
      a2 = l2 & 65535;
      b2 = l2 >>> 16;
      c2 = h2 & 65535;
      d2 = h2 >>> 16;
      h2 = hh[7];
      l2 = hl2[7];
      a2 += l2 & 65535;
      b2 += l2 >>> 16;
      c2 += h2 & 65535;
      d2 += h2 >>> 16;
      b2 += a2 >>> 16;
      c2 += b2 >>> 16;
      d2 += c2 >>> 16;
      hh[7] = ah7 = c2 & 65535 | d2 << 16;
      hl2[7] = al7 = a2 & 65535 | b2 << 16;
      pos += 128;
      len2 -= 128;
    }
    return pos;
  }
  function hash3(data2) {
    var h2 = new SHA5122();
    h2.update(data2);
    var digest9 = h2.digest();
    h2.clean();
    return digest9;
  }
  exports2.hash = hash3;
})(sha512$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.convertSecretKeyToX25519 = exports2.convertPublicKeyToX25519 = exports2.verify = exports2.sign = exports2.extractPublicKeyFromSecretKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.SEED_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = exports2.SIGNATURE_LENGTH = void 0;
  const random_1 = random;
  const sha512_1 = sha512$1;
  const wipe_12 = wipe$1;
  exports2.SIGNATURE_LENGTH = 64;
  exports2.PUBLIC_KEY_LENGTH = 32;
  exports2.SECRET_KEY_LENGTH = 64;
  exports2.SEED_LENGTH = 32;
  function gf(init5) {
    const r2 = new Float64Array(16);
    if (init5) {
      for (let i2 = 0; i2 < init5.length; i2++) {
        r2[i2] = init5[i2];
      }
    }
    return r2;
  }
  const _9 = new Uint8Array(32);
  _9[0] = 9;
  const gf0 = gf();
  const gf1 = gf([1]);
  const D = gf([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]);
  const D2 = gf([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]);
  const X = gf([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]);
  const Y = gf([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]);
  const I2 = gf([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function set25519(r2, a2) {
    for (let i2 = 0; i2 < 16; i2++) {
      r2[i2] = a2[i2] | 0;
    }
  }
  function car25519(o) {
    let c2 = 1;
    for (let i2 = 0; i2 < 16; i2++) {
      let v2 = o[i2] + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      o[i2] = v2 - c2 * 65536;
    }
    o[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p2, q, b2) {
    const c2 = ~(b2 - 1);
    for (let i2 = 0; i2 < 16; i2++) {
      const t = c2 & (p2[i2] ^ q[i2]);
      p2[i2] ^= t;
      q[i2] ^= t;
    }
  }
  function pack25519(o, n) {
    const m2 = gf();
    const t = gf();
    for (let i2 = 0; i2 < 16; i2++) {
      t[i2] = n[i2];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t[0] - 65517;
      for (let i2 = 1; i2 < 15; i2++) {
        m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
        m2[i2 - 1] &= 65535;
      }
      m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
      const b2 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t, m2, 1 - b2);
    }
    for (let i2 = 0; i2 < 16; i2++) {
      o[2 * i2] = t[i2] & 255;
      o[2 * i2 + 1] = t[i2] >> 8;
    }
  }
  function verify32(x2, y2) {
    let d2 = 0;
    for (let i2 = 0; i2 < 32; i2++) {
      d2 |= x2[i2] ^ y2[i2];
    }
    return (1 & d2 - 1 >>> 8) - 1;
  }
  function neq25519(a2, b2) {
    const c2 = new Uint8Array(32);
    const d2 = new Uint8Array(32);
    pack25519(c2, a2);
    pack25519(d2, b2);
    return verify32(c2, d2);
  }
  function par25519(a2) {
    const d2 = new Uint8Array(32);
    pack25519(d2, a2);
    return d2[0] & 1;
  }
  function unpack25519(o, n) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
    }
    o[15] &= 32767;
  }
  function add7(o, a2, b2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = a2[i2] + b2[i2];
    }
  }
  function sub(o, a2, b2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = a2[i2] - b2[i2];
    }
  }
  function mul7(o, a2, b2) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v2 = a2[0];
    t0 += v2 * b0;
    t1 += v2 * b1;
    t2 += v2 * b22;
    t3 += v2 * b3;
    t4 += v2 * b4;
    t5 += v2 * b5;
    t6 += v2 * b6;
    t7 += v2 * b7;
    t8 += v2 * b8;
    t9 += v2 * b9;
    t10 += v2 * b10;
    t11 += v2 * b11;
    t12 += v2 * b12;
    t13 += v2 * b13;
    t14 += v2 * b14;
    t15 += v2 * b15;
    v2 = a2[1];
    t1 += v2 * b0;
    t2 += v2 * b1;
    t3 += v2 * b22;
    t4 += v2 * b3;
    t5 += v2 * b4;
    t6 += v2 * b5;
    t7 += v2 * b6;
    t8 += v2 * b7;
    t9 += v2 * b8;
    t10 += v2 * b9;
    t11 += v2 * b10;
    t12 += v2 * b11;
    t13 += v2 * b12;
    t14 += v2 * b13;
    t15 += v2 * b14;
    t16 += v2 * b15;
    v2 = a2[2];
    t2 += v2 * b0;
    t3 += v2 * b1;
    t4 += v2 * b22;
    t5 += v2 * b3;
    t6 += v2 * b4;
    t7 += v2 * b5;
    t8 += v2 * b6;
    t9 += v2 * b7;
    t10 += v2 * b8;
    t11 += v2 * b9;
    t12 += v2 * b10;
    t13 += v2 * b11;
    t14 += v2 * b12;
    t15 += v2 * b13;
    t16 += v2 * b14;
    t17 += v2 * b15;
    v2 = a2[3];
    t3 += v2 * b0;
    t4 += v2 * b1;
    t5 += v2 * b22;
    t6 += v2 * b3;
    t7 += v2 * b4;
    t8 += v2 * b5;
    t9 += v2 * b6;
    t10 += v2 * b7;
    t11 += v2 * b8;
    t12 += v2 * b9;
    t13 += v2 * b10;
    t14 += v2 * b11;
    t15 += v2 * b12;
    t16 += v2 * b13;
    t17 += v2 * b14;
    t18 += v2 * b15;
    v2 = a2[4];
    t4 += v2 * b0;
    t5 += v2 * b1;
    t6 += v2 * b22;
    t7 += v2 * b3;
    t8 += v2 * b4;
    t9 += v2 * b5;
    t10 += v2 * b6;
    t11 += v2 * b7;
    t12 += v2 * b8;
    t13 += v2 * b9;
    t14 += v2 * b10;
    t15 += v2 * b11;
    t16 += v2 * b12;
    t17 += v2 * b13;
    t18 += v2 * b14;
    t19 += v2 * b15;
    v2 = a2[5];
    t5 += v2 * b0;
    t6 += v2 * b1;
    t7 += v2 * b22;
    t8 += v2 * b3;
    t9 += v2 * b4;
    t10 += v2 * b5;
    t11 += v2 * b6;
    t12 += v2 * b7;
    t13 += v2 * b8;
    t14 += v2 * b9;
    t15 += v2 * b10;
    t16 += v2 * b11;
    t17 += v2 * b12;
    t18 += v2 * b13;
    t19 += v2 * b14;
    t20 += v2 * b15;
    v2 = a2[6];
    t6 += v2 * b0;
    t7 += v2 * b1;
    t8 += v2 * b22;
    t9 += v2 * b3;
    t10 += v2 * b4;
    t11 += v2 * b5;
    t12 += v2 * b6;
    t13 += v2 * b7;
    t14 += v2 * b8;
    t15 += v2 * b9;
    t16 += v2 * b10;
    t17 += v2 * b11;
    t18 += v2 * b12;
    t19 += v2 * b13;
    t20 += v2 * b14;
    t21 += v2 * b15;
    v2 = a2[7];
    t7 += v2 * b0;
    t8 += v2 * b1;
    t9 += v2 * b22;
    t10 += v2 * b3;
    t11 += v2 * b4;
    t12 += v2 * b5;
    t13 += v2 * b6;
    t14 += v2 * b7;
    t15 += v2 * b8;
    t16 += v2 * b9;
    t17 += v2 * b10;
    t18 += v2 * b11;
    t19 += v2 * b12;
    t20 += v2 * b13;
    t21 += v2 * b14;
    t22 += v2 * b15;
    v2 = a2[8];
    t8 += v2 * b0;
    t9 += v2 * b1;
    t10 += v2 * b22;
    t11 += v2 * b3;
    t12 += v2 * b4;
    t13 += v2 * b5;
    t14 += v2 * b6;
    t15 += v2 * b7;
    t16 += v2 * b8;
    t17 += v2 * b9;
    t18 += v2 * b10;
    t19 += v2 * b11;
    t20 += v2 * b12;
    t21 += v2 * b13;
    t22 += v2 * b14;
    t23 += v2 * b15;
    v2 = a2[9];
    t9 += v2 * b0;
    t10 += v2 * b1;
    t11 += v2 * b22;
    t12 += v2 * b3;
    t13 += v2 * b4;
    t14 += v2 * b5;
    t15 += v2 * b6;
    t16 += v2 * b7;
    t17 += v2 * b8;
    t18 += v2 * b9;
    t19 += v2 * b10;
    t20 += v2 * b11;
    t21 += v2 * b12;
    t22 += v2 * b13;
    t23 += v2 * b14;
    t24 += v2 * b15;
    v2 = a2[10];
    t10 += v2 * b0;
    t11 += v2 * b1;
    t12 += v2 * b22;
    t13 += v2 * b3;
    t14 += v2 * b4;
    t15 += v2 * b5;
    t16 += v2 * b6;
    t17 += v2 * b7;
    t18 += v2 * b8;
    t19 += v2 * b9;
    t20 += v2 * b10;
    t21 += v2 * b11;
    t22 += v2 * b12;
    t23 += v2 * b13;
    t24 += v2 * b14;
    t25 += v2 * b15;
    v2 = a2[11];
    t11 += v2 * b0;
    t12 += v2 * b1;
    t13 += v2 * b22;
    t14 += v2 * b3;
    t15 += v2 * b4;
    t16 += v2 * b5;
    t17 += v2 * b6;
    t18 += v2 * b7;
    t19 += v2 * b8;
    t20 += v2 * b9;
    t21 += v2 * b10;
    t22 += v2 * b11;
    t23 += v2 * b12;
    t24 += v2 * b13;
    t25 += v2 * b14;
    t26 += v2 * b15;
    v2 = a2[12];
    t12 += v2 * b0;
    t13 += v2 * b1;
    t14 += v2 * b22;
    t15 += v2 * b3;
    t16 += v2 * b4;
    t17 += v2 * b5;
    t18 += v2 * b6;
    t19 += v2 * b7;
    t20 += v2 * b8;
    t21 += v2 * b9;
    t22 += v2 * b10;
    t23 += v2 * b11;
    t24 += v2 * b12;
    t25 += v2 * b13;
    t26 += v2 * b14;
    t27 += v2 * b15;
    v2 = a2[13];
    t13 += v2 * b0;
    t14 += v2 * b1;
    t15 += v2 * b22;
    t16 += v2 * b3;
    t17 += v2 * b4;
    t18 += v2 * b5;
    t19 += v2 * b6;
    t20 += v2 * b7;
    t21 += v2 * b8;
    t22 += v2 * b9;
    t23 += v2 * b10;
    t24 += v2 * b11;
    t25 += v2 * b12;
    t26 += v2 * b13;
    t27 += v2 * b14;
    t28 += v2 * b15;
    v2 = a2[14];
    t14 += v2 * b0;
    t15 += v2 * b1;
    t16 += v2 * b22;
    t17 += v2 * b3;
    t18 += v2 * b4;
    t19 += v2 * b5;
    t20 += v2 * b6;
    t21 += v2 * b7;
    t22 += v2 * b8;
    t23 += v2 * b9;
    t24 += v2 * b10;
    t25 += v2 * b11;
    t26 += v2 * b12;
    t27 += v2 * b13;
    t28 += v2 * b14;
    t29 += v2 * b15;
    v2 = a2[15];
    t15 += v2 * b0;
    t16 += v2 * b1;
    t17 += v2 * b22;
    t18 += v2 * b3;
    t19 += v2 * b4;
    t20 += v2 * b5;
    t21 += v2 * b6;
    t22 += v2 * b7;
    t23 += v2 * b8;
    t24 += v2 * b9;
    t25 += v2 * b10;
    t26 += v2 * b11;
    t27 += v2 * b12;
    t28 += v2 * b13;
    t29 += v2 * b14;
    t30 += v2 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
  function square(o, a2) {
    mul7(o, a2, a2);
  }
  function inv25519(o, i2) {
    const c2 = gf();
    let a2;
    for (a2 = 0; a2 < 16; a2++) {
      c2[a2] = i2[a2];
    }
    for (a2 = 253; a2 >= 0; a2--) {
      square(c2, c2);
      if (a2 !== 2 && a2 !== 4) {
        mul7(c2, c2, i2);
      }
    }
    for (a2 = 0; a2 < 16; a2++) {
      o[a2] = c2[a2];
    }
  }
  function pow2523(o, i2) {
    const c2 = gf();
    let a2;
    for (a2 = 0; a2 < 16; a2++) {
      c2[a2] = i2[a2];
    }
    for (a2 = 250; a2 >= 0; a2--) {
      square(c2, c2);
      if (a2 !== 1) {
        mul7(c2, c2, i2);
      }
    }
    for (a2 = 0; a2 < 16; a2++) {
      o[a2] = c2[a2];
    }
  }
  function edadd(p2, q) {
    const a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t = gf();
    sub(a2, p2[1], p2[0]);
    sub(t, q[1], q[0]);
    mul7(a2, a2, t);
    add7(b2, p2[0], p2[1]);
    add7(t, q[0], q[1]);
    mul7(b2, b2, t);
    mul7(c2, p2[3], q[3]);
    mul7(c2, c2, D2);
    mul7(d2, p2[2], q[2]);
    add7(d2, d2, d2);
    sub(e, b2, a2);
    sub(f2, d2, c2);
    add7(g2, d2, c2);
    add7(h2, b2, a2);
    mul7(p2[0], e, f2);
    mul7(p2[1], h2, g2);
    mul7(p2[2], g2, f2);
    mul7(p2[3], e, h2);
  }
  function cswap(p2, q, b2) {
    for (let i2 = 0; i2 < 4; i2++) {
      sel25519(p2[i2], q[i2], b2);
    }
  }
  function pack2(r2, p2) {
    const tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p2[2]);
    mul7(tx, p2[0], zi);
    mul7(ty, p2[1], zi);
    pack25519(r2, ty);
    r2[31] ^= par25519(tx) << 7;
  }
  function scalarmult(p2, q, s2) {
    set25519(p2[0], gf0);
    set25519(p2[1], gf1);
    set25519(p2[2], gf1);
    set25519(p2[3], gf0);
    for (let i2 = 255; i2 >= 0; --i2) {
      const b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
      cswap(p2, q, b2);
      edadd(q, p2);
      edadd(p2, p2);
      cswap(p2, q, b2);
    }
  }
  function scalarbase(p2, s2) {
    const q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    mul7(q[3], X, Y);
    scalarmult(p2, q, s2);
  }
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports2.SEED_LENGTH) {
      throw new Error(`ed25519: seed must be ${exports2.SEED_LENGTH} bytes`);
    }
    const d2 = (0, sha512_1.hash)(seed);
    d2[0] &= 248;
    d2[31] &= 127;
    d2[31] |= 64;
    const publicKey = new Uint8Array(32);
    const p2 = [gf(), gf(), gf(), gf()];
    scalarbase(p2, d2);
    pack2(publicKey, p2);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey, 32);
    return {
      publicKey,
      secretKey
    };
  }
  exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_12.wipe)(seed);
    return result;
  }
  exports2.generateKeyPair = generateKeyPair;
  function extractPublicKeyFromSecretKey(secretKey) {
    if (secretKey.length !== exports2.SECRET_KEY_LENGTH) {
      throw new Error(`ed25519: secret key must be ${exports2.SECRET_KEY_LENGTH} bytes`);
    }
    return new Uint8Array(secretKey.subarray(32));
  }
  exports2.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
  const L2 = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function modL(r2, x2) {
    let carry;
    let i2;
    let j2;
    let k;
    for (i2 = 63; i2 >= 32; --i2) {
      carry = 0;
      for (j2 = i2 - 32, k = i2 - 12; j2 < k; ++j2) {
        x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
        carry = Math.floor((x2[j2] + 128) / 256);
        x2[j2] -= carry * 256;
      }
      x2[j2] += carry;
      x2[i2] = 0;
    }
    carry = 0;
    for (j2 = 0; j2 < 32; j2++) {
      x2[j2] += carry - (x2[31] >> 4) * L2[j2];
      carry = x2[j2] >> 8;
      x2[j2] &= 255;
    }
    for (j2 = 0; j2 < 32; j2++) {
      x2[j2] -= carry * L2[j2];
    }
    for (i2 = 0; i2 < 32; i2++) {
      x2[i2 + 1] += x2[i2] >> 8;
      r2[i2] = x2[i2] & 255;
    }
  }
  function reduce(r2) {
    const x2 = new Float64Array(64);
    for (let i2 = 0; i2 < 64; i2++) {
      x2[i2] = r2[i2];
    }
    for (let i2 = 0; i2 < 64; i2++) {
      r2[i2] = 0;
    }
    modL(r2, x2);
  }
  function sign7(secretKey, message) {
    const x2 = new Float64Array(64);
    const p2 = [gf(), gf(), gf(), gf()];
    const d2 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    d2[0] &= 248;
    d2[31] &= 127;
    d2[31] |= 64;
    const signature2 = new Uint8Array(64);
    signature2.set(d2.subarray(32), 32);
    const hs = new sha512_1.SHA512();
    hs.update(signature2.subarray(32));
    hs.update(message);
    const r2 = hs.digest();
    hs.clean();
    reduce(r2);
    scalarbase(p2, r2);
    pack2(signature2, p2);
    hs.reset();
    hs.update(signature2.subarray(0, 32));
    hs.update(secretKey.subarray(32));
    hs.update(message);
    const h2 = hs.digest();
    reduce(h2);
    for (let i2 = 0; i2 < 32; i2++) {
      x2[i2] = r2[i2];
    }
    for (let i2 = 0; i2 < 32; i2++) {
      for (let j2 = 0; j2 < 32; j2++) {
        x2[i2 + j2] += h2[i2] * d2[j2];
      }
    }
    modL(signature2.subarray(32), x2);
    return signature2;
  }
  exports2.sign = sign7;
  function unpackneg(r2, p2) {
    const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r2[2], gf1);
    unpack25519(r2[1], p2);
    square(num, r2[1]);
    mul7(den, num, D);
    sub(num, num, r2[2]);
    add7(den, r2[2], den);
    square(den2, den);
    square(den4, den2);
    mul7(den6, den4, den2);
    mul7(t, den6, num);
    mul7(t, t, den);
    pow2523(t, t);
    mul7(t, t, num);
    mul7(t, t, den);
    mul7(t, t, den);
    mul7(r2[0], t, den);
    square(chk, r2[0]);
    mul7(chk, chk, den);
    if (neq25519(chk, num)) {
      mul7(r2[0], r2[0], I2);
    }
    square(chk, r2[0]);
    mul7(chk, chk, den);
    if (neq25519(chk, num)) {
      return -1;
    }
    if (par25519(r2[0]) === p2[31] >> 7) {
      sub(r2[0], gf0, r2[0]);
    }
    mul7(r2[3], r2[0], r2[1]);
    return 0;
  }
  function verify7(publicKey, message, signature2) {
    const t = new Uint8Array(32);
    const p2 = [gf(), gf(), gf(), gf()];
    const q = [gf(), gf(), gf(), gf()];
    if (signature2.length !== exports2.SIGNATURE_LENGTH) {
      throw new Error(`ed25519: signature must be ${exports2.SIGNATURE_LENGTH} bytes`);
    }
    if (unpackneg(q, publicKey)) {
      return false;
    }
    const hs = new sha512_1.SHA512();
    hs.update(signature2.subarray(0, 32));
    hs.update(publicKey);
    hs.update(message);
    const h2 = hs.digest();
    reduce(h2);
    scalarmult(p2, q, h2);
    scalarbase(q, signature2.subarray(32));
    edadd(p2, q);
    pack2(t, p2);
    if (verify32(signature2, t)) {
      return false;
    }
    return true;
  }
  exports2.verify = verify7;
  function convertPublicKeyToX25519(publicKey) {
    let q = [gf(), gf(), gf(), gf()];
    if (unpackneg(q, publicKey)) {
      throw new Error("Ed25519: invalid public key");
    }
    let a2 = gf();
    let b2 = gf();
    let y2 = q[1];
    add7(a2, gf1, y2);
    sub(b2, gf1, y2);
    inv25519(b2, b2);
    mul7(a2, a2, b2);
    let z2 = new Uint8Array(32);
    pack25519(z2, a2);
    return z2;
  }
  exports2.convertPublicKeyToX25519 = convertPublicKeyToX25519;
  function convertSecretKeyToX25519(secretKey) {
    const d2 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    d2[0] &= 248;
    d2[31] &= 127;
    d2[31] |= 64;
    const o = new Uint8Array(d2.subarray(0, 32));
    (0, wipe_12.wipe)(d2);
    return o;
  }
  exports2.convertSecretKeyToX25519 = convertSecretKeyToX25519;
})(ed25519);
var blake2b$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var binary_1 = binary;
  var wipe_12 = wipe$1;
  exports2.BLOCK_SIZE = 128;
  exports2.DIGEST_LENGTH = 64;
  exports2.KEY_LENGTH = 64;
  exports2.PERSONALIZATION_LENGTH = 16;
  exports2.SALT_LENGTH = 16;
  exports2.MAX_LEAF_SIZE = Math.pow(2, 32) - 1;
  exports2.MAX_FANOUT = 255;
  exports2.MAX_MAX_DEPTH = 255;
  var IV = new Uint32Array([
    // low bits // high bits
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  var SIGMA2 = [
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
    [28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6],
    [22, 16, 24, 0, 10, 4, 30, 26, 20, 28, 6, 12, 14, 2, 18, 8],
    [14, 18, 6, 2, 26, 24, 22, 28, 4, 12, 10, 20, 8, 0, 30, 16],
    [18, 0, 10, 14, 4, 8, 20, 30, 28, 2, 22, 24, 12, 16, 6, 26],
    [4, 24, 12, 20, 0, 22, 16, 6, 8, 26, 14, 10, 30, 28, 2, 18],
    [24, 10, 2, 30, 28, 26, 8, 20, 0, 14, 12, 6, 18, 4, 16, 22],
    [26, 22, 14, 28, 24, 2, 6, 18, 10, 0, 30, 8, 16, 12, 4, 20],
    [12, 30, 28, 18, 22, 6, 0, 16, 24, 4, 26, 14, 2, 8, 20, 10],
    [20, 4, 16, 8, 14, 12, 2, 10, 30, 22, 18, 28, 6, 24, 26, 0],
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
    [28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6]
  ];
  var BLAKE2b = function() {
    function BLAKE2b2(digestLength, config2) {
      if (digestLength === void 0) {
        digestLength = 64;
      }
      this.digestLength = digestLength;
      this.blockSize = exports2.BLOCK_SIZE;
      this._state = new Int32Array(IV);
      this._buffer = new Uint8Array(exports2.BLOCK_SIZE);
      this._bufferLength = 0;
      this._ctr = new Uint32Array(4);
      this._flag = new Uint32Array(4);
      this._lastNode = false;
      this._finished = false;
      this._vtmp = new Uint32Array(32);
      this._mtmp = new Uint32Array(32);
      if (digestLength < 1 || digestLength > exports2.DIGEST_LENGTH) {
        throw new Error("blake2b: wrong digest length");
      }
      if (config2) {
        this.validateConfig(config2);
      }
      var keyLength = 0;
      if (config2 && config2.key) {
        keyLength = config2.key.length;
      }
      var fanout = 1;
      var maxDepth = 1;
      if (config2 && config2.tree) {
        fanout = config2.tree.fanout;
        maxDepth = config2.tree.maxDepth;
      }
      this._state[0] ^= digestLength | keyLength << 8 | fanout << 16 | maxDepth << 24;
      if (config2 && config2.tree) {
        this._state[1] ^= config2.tree.leafSize;
        this._state[2] ^= config2.tree.nodeOffsetLowBits;
        this._state[3] ^= config2.tree.nodeOffsetHighBits;
        this._state[4] ^= config2.tree.nodeDepth | config2.tree.innerDigestLength << 8;
        this._lastNode = config2.tree.lastNode;
      }
      if (config2 && config2.salt) {
        this._state[8] ^= binary_1.readUint32LE(config2.salt, 0);
        this._state[9] ^= binary_1.readUint32LE(config2.salt, 4);
        this._state[10] ^= binary_1.readUint32LE(config2.salt, 8);
        this._state[11] ^= binary_1.readUint32LE(config2.salt, 12);
      }
      if (config2 && config2.personalization) {
        this._state[12] ^= binary_1.readUint32LE(config2.personalization, 0);
        this._state[13] ^= binary_1.readUint32LE(config2.personalization, 4);
        this._state[14] ^= binary_1.readUint32LE(config2.personalization, 8);
        this._state[15] ^= binary_1.readUint32LE(config2.personalization, 12);
      }
      this._initialState = new Uint32Array(this._state);
      if (config2 && config2.key && keyLength > 0) {
        this._paddedKey = new Uint8Array(exports2.BLOCK_SIZE);
        this._paddedKey.set(config2.key);
        this._buffer.set(this._paddedKey);
        this._bufferLength = exports2.BLOCK_SIZE;
      }
    }
    BLAKE2b2.prototype.reset = function() {
      this._state.set(this._initialState);
      if (this._paddedKey) {
        this._buffer.set(this._paddedKey);
        this._bufferLength = exports2.BLOCK_SIZE;
      } else {
        this._bufferLength = 0;
      }
      wipe_12.wipe(this._ctr);
      wipe_12.wipe(this._flag);
      this._finished = false;
      return this;
    };
    BLAKE2b2.prototype.validateConfig = function(config2) {
      if (config2.key && config2.key.length > exports2.KEY_LENGTH) {
        throw new Error("blake2b: wrong key length");
      }
      if (config2.salt && config2.salt.length !== exports2.SALT_LENGTH) {
        throw new Error("blake2b: wrong salt length");
      }
      if (config2.personalization && config2.personalization.length !== exports2.PERSONALIZATION_LENGTH) {
        throw new Error("blake2b: wrong personalization length");
      }
      if (config2.tree) {
        if (config2.tree.fanout < 0 || config2.tree.fanout > exports2.MAX_FANOUT) {
          throw new Error("blake2b: wrong tree fanout");
        }
        if (config2.tree.maxDepth < 0 || config2.tree.maxDepth > exports2.MAX_MAX_DEPTH) {
          throw new Error("blake2b: wrong tree depth");
        }
        if (config2.tree.leafSize < 0 || config2.tree.leafSize > exports2.MAX_LEAF_SIZE) {
          throw new Error("blake2b: wrong leaf size");
        }
        if (config2.tree.innerDigestLength < 0 || config2.tree.innerDigestLength > exports2.DIGEST_LENGTH) {
          throw new Error("blake2b: wrong tree inner digest length");
        }
      }
    };
    BLAKE2b2.prototype.update = function(data2, dataLength) {
      if (dataLength === void 0) {
        dataLength = data2.length;
      }
      if (this._finished) {
        throw new Error("blake2b: can't update because hash was finished.");
      }
      var left = exports2.BLOCK_SIZE - this._bufferLength;
      var dataPos = 0;
      if (dataLength === 0) {
        return this;
      }
      if (dataLength > left) {
        for (var i2 = 0; i2 < left; i2++) {
          this._buffer[this._bufferLength + i2] = data2[dataPos + i2];
        }
        this._processBlock(exports2.BLOCK_SIZE);
        dataPos += left;
        dataLength -= left;
        this._bufferLength = 0;
      }
      while (dataLength > exports2.BLOCK_SIZE) {
        for (var i2 = 0; i2 < exports2.BLOCK_SIZE; i2++) {
          this._buffer[i2] = data2[dataPos + i2];
        }
        this._processBlock(exports2.BLOCK_SIZE);
        dataPos += exports2.BLOCK_SIZE;
        dataLength -= exports2.BLOCK_SIZE;
        this._bufferLength = 0;
      }
      for (var i2 = 0; i2 < dataLength; i2++) {
        this._buffer[this._bufferLength + i2] = data2[dataPos + i2];
      }
      this._bufferLength += dataLength;
      return this;
    };
    BLAKE2b2.prototype.finish = function(out) {
      if (!this._finished) {
        for (var i2 = this._bufferLength; i2 < exports2.BLOCK_SIZE; i2++) {
          this._buffer[i2] = 0;
        }
        this._flag[0] = 4294967295;
        this._flag[1] = 4294967295;
        if (this._lastNode) {
          this._flag[2] = 4294967295;
          this._flag[3] = 4294967295;
        }
        this._processBlock(this._bufferLength);
        this._finished = true;
      }
      var tmp = this._buffer.subarray(0, 64);
      for (var i2 = 0; i2 < 16; i2++) {
        binary_1.writeUint32LE(this._state[i2], tmp, i2 * 4);
      }
      out.set(tmp.subarray(0, out.length));
      return this;
    };
    BLAKE2b2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    BLAKE2b2.prototype.clean = function() {
      wipe_12.wipe(this._vtmp);
      wipe_12.wipe(this._mtmp);
      wipe_12.wipe(this._state);
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._initialState);
      if (this._paddedKey) {
        wipe_12.wipe(this._paddedKey);
      }
      this._bufferLength = 0;
      wipe_12.wipe(this._ctr);
      wipe_12.wipe(this._flag);
      this._lastNode = false;
      this._finished = false;
    };
    BLAKE2b2.prototype.saveState = function() {
      if (this._finished) {
        throw new Error("blake2b: cannot save finished state");
      }
      return {
        state: new Uint32Array(this._state),
        buffer: new Uint8Array(this._buffer),
        bufferLength: this._bufferLength,
        ctr: new Uint32Array(this._ctr),
        flag: new Uint32Array(this._flag),
        lastNode: this._lastNode,
        paddedKey: this._paddedKey ? new Uint8Array(this._paddedKey) : void 0,
        initialState: new Uint32Array(this._initialState)
      };
    };
    BLAKE2b2.prototype.restoreState = function(savedState) {
      this._state.set(savedState.state);
      this._buffer.set(savedState.buffer);
      this._bufferLength = savedState.bufferLength;
      this._ctr.set(savedState.ctr);
      this._flag.set(savedState.flag);
      this._lastNode = savedState.lastNode;
      if (this._paddedKey) {
        wipe_12.wipe(this._paddedKey);
      }
      this._paddedKey = savedState.paddedKey ? new Uint8Array(savedState.paddedKey) : void 0;
      this._initialState.set(savedState.initialState);
      return this;
    };
    BLAKE2b2.prototype.cleanSavedState = function(savedState) {
      wipe_12.wipe(savedState.state);
      wipe_12.wipe(savedState.buffer);
      wipe_12.wipe(savedState.initialState);
      if (savedState.paddedKey) {
        wipe_12.wipe(savedState.paddedKey);
      }
      savedState.bufferLength = 0;
      wipe_12.wipe(savedState.ctr);
      wipe_12.wipe(savedState.flag);
      savedState.lastNode = false;
    };
    BLAKE2b2.prototype._G = function(v2, al, bl, cl, dl, ah, bh, ch2, dh, ml0, mh0, ml1, mh1) {
      var vla = v2[al], vha = v2[ah], vlb = v2[bl], vhb = v2[bh], vlc = v2[cl], vhc = v2[ch2], vld = v2[dl], vhd = v2[dh];
      var w2 = vla & 65535, x2 = vla >>> 16, y2 = vha & 65535, z2 = vha >>> 16;
      w2 += vlb & 65535;
      x2 += vlb >>> 16;
      y2 += vhb & 65535;
      z2 += vhb >>> 16;
      x2 += w2 >>> 16;
      y2 += x2 >>> 16;
      z2 += y2 >>> 16;
      vha = y2 & 65535 | z2 << 16;
      vla = w2 & 65535 | x2 << 16;
      w2 = vla & 65535;
      x2 = vla >>> 16;
      y2 = vha & 65535;
      z2 = vha >>> 16;
      w2 += ml0 & 65535;
      x2 += ml0 >>> 16;
      y2 += mh0 & 65535;
      z2 += mh0 >>> 16;
      x2 += w2 >>> 16;
      y2 += x2 >>> 16;
      z2 += y2 >>> 16;
      vha = y2 & 65535 | z2 << 16;
      vla = w2 & 65535 | x2 << 16;
      vld ^= vla;
      vhd ^= vha;
      w2 = vhd;
      vhd = vld;
      vld = w2;
      w2 = vlc & 65535;
      x2 = vlc >>> 16;
      y2 = vhc & 65535;
      z2 = vhc >>> 16;
      w2 += vld & 65535;
      x2 += vld >>> 16;
      y2 += vhd & 65535;
      z2 += vhd >>> 16;
      x2 += w2 >>> 16;
      y2 += x2 >>> 16;
      z2 += y2 >>> 16;
      vhc = y2 & 65535 | z2 << 16;
      vlc = w2 & 65535 | x2 << 16;
      vlb ^= vlc;
      vhb ^= vhc;
      w2 = vlb << 8 | vhb >>> 24;
      vlb = vhb << 8 | vlb >>> 24;
      vhb = w2;
      w2 = vla & 65535;
      x2 = vla >>> 16;
      y2 = vha & 65535;
      z2 = vha >>> 16;
      w2 += vlb & 65535;
      x2 += vlb >>> 16;
      y2 += vhb & 65535;
      z2 += vhb >>> 16;
      x2 += w2 >>> 16;
      y2 += x2 >>> 16;
      z2 += y2 >>> 16;
      vha = y2 & 65535 | z2 << 16;
      vla = w2 & 65535 | x2 << 16;
      w2 = vla & 65535;
      x2 = vla >>> 16;
      y2 = vha & 65535;
      z2 = vha >>> 16;
      w2 += ml1 & 65535;
      x2 += ml1 >>> 16;
      y2 += mh1 & 65535;
      z2 += mh1 >>> 16;
      x2 += w2 >>> 16;
      y2 += x2 >>> 16;
      z2 += y2 >>> 16;
      vha = y2 & 65535 | z2 << 16;
      vla = w2 & 65535 | x2 << 16;
      vld ^= vla;
      vhd ^= vha;
      w2 = vld << 16 | vhd >>> 16;
      vld = vhd << 16 | vld >>> 16;
      vhd = w2;
      w2 = vlc & 65535;
      x2 = vlc >>> 16;
      y2 = vhc & 65535;
      z2 = vhc >>> 16;
      w2 += vld & 65535;
      x2 += vld >>> 16;
      y2 += vhd & 65535;
      z2 += vhd >>> 16;
      x2 += w2 >>> 16;
      y2 += x2 >>> 16;
      z2 += y2 >>> 16;
      vhc = y2 & 65535 | z2 << 16;
      vlc = w2 & 65535 | x2 << 16;
      vlb ^= vlc;
      vhb ^= vhc;
      w2 = vhb << 1 | vlb >>> 31;
      vlb = vlb << 1 | vhb >>> 31;
      vhb = w2;
      v2[al] = vla;
      v2[ah] = vha;
      v2[bl] = vlb;
      v2[bh] = vhb;
      v2[cl] = vlc;
      v2[ch2] = vhc;
      v2[dl] = vld;
      v2[dh] = vhd;
    };
    BLAKE2b2.prototype._incrementCounter = function(n) {
      for (var i2 = 0; i2 < 3; i2++) {
        var a2 = this._ctr[i2] + n;
        this._ctr[i2] = a2 >>> 0;
        if (this._ctr[i2] === a2) {
          return;
        }
        n = 1;
      }
    };
    BLAKE2b2.prototype._processBlock = function(length) {
      this._incrementCounter(length);
      var v2 = this._vtmp;
      v2.set(this._state);
      v2.set(IV, 16);
      v2[12 * 2 + 0] ^= this._ctr[0];
      v2[12 * 2 + 1] ^= this._ctr[1];
      v2[13 * 2 + 0] ^= this._ctr[2];
      v2[13 * 2 + 1] ^= this._ctr[3];
      v2[14 * 2 + 0] ^= this._flag[0];
      v2[14 * 2 + 1] ^= this._flag[1];
      v2[15 * 2 + 0] ^= this._flag[2];
      v2[15 * 2 + 1] ^= this._flag[3];
      var m2 = this._mtmp;
      for (var i2 = 0; i2 < 32; i2++) {
        m2[i2] = binary_1.readUint32LE(this._buffer, i2 * 4);
      }
      for (var r2 = 0; r2 < 12; r2++) {
        this._G(v2, 0, 8, 16, 24, 1, 9, 17, 25, m2[SIGMA2[r2][0]], m2[SIGMA2[r2][0] + 1], m2[SIGMA2[r2][1]], m2[SIGMA2[r2][1] + 1]);
        this._G(v2, 2, 10, 18, 26, 3, 11, 19, 27, m2[SIGMA2[r2][2]], m2[SIGMA2[r2][2] + 1], m2[SIGMA2[r2][3]], m2[SIGMA2[r2][3] + 1]);
        this._G(v2, 4, 12, 20, 28, 5, 13, 21, 29, m2[SIGMA2[r2][4]], m2[SIGMA2[r2][4] + 1], m2[SIGMA2[r2][5]], m2[SIGMA2[r2][5] + 1]);
        this._G(v2, 6, 14, 22, 30, 7, 15, 23, 31, m2[SIGMA2[r2][6]], m2[SIGMA2[r2][6] + 1], m2[SIGMA2[r2][7]], m2[SIGMA2[r2][7] + 1]);
        this._G(v2, 0, 10, 20, 30, 1, 11, 21, 31, m2[SIGMA2[r2][8]], m2[SIGMA2[r2][8] + 1], m2[SIGMA2[r2][9]], m2[SIGMA2[r2][9] + 1]);
        this._G(v2, 2, 12, 22, 24, 3, 13, 23, 25, m2[SIGMA2[r2][10]], m2[SIGMA2[r2][10] + 1], m2[SIGMA2[r2][11]], m2[SIGMA2[r2][11] + 1]);
        this._G(v2, 4, 14, 16, 26, 5, 15, 17, 27, m2[SIGMA2[r2][12]], m2[SIGMA2[r2][12] + 1], m2[SIGMA2[r2][13]], m2[SIGMA2[r2][13] + 1]);
        this._G(v2, 6, 8, 18, 28, 7, 9, 19, 29, m2[SIGMA2[r2][14]], m2[SIGMA2[r2][14] + 1], m2[SIGMA2[r2][15]], m2[SIGMA2[r2][15] + 1]);
      }
      for (var i2 = 0; i2 < 16; i2++) {
        this._state[i2] ^= v2[i2] ^ v2[i2 + 16];
      }
    };
    return BLAKE2b2;
  }();
  exports2.BLAKE2b = BLAKE2b;
  function hash3(data2, digestLength, config2) {
    if (digestLength === void 0) {
      digestLength = exports2.DIGEST_LENGTH;
    }
    var h2 = new BLAKE2b(digestLength, config2);
    h2.update(data2);
    var digest9 = h2.digest();
    h2.clean();
    return digest9;
  }
  exports2.hash = hash3;
})(blake2b$1);
const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
function normalizeInput(input) {
  let ret;
  if (input instanceof Uint8Array) {
    ret = input;
  } else if (typeof input === "string") {
    const encoder = new TextEncoder();
    ret = encoder.encode(input);
  } else {
    throw new Error(ERROR_MSG_INPUT);
  }
  return ret;
}
function toHex(bytes) {
  return Array.prototype.map.call(bytes, function(n) {
    return (n < 16 ? "0" : "") + n.toString(16);
  }).join("");
}
function uint32ToHex(val) {
  return (4294967296 + val).toString(16).substring(1);
}
function debugPrint(label, arr, size) {
  let msg = "\n" + label + " = ";
  for (let i2 = 0; i2 < arr.length; i2 += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i2]).toUpperCase();
      msg += " ";
      msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
    } else if (size === 64) {
      msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
      msg += uint32ToHex(arr[i2]).toUpperCase();
    } else
      throw new Error("Invalid size " + size);
    if (i2 % 6 === 4) {
      msg += "\n" + new Array(label.length + 4).join(" ");
    } else if (i2 < arr.length - 2) {
      msg += " ";
    }
  }
  console.log(msg);
}
function testSpeed(hashFn, N2, M) {
  let startMs = new Date().getTime();
  const input = new Uint8Array(N2);
  for (let i2 = 0; i2 < N2; i2++) {
    input[i2] = i2 % 256;
  }
  const genMs = new Date().getTime();
  console.log("Generated random input in " + (genMs - startMs) + "ms");
  startMs = genMs;
  for (let i2 = 0; i2 < M; i2++) {
    const hashHex = hashFn(input);
    const hashMs = new Date().getTime();
    const ms = hashMs - startMs;
    startMs = hashMs;
    console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
    console.log(
      Math.round(N2 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
    );
  }
}
var util$2 = {
  normalizeInput,
  toHex,
  debugPrint,
  testSpeed
};
const util$1 = util$2;
function ADD64AA(v2, a2, b2) {
  const o0 = v2[a2] + v2[b2];
  let o1 = v2[a2 + 1] + v2[b2 + 1];
  if (o0 >= 4294967296) {
    o1++;
  }
  v2[a2] = o0;
  v2[a2 + 1] = o1;
}
function ADD64AC(v2, a2, b0, b1) {
  let o0 = v2[a2] + b0;
  if (b0 < 0) {
    o0 += 4294967296;
  }
  let o1 = v2[a2 + 1] + b1;
  if (o0 >= 4294967296) {
    o1++;
  }
  v2[a2] = o0;
  v2[a2 + 1] = o1;
}
function B2B_GET32(arr, i2) {
  return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
}
function B2B_G(a2, b2, c2, d2, ix, iy) {
  const x0 = m$2[ix];
  const x1 = m$2[ix + 1];
  const y0 = m$2[iy];
  const y1 = m$2[iy + 1];
  ADD64AA(v$2, a2, b2);
  ADD64AC(v$2, a2, x0, x1);
  let xor0 = v$2[d2] ^ v$2[a2];
  let xor1 = v$2[d2 + 1] ^ v$2[a2 + 1];
  v$2[d2] = xor1;
  v$2[d2 + 1] = xor0;
  ADD64AA(v$2, c2, d2);
  xor0 = v$2[b2] ^ v$2[c2];
  xor1 = v$2[b2 + 1] ^ v$2[c2 + 1];
  v$2[b2] = xor0 >>> 24 ^ xor1 << 8;
  v$2[b2 + 1] = xor1 >>> 24 ^ xor0 << 8;
  ADD64AA(v$2, a2, b2);
  ADD64AC(v$2, a2, y0, y1);
  xor0 = v$2[d2] ^ v$2[a2];
  xor1 = v$2[d2 + 1] ^ v$2[a2 + 1];
  v$2[d2] = xor0 >>> 16 ^ xor1 << 16;
  v$2[d2 + 1] = xor1 >>> 16 ^ xor0 << 16;
  ADD64AA(v$2, c2, d2);
  xor0 = v$2[b2] ^ v$2[c2];
  xor1 = v$2[b2 + 1] ^ v$2[c2 + 1];
  v$2[b2] = xor1 >>> 31 ^ xor0 << 1;
  v$2[b2 + 1] = xor0 >>> 31 ^ xor1 << 1;
}
const BLAKE2B_IV32 = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
const SIGMA8 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
];
const SIGMA82 = new Uint8Array(
  SIGMA8.map(function(x2) {
    return x2 * 2;
  })
);
const v$2 = new Uint32Array(32);
const m$2 = new Uint32Array(32);
function blake2bCompress(ctx, last) {
  let i2 = 0;
  for (i2 = 0; i2 < 16; i2++) {
    v$2[i2] = ctx.h[i2];
    v$2[i2 + 16] = BLAKE2B_IV32[i2];
  }
  v$2[24] = v$2[24] ^ ctx.t;
  v$2[25] = v$2[25] ^ ctx.t / 4294967296;
  if (last) {
    v$2[28] = ~v$2[28];
    v$2[29] = ~v$2[29];
  }
  for (i2 = 0; i2 < 32; i2++) {
    m$2[i2] = B2B_GET32(ctx.b, 4 * i2);
  }
  for (i2 = 0; i2 < 12; i2++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
  }
  for (i2 = 0; i2 < 16; i2++) {
    ctx.h[i2] = ctx.h[i2] ^ v$2[i2] ^ v$2[i2 + 16];
  }
}
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0,
  //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0,
  //  4: leaf length, sequential mode
  0,
  0,
  0,
  0,
  //  8: node offset
  0,
  0,
  0,
  0,
  // 12: node offset
  0,
  0,
  0,
  0,
  // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0,
  // 20: rfu
  0,
  0,
  0,
  0,
  // 24: rfu
  0,
  0,
  0,
  0,
  // 28: rfu
  0,
  0,
  0,
  0,
  // 32: salt
  0,
  0,
  0,
  0,
  // 36: salt
  0,
  0,
  0,
  0,
  // 40: salt
  0,
  0,
  0,
  0,
  // 44: salt
  0,
  0,
  0,
  0,
  // 48: personal
  0,
  0,
  0,
  0,
  // 52: personal
  0,
  0,
  0,
  0,
  // 56: personal
  0,
  0,
  0,
  0
  // 60: personal
]);
function blake2bInit(outlen, key2, salt, personal) {
  if (outlen === 0 || outlen > 64) {
    throw new Error("Illegal output length, expected 0 < length <= 64");
  }
  if (key2 && key2.length > 64) {
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  }
  if (salt && salt.length !== 16) {
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  }
  if (personal && personal.length !== 16) {
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  }
  const ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0,
    // input count
    c: 0,
    // pointer within buffer
    outlen
    // output length in bytes
  };
  parameterBlock.fill(0);
  parameterBlock[0] = outlen;
  if (key2)
    parameterBlock[1] = key2.length;
  parameterBlock[2] = 1;
  parameterBlock[3] = 1;
  if (salt)
    parameterBlock.set(salt, 32);
  if (personal)
    parameterBlock.set(personal, 48);
  for (let i2 = 0; i2 < 16; i2++) {
    ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
  }
  if (key2) {
    blake2bUpdate(ctx, key2);
    ctx.c = 128;
  }
  return ctx;
}
function blake2bUpdate(ctx, input) {
  for (let i2 = 0; i2 < input.length; i2++) {
    if (ctx.c === 128) {
      ctx.t += ctx.c;
      blake2bCompress(ctx, false);
      ctx.c = 0;
    }
    ctx.b[ctx.c++] = input[i2];
  }
}
function blake2bFinal(ctx) {
  ctx.t += ctx.c;
  while (ctx.c < 128) {
    ctx.b[ctx.c++] = 0;
  }
  blake2bCompress(ctx, true);
  const out = new Uint8Array(ctx.outlen);
  for (let i2 = 0; i2 < ctx.outlen; i2++) {
    out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
  }
  return out;
}
function blake2b(input, key2, outlen, salt, personal) {
  outlen = outlen || 64;
  input = util$1.normalizeInput(input);
  if (salt) {
    salt = util$1.normalizeInput(salt);
  }
  if (personal) {
    personal = util$1.normalizeInput(personal);
  }
  const ctx = blake2bInit(outlen, key2, salt, personal);
  blake2bUpdate(ctx, input);
  return blake2bFinal(ctx);
}
function blake2bHex(input, key2, outlen, salt, personal) {
  const output = blake2b(input, key2, outlen, salt, personal);
  return util$1.toHex(output);
}
var blake2b_1 = {
  blake2b,
  blake2bHex,
  blake2bInit,
  blake2bUpdate,
  blake2bFinal
};
const util = util$2;
function B2S_GET32(v2, i2) {
  return v2[i2] ^ v2[i2 + 1] << 8 ^ v2[i2 + 2] << 16 ^ v2[i2 + 3] << 24;
}
function B2S_G(a2, b2, c2, d2, x2, y2) {
  v$1[a2] = v$1[a2] + v$1[b2] + x2;
  v$1[d2] = ROTR32(v$1[d2] ^ v$1[a2], 16);
  v$1[c2] = v$1[c2] + v$1[d2];
  v$1[b2] = ROTR32(v$1[b2] ^ v$1[c2], 12);
  v$1[a2] = v$1[a2] + v$1[b2] + y2;
  v$1[d2] = ROTR32(v$1[d2] ^ v$1[a2], 8);
  v$1[c2] = v$1[c2] + v$1[d2];
  v$1[b2] = ROTR32(v$1[b2] ^ v$1[c2], 7);
}
function ROTR32(x2, y2) {
  return x2 >>> y2 ^ x2 << 32 - y2;
}
const BLAKE2S_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0
]);
const v$1 = new Uint32Array(16);
const m$1 = new Uint32Array(16);
function blake2sCompress(ctx, last) {
  let i2 = 0;
  for (i2 = 0; i2 < 8; i2++) {
    v$1[i2] = ctx.h[i2];
    v$1[i2 + 8] = BLAKE2S_IV[i2];
  }
  v$1[12] ^= ctx.t;
  v$1[13] ^= ctx.t / 4294967296;
  if (last) {
    v$1[14] = ~v$1[14];
  }
  for (i2 = 0; i2 < 16; i2++) {
    m$1[i2] = B2S_GET32(ctx.b, 4 * i2);
  }
  for (i2 = 0; i2 < 10; i2++) {
    B2S_G(0, 4, 8, 12, m$1[SIGMA[i2 * 16 + 0]], m$1[SIGMA[i2 * 16 + 1]]);
    B2S_G(1, 5, 9, 13, m$1[SIGMA[i2 * 16 + 2]], m$1[SIGMA[i2 * 16 + 3]]);
    B2S_G(2, 6, 10, 14, m$1[SIGMA[i2 * 16 + 4]], m$1[SIGMA[i2 * 16 + 5]]);
    B2S_G(3, 7, 11, 15, m$1[SIGMA[i2 * 16 + 6]], m$1[SIGMA[i2 * 16 + 7]]);
    B2S_G(0, 5, 10, 15, m$1[SIGMA[i2 * 16 + 8]], m$1[SIGMA[i2 * 16 + 9]]);
    B2S_G(1, 6, 11, 12, m$1[SIGMA[i2 * 16 + 10]], m$1[SIGMA[i2 * 16 + 11]]);
    B2S_G(2, 7, 8, 13, m$1[SIGMA[i2 * 16 + 12]], m$1[SIGMA[i2 * 16 + 13]]);
    B2S_G(3, 4, 9, 14, m$1[SIGMA[i2 * 16 + 14]], m$1[SIGMA[i2 * 16 + 15]]);
  }
  for (i2 = 0; i2 < 8; i2++) {
    ctx.h[i2] ^= v$1[i2] ^ v$1[i2 + 8];
  }
}
function blake2sInit(outlen, key2) {
  if (!(outlen > 0 && outlen <= 32)) {
    throw new Error("Incorrect output length, should be in [1, 32]");
  }
  const keylen = key2 ? key2.length : 0;
  if (key2 && !(keylen > 0 && keylen <= 32)) {
    throw new Error("Incorrect key length, should be in [1, 32]");
  }
  const ctx = {
    h: new Uint32Array(BLAKE2S_IV),
    // hash state
    b: new Uint8Array(64),
    // input block
    c: 0,
    // pointer within block
    t: 0,
    // input count
    outlen
    // output length in bytes
  };
  ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
  if (keylen > 0) {
    blake2sUpdate(ctx, key2);
    ctx.c = 64;
  }
  return ctx;
}
function blake2sUpdate(ctx, input) {
  for (let i2 = 0; i2 < input.length; i2++) {
    if (ctx.c === 64) {
      ctx.t += ctx.c;
      blake2sCompress(ctx, false);
      ctx.c = 0;
    }
    ctx.b[ctx.c++] = input[i2];
  }
}
function blake2sFinal(ctx) {
  ctx.t += ctx.c;
  while (ctx.c < 64) {
    ctx.b[ctx.c++] = 0;
  }
  blake2sCompress(ctx, true);
  const out = new Uint8Array(ctx.outlen);
  for (let i2 = 0; i2 < ctx.outlen; i2++) {
    out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
  }
  return out;
}
function blake2s(input, key2, outlen) {
  outlen = outlen || 32;
  input = util.normalizeInput(input);
  const ctx = blake2sInit(outlen, key2);
  blake2sUpdate(ctx, input);
  return blake2sFinal(ctx);
}
function blake2sHex(input, key2, outlen) {
  const output = blake2s(input, key2, outlen);
  return util.toHex(output);
}
var blake2s_1 = {
  blake2s,
  blake2sHex,
  blake2sInit,
  blake2sUpdate,
  blake2sFinal
};
const b2b = blake2b_1;
const b2s = blake2s_1;
var blakejs = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
};
var safeBufferExports = {};
var safeBuffer = {
  get exports() {
    return safeBufferExports;
  },
  set exports(v2) {
    safeBufferExports = v2;
  }
};
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports2) {
  var buffer$1 = buffer;
  var Buffer2 = buffer$1.Buffer;
  function copyProps(src2, dst) {
    for (var key2 in src2) {
      dst[key2] = src2[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer$1;
  } else {
    copyProps(buffer$1, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$1.SlowBuffer(size);
  };
})(safeBuffer, safeBufferExports);
var readableBrowserExports = {};
var readableBrowser = {
  get exports() {
    return readableBrowserExports;
  },
  set exports(v2) {
    readableBrowserExports = v2;
  }
};
var eventsExports = {};
var events = {
  get exports() {
    return eventsExports;
  },
  set exports(v2) {
    eventsExports = v2;
  }
};
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$1 && typeof R$1.ownKeys === "function") {
  ReflectOwnKeys = R$1.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
eventsExports.once = once$2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key2;
    for (i2 = 0; i2 < keys.length; ++i2) {
      key2 = keys[i2];
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i2 = 0; i2 < n; ++i2)
    copy[i2] = arr[i2];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once$2(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var streamBrowser = eventsExports.EventEmitter;
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer, Buffer2 = _require.Buffer;
  var _require2 = require$$0$1, inspect9 = _require2.inspect;
  var custom = inspect9 && inspect9.custom || "inspect";
  function copyBuffer(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0)
          return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next) {
          ret += s2 + p2.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p2 = this.head;
        var i2 = 0;
        while (p2) {
          copyBuffer(p2.data, ret, i2);
          i2 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first2() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p2 = this.head;
        var c2 = 1;
        var ret = p2.data;
        n -= ret.length;
        while (p2 = p2.next) {
          var str = p2.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p2 = this.head;
        var c2 = 1;
        p2.data.copy(ret);
        n -= p2.data.length;
        while (p2 = p2.next) {
          var buf = p2.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect9(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return buffer_list;
}
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy(stream, err) {
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream.destroy(err);
  else
    stream.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code2, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code2;
  codes[code2] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len2 = expected.length;
    expected = expected.map(function(i2) {
      return String(i2);
    });
    if (len2 > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
    } else if (len2 === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start2) {
  if (typeof start2 !== "number") {
    start2 = 0;
  }
  if (start2 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start2) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
  return 'The value "' + value + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith(name2, " argument")) {
    msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes(name2, ".") ? "property" : "argument";
    msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
};
var browser$1 = deprecate;
function deprecate(fn, msg) {
  if (config$1("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config$1("throwDeprecation")) {
        throw new Error(msg);
      } else if (config$1("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config$1(name2) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_2) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: browser$1
  };
  var Stream = streamBrowser;
  var Buffer2 = buffer.Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  inherits_browserExports(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy2(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy2(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
    else if (writev)
      stream._writev(chunk, state2.onwrite);
    else
      stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy2(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy2(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK2();
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state2.bufferedRequestCount;
      var buffer2 = new Array(l2);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy2(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish2(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key2 in obj) {
      keys2.push(key2);
    }
    return keys2;
  };
  _stream_duplex = Duplex2;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  inherits_browserExports(Duplex2, Readable);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys.length; v2++) {
      var method = keys[v2];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var Buffer$d = safeBufferExports.Buffer;
var isEncoding = Buffer$d.isEncoding || function(encoding) {
  encoding = "" + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding(enc) {
  if (!enc)
    return "utf8";
  var retried;
  while (true) {
    switch (enc) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return enc;
      default:
        if (retried)
          return;
        enc = ("" + enc).toLowerCase();
        retried = true;
    }
  }
}
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== "string" && (Buffer$d.isEncoding === isEncoding || !isEncoding(enc)))
    throw new Error("Unknown encoding: " + enc);
  return nenc || enc;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case "base64":
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer$d.allocUnsafe(nb);
}
StringDecoder$1.prototype.write = function(buf) {
  if (buf.length === 0)
    return "";
  var r2;
  var i2;
  if (this.lastNeed) {
    r2 = this.fillLast(buf);
    if (r2 === void 0)
      return "";
    i2 = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i2 = 0;
  }
  if (i2 < buf.length)
    return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
  return r2 || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};
function utf8CheckByte(byte) {
  if (byte <= 127)
    return 0;
  else if (byte >> 5 === 6)
    return 2;
  else if (byte >> 4 === 14)
    return 3;
  else if (byte >> 3 === 30)
    return 4;
  return byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self2, buf, i2) {
  var j2 = buf.length - 1;
  if (j2 < i2)
    return 0;
  var nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j2 < i2 || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j2 < i2 || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self2, buf, p2) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "";
      }
    }
  }
}
function utf8FillLast(buf) {
  var p2 = this.lastTotal - this.lastNeed;
  var r2 = utf8CheckExtraBytes(this, buf);
  if (r2 !== void 0)
    return r2;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p2, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p2, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i2) {
  var total = utf8CheckIncomplete(this, buf, i2);
  if (!this.lastNeed)
    return buf.toString("utf8", i2);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i2, end);
}
function utf8End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + "";
  return r2;
}
function utf16Text(buf, i2) {
  if ((buf.length - i2) % 2 === 0) {
    var r2 = buf.toString("utf16le", i2);
    if (r2) {
      var c2 = r2.charCodeAt(r2.length - 1);
      if (c2 >= 55296 && c2 <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r2.slice(0, -1);
      }
    }
    return r2;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString("utf16le", i2, buf.length - 1);
}
function utf16End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r2 + this.lastChar.toString("utf16le", 0, end);
  }
  return r2;
}
function base64Text(buf, i2) {
  var n = (buf.length - i2) % 3;
  if (n === 0)
    return buf.toString("base64", i2);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i2, buf.length - n);
}
function base64End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  return r2;
}
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$2() {
}
function isRequest$1(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function eos$1(stream, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream, null, opts);
  if (!opts)
    opts = {};
  callback = once$1(callback || noop$2);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream.writable)
      onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend2() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream);
  };
  var onerror = function onerror2(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest2() {
    stream.req.on("finish", onfinish);
  };
  if (isRequest$1(stream)) {
    stream.on("complete", onfinish);
    stream.on("abort", onclose);
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !stream._writableState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (opts.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  return function() {
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data2 = iterator2[kStream].read();
        if (data2) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator2[kLastResolve] = resolve;
          iterator2[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        if (reject !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject(err);
        }
        iterator2[kError] = err;
        return;
      }
      var resolve = iterator2[kLastResolve];
      if (resolve !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex2;
  Readable.ReadableState = ReadableState;
  eventsExports.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = streamBrowser;
  var Buffer2 = buffer.Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$0$1;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder2;
  var createReadableStreamAsyncIterator;
  var from2;
  inherits_browserExports(Readable, Stream);
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2)
        StringDecoder2 = string_decoder.StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy2(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream, state2, chunk, false);
            else
              maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder2)
      StringDecoder2 = string_decoder.StringDecoder;
    var decoder = new StringDecoder2(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p2 = this._readableState.buffer.head;
    var content = "";
    while (p2 !== null) {
      content += decoder.write(p2.data);
      p2 = p2.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len2 = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len2 === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      process.nextTick(endFn);
    else
      src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy2(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len2; i2++) {
        dests[i2].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1)
      return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i2 in stream) {
      if (this[i2] === void 0 && typeof stream[i2] === "function") {
        this[i2] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x2) {
    for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
      if (xs[i2] === x2)
        return i2;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$3;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require_stream_duplex();
inherits_browserExports(Transform$3, Duplex);
function afterTransform(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$3(options) {
  if (!(this instanceof Transform$3))
    return new Transform$3(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done(_this, er, data2);
    });
  } else {
    done(this, null, null);
  }
}
Transform$3.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$3.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$3.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$3.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$3.prototype._destroy = function(err, cb) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
  });
};
function done(stream, er, data2) {
  if (er)
    return stream.emit("error", er);
  if (data2 != null)
    stream.push(data2);
  if (stream._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
var _stream_passthrough = PassThrough;
var Transform$2 = _stream_transform;
inherits_browserExports(PassThrough, Transform$2);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform$2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$1(err) {
  if (err)
    throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream))
      return stream.abort();
    if (typeof stream.destroy === "function")
      return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from2, to) {
  return from2.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop$1;
  if (typeof streams[streams.length - 1] !== "function")
    return noop$1;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams.map(function(stream, i2) {
    var reading = i2 < streams.length - 1;
    var writing = i2 > 0;
    return destroyer(stream, reading, writing, function(err) {
      if (!error)
        error = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module, exports2) {
  exports2 = module.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = _stream_transform;
  exports2.PassThrough = _stream_passthrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowserExports);
var Buffer$c = safeBufferExports.Buffer;
var Transform$1 = readableBrowserExports.Transform;
var inherits$d = inherits_browserExports;
function throwIfNotStringOrBuffer(val, prefix2) {
  if (!Buffer$c.isBuffer(val) && typeof val !== "string") {
    throw new TypeError(prefix2 + " must be a string or a buffer");
  }
}
function HashBase$2(blockSize) {
  Transform$1.call(this);
  this._block = Buffer$c.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}
inherits$d(HashBase$2, Transform$1);
HashBase$2.prototype._transform = function(chunk, encoding, callback) {
  var error = null;
  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }
  callback(error);
};
HashBase$2.prototype._flush = function(callback) {
  var error = null;
  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }
  callback(error);
};
HashBase$2.prototype.update = function(data2, encoding) {
  throwIfNotStringOrBuffer(data2, "Data");
  if (this._finalized)
    throw new Error("Digest already called");
  if (!Buffer$c.isBuffer(data2))
    data2 = Buffer$c.from(data2, encoding);
  var block = this._block;
  var offset = 0;
  while (this._blockOffset + data2.length - offset >= this._blockSize) {
    for (var i2 = this._blockOffset; i2 < this._blockSize; )
      block[i2++] = data2[offset++];
    this._update();
    this._blockOffset = 0;
  }
  while (offset < data2.length)
    block[this._blockOffset++] = data2[offset++];
  for (var j2 = 0, carry = data2.length * 8; carry > 0; ++j2) {
    this._length[j2] += carry;
    carry = this._length[j2] / 4294967296 | 0;
    if (carry > 0)
      this._length[j2] -= 4294967296 * carry;
  }
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(encoding) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = true;
  var digest9 = this._digest();
  if (encoding !== void 0)
    digest9 = digest9.toString(encoding);
  this._block.fill(0);
  this._blockOffset = 0;
  for (var i2 = 0; i2 < 4; ++i2)
    this._length[i2] = 0;
  return digest9;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2;
var inherits$c = inherits_browserExports;
var HashBase$1 = hashBase;
var Buffer$b = safeBufferExports.Buffer;
var ARRAY16$1 = new Array(16);
function MD5$1() {
  HashBase$1.call(this, 64);
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
}
inherits$c(MD5$1, HashBase$1);
MD5$1.prototype._update = function() {
  var M = ARRAY16$1;
  for (var i2 = 0; i2 < 16; ++i2)
    M[i2] = this._block.readInt32LE(i2 * 4);
  var a2 = this._a;
  var b2 = this._b;
  var c2 = this._c;
  var d2 = this._d;
  a2 = fnF(a2, b2, c2, d2, M[0], 3614090360, 7);
  d2 = fnF(d2, a2, b2, c2, M[1], 3905402710, 12);
  c2 = fnF(c2, d2, a2, b2, M[2], 606105819, 17);
  b2 = fnF(b2, c2, d2, a2, M[3], 3250441966, 22);
  a2 = fnF(a2, b2, c2, d2, M[4], 4118548399, 7);
  d2 = fnF(d2, a2, b2, c2, M[5], 1200080426, 12);
  c2 = fnF(c2, d2, a2, b2, M[6], 2821735955, 17);
  b2 = fnF(b2, c2, d2, a2, M[7], 4249261313, 22);
  a2 = fnF(a2, b2, c2, d2, M[8], 1770035416, 7);
  d2 = fnF(d2, a2, b2, c2, M[9], 2336552879, 12);
  c2 = fnF(c2, d2, a2, b2, M[10], 4294925233, 17);
  b2 = fnF(b2, c2, d2, a2, M[11], 2304563134, 22);
  a2 = fnF(a2, b2, c2, d2, M[12], 1804603682, 7);
  d2 = fnF(d2, a2, b2, c2, M[13], 4254626195, 12);
  c2 = fnF(c2, d2, a2, b2, M[14], 2792965006, 17);
  b2 = fnF(b2, c2, d2, a2, M[15], 1236535329, 22);
  a2 = fnG(a2, b2, c2, d2, M[1], 4129170786, 5);
  d2 = fnG(d2, a2, b2, c2, M[6], 3225465664, 9);
  c2 = fnG(c2, d2, a2, b2, M[11], 643717713, 14);
  b2 = fnG(b2, c2, d2, a2, M[0], 3921069994, 20);
  a2 = fnG(a2, b2, c2, d2, M[5], 3593408605, 5);
  d2 = fnG(d2, a2, b2, c2, M[10], 38016083, 9);
  c2 = fnG(c2, d2, a2, b2, M[15], 3634488961, 14);
  b2 = fnG(b2, c2, d2, a2, M[4], 3889429448, 20);
  a2 = fnG(a2, b2, c2, d2, M[9], 568446438, 5);
  d2 = fnG(d2, a2, b2, c2, M[14], 3275163606, 9);
  c2 = fnG(c2, d2, a2, b2, M[3], 4107603335, 14);
  b2 = fnG(b2, c2, d2, a2, M[8], 1163531501, 20);
  a2 = fnG(a2, b2, c2, d2, M[13], 2850285829, 5);
  d2 = fnG(d2, a2, b2, c2, M[2], 4243563512, 9);
  c2 = fnG(c2, d2, a2, b2, M[7], 1735328473, 14);
  b2 = fnG(b2, c2, d2, a2, M[12], 2368359562, 20);
  a2 = fnH(a2, b2, c2, d2, M[5], 4294588738, 4);
  d2 = fnH(d2, a2, b2, c2, M[8], 2272392833, 11);
  c2 = fnH(c2, d2, a2, b2, M[11], 1839030562, 16);
  b2 = fnH(b2, c2, d2, a2, M[14], 4259657740, 23);
  a2 = fnH(a2, b2, c2, d2, M[1], 2763975236, 4);
  d2 = fnH(d2, a2, b2, c2, M[4], 1272893353, 11);
  c2 = fnH(c2, d2, a2, b2, M[7], 4139469664, 16);
  b2 = fnH(b2, c2, d2, a2, M[10], 3200236656, 23);
  a2 = fnH(a2, b2, c2, d2, M[13], 681279174, 4);
  d2 = fnH(d2, a2, b2, c2, M[0], 3936430074, 11);
  c2 = fnH(c2, d2, a2, b2, M[3], 3572445317, 16);
  b2 = fnH(b2, c2, d2, a2, M[6], 76029189, 23);
  a2 = fnH(a2, b2, c2, d2, M[9], 3654602809, 4);
  d2 = fnH(d2, a2, b2, c2, M[12], 3873151461, 11);
  c2 = fnH(c2, d2, a2, b2, M[15], 530742520, 16);
  b2 = fnH(b2, c2, d2, a2, M[2], 3299628645, 23);
  a2 = fnI(a2, b2, c2, d2, M[0], 4096336452, 6);
  d2 = fnI(d2, a2, b2, c2, M[7], 1126891415, 10);
  c2 = fnI(c2, d2, a2, b2, M[14], 2878612391, 15);
  b2 = fnI(b2, c2, d2, a2, M[5], 4237533241, 21);
  a2 = fnI(a2, b2, c2, d2, M[12], 1700485571, 6);
  d2 = fnI(d2, a2, b2, c2, M[3], 2399980690, 10);
  c2 = fnI(c2, d2, a2, b2, M[10], 4293915773, 15);
  b2 = fnI(b2, c2, d2, a2, M[1], 2240044497, 21);
  a2 = fnI(a2, b2, c2, d2, M[8], 1873313359, 6);
  d2 = fnI(d2, a2, b2, c2, M[15], 4264355552, 10);
  c2 = fnI(c2, d2, a2, b2, M[6], 2734768916, 15);
  b2 = fnI(b2, c2, d2, a2, M[13], 1309151649, 21);
  a2 = fnI(a2, b2, c2, d2, M[4], 4149444226, 6);
  d2 = fnI(d2, a2, b2, c2, M[11], 3174756917, 10);
  c2 = fnI(c2, d2, a2, b2, M[2], 718787259, 15);
  b2 = fnI(b2, c2, d2, a2, M[9], 3951481745, 21);
  this._a = this._a + a2 | 0;
  this._b = this._b + b2 | 0;
  this._c = this._c + c2 | 0;
  this._d = this._d + d2 | 0;
};
MD5$1.prototype._digest = function() {
  this._block[this._blockOffset++] = 128;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();
  var buffer2 = Buffer$b.allocUnsafe(16);
  buffer2.writeInt32LE(this._a, 0);
  buffer2.writeInt32LE(this._b, 4);
  buffer2.writeInt32LE(this._c, 8);
  buffer2.writeInt32LE(this._d, 12);
  return buffer2;
};
function rotl$1(x2, n) {
  return x2 << n | x2 >>> 32 - n;
}
function fnF(a2, b2, c2, d2, m2, k, s2) {
  return rotl$1(a2 + (b2 & c2 | ~b2 & d2) + m2 + k | 0, s2) + b2 | 0;
}
function fnG(a2, b2, c2, d2, m2, k, s2) {
  return rotl$1(a2 + (b2 & d2 | c2 & ~d2) + m2 + k | 0, s2) + b2 | 0;
}
function fnH(a2, b2, c2, d2, m2, k, s2) {
  return rotl$1(a2 + (b2 ^ c2 ^ d2) + m2 + k | 0, s2) + b2 | 0;
}
function fnI(a2, b2, c2, d2, m2, k, s2) {
  return rotl$1(a2 + (c2 ^ (b2 | ~d2)) + m2 + k | 0, s2) + b2 | 0;
}
var md5_js = MD5$1;
var Buffer$a = buffer.Buffer;
var inherits$b = inherits_browserExports;
var HashBase = hashBase;
var ARRAY16 = new Array(16);
var zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$1() {
  HashBase.call(this, 64);
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
}
inherits$b(RIPEMD160$1, HashBase);
RIPEMD160$1.prototype._update = function() {
  var words = ARRAY16;
  for (var j2 = 0; j2 < 16; ++j2)
    words[j2] = this._block.readInt32LE(j2 * 4);
  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0;
  for (var i2 = 0; i2 < 80; i2 += 1) {
    var tl;
    var tr;
    if (i2 < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i2]], hl[0], sl[i2]);
      tr = fn5(ar, br, cr, dr, er, words[zr[i2]], hr[0], sr[i2]);
    } else if (i2 < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i2]], hl[1], sl[i2]);
      tr = fn4(ar, br, cr, dr, er, words[zr[i2]], hr[1], sr[i2]);
    } else if (i2 < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i2]], hl[2], sl[i2]);
      tr = fn3(ar, br, cr, dr, er, words[zr[i2]], hr[2], sr[i2]);
    } else if (i2 < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i2]], hl[3], sl[i2]);
      tr = fn2(ar, br, cr, dr, er, words[zr[i2]], hr[3], sr[i2]);
    } else {
      tl = fn5(al, bl, cl, dl, el, words[zl[i2]], hl[4], sl[i2]);
      tr = fn1(ar, br, cr, dr, er, words[zr[i2]], hr[4], sr[i2]);
    }
    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  }
  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};
RIPEMD160$1.prototype._digest = function() {
  this._block[this._blockOffset++] = 128;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();
  var buffer2 = Buffer$a.alloc ? Buffer$a.alloc(20) : new Buffer$a(20);
  buffer2.writeInt32LE(this._a, 0);
  buffer2.writeInt32LE(this._b, 4);
  buffer2.writeInt32LE(this._c, 8);
  buffer2.writeInt32LE(this._d, 12);
  buffer2.writeInt32LE(this._e, 16);
  return buffer2;
};
function rotl(x2, n) {
  return x2 << n | x2 >>> 32 - n;
}
function fn1(a2, b2, c2, d2, e, m2, k, s2) {
  return rotl(a2 + (b2 ^ c2 ^ d2) + m2 + k | 0, s2) + e | 0;
}
function fn2(a2, b2, c2, d2, e, m2, k, s2) {
  return rotl(a2 + (b2 & c2 | ~b2 & d2) + m2 + k | 0, s2) + e | 0;
}
function fn3(a2, b2, c2, d2, e, m2, k, s2) {
  return rotl(a2 + ((b2 | ~c2) ^ d2) + m2 + k | 0, s2) + e | 0;
}
function fn4(a2, b2, c2, d2, e, m2, k, s2) {
  return rotl(a2 + (b2 & d2 | c2 & ~d2) + m2 + k | 0, s2) + e | 0;
}
function fn5(a2, b2, c2, d2, e, m2, k, s2) {
  return rotl(a2 + (b2 ^ (c2 | ~d2)) + m2 + k | 0, s2) + e | 0;
}
var ripemd160 = RIPEMD160$1;
var sha_jsExports = {};
var sha_js = {
  get exports() {
    return sha_jsExports;
  },
  set exports(v2) {
    sha_jsExports = v2;
  }
};
var Buffer$9 = safeBufferExports.Buffer;
function Hash$7(blockSize, finalSize) {
  this._block = Buffer$9.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash$7.prototype.update = function(data2, enc) {
  if (typeof data2 === "string") {
    enc = enc || "utf8";
    data2 = Buffer$9.from(data2, enc);
  }
  var block = this._block;
  var blockSize = this._blockSize;
  var length = data2.length;
  var accum = this._len;
  for (var offset = 0; offset < length; ) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);
    for (var i2 = 0; i2 < remainder; i2++) {
      block[assigned + i2] = data2[offset + i2];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block);
    }
  }
  this._len += length;
  return this;
};
Hash$7.prototype.digest = function(enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 128;
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;
  if (bits <= 4294967295) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);
  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash3 = this._hash();
  return enc ? hash3.toString(enc) : hash3;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$2 = Hash$7;
var inherits$a = inherits_browserExports;
var Hash$6 = hash$2;
var Buffer$8 = safeBufferExports.Buffer;
var K$4 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$5 = new Array(80);
function Sha() {
  this.init();
  this._w = W$5;
  Hash$6.call(this, 64, 56);
}
inherits$a(Sha, Hash$6);
Sha.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl5$1(num) {
  return num << 5 | num >>> 27;
}
function rotl30$1(num) {
  return num << 30 | num >>> 2;
}
function ft$1(s2, b2, c2, d2) {
  if (s2 === 0)
    return b2 & c2 | ~b2 & d2;
  if (s2 === 2)
    return b2 & c2 | b2 & d2 | c2 & d2;
  return b2 ^ c2 ^ d2;
}
Sha.prototype._update = function(M) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e = this._e | 0;
  for (var i2 = 0; i2 < 16; ++i2)
    W2[i2] = M.readInt32BE(i2 * 4);
  for (; i2 < 80; ++i2)
    W2[i2] = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
  for (var j2 = 0; j2 < 80; ++j2) {
    var s2 = ~~(j2 / 20);
    var t = rotl5$1(a2) + ft$1(s2, b2, c2, d2) + e + W2[j2] + K$4[s2] | 0;
    e = d2;
    d2 = c2;
    c2 = rotl30$1(b2);
    b2 = a2;
    a2 = t;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e + this._e | 0;
};
Sha.prototype._hash = function() {
  var H2 = Buffer$8.allocUnsafe(20);
  H2.writeInt32BE(this._a | 0, 0);
  H2.writeInt32BE(this._b | 0, 4);
  H2.writeInt32BE(this._c | 0, 8);
  H2.writeInt32BE(this._d | 0, 12);
  H2.writeInt32BE(this._e | 0, 16);
  return H2;
};
var sha$1 = Sha;
var inherits$9 = inherits_browserExports;
var Hash$5 = hash$2;
var Buffer$7 = safeBufferExports.Buffer;
var K$3 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$4 = new Array(80);
function Sha1() {
  this.init();
  this._w = W$4;
  Hash$5.call(this, 64, 56);
}
inherits$9(Sha1, Hash$5);
Sha1.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s2, b2, c2, d2) {
  if (s2 === 0)
    return b2 & c2 | ~b2 & d2;
  if (s2 === 2)
    return b2 & c2 | b2 & d2 | c2 & d2;
  return b2 ^ c2 ^ d2;
}
Sha1.prototype._update = function(M) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e = this._e | 0;
  for (var i2 = 0; i2 < 16; ++i2)
    W2[i2] = M.readInt32BE(i2 * 4);
  for (; i2 < 80; ++i2)
    W2[i2] = rotl1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16]);
  for (var j2 = 0; j2 < 80; ++j2) {
    var s2 = ~~(j2 / 20);
    var t = rotl5(a2) + ft(s2, b2, c2, d2) + e + W2[j2] + K$3[s2] | 0;
    e = d2;
    d2 = c2;
    c2 = rotl30(b2);
    b2 = a2;
    a2 = t;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
  var H2 = Buffer$7.allocUnsafe(20);
  H2.writeInt32BE(this._a | 0, 0);
  H2.writeInt32BE(this._b | 0, 4);
  H2.writeInt32BE(this._c | 0, 8);
  H2.writeInt32BE(this._d | 0, 12);
  H2.writeInt32BE(this._e | 0, 16);
  return H2;
};
var sha1 = Sha1;
var inherits$8 = inherits_browserExports;
var Hash$4 = hash$2;
var Buffer$6 = safeBufferExports.Buffer;
var K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var W$3 = new Array(64);
function Sha256$1() {
  this.init();
  this._w = W$3;
  Hash$4.call(this, 64, 56);
}
inherits$8(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  this._a = 1779033703;
  this._b = 3144134277;
  this._c = 1013904242;
  this._d = 2773480762;
  this._e = 1359893119;
  this._f = 2600822924;
  this._g = 528734635;
  this._h = 1541459225;
  return this;
};
function ch(x2, y2, z2) {
  return z2 ^ x2 & (y2 ^ z2);
}
function maj$1(x2, y2, z2) {
  return x2 & y2 | z2 & (x2 | y2);
}
function sigma0$1(x2) {
  return (x2 >>> 2 | x2 << 30) ^ (x2 >>> 13 | x2 << 19) ^ (x2 >>> 22 | x2 << 10);
}
function sigma1$1(x2) {
  return (x2 >>> 6 | x2 << 26) ^ (x2 >>> 11 | x2 << 21) ^ (x2 >>> 25 | x2 << 7);
}
function gamma0(x2) {
  return (x2 >>> 7 | x2 << 25) ^ (x2 >>> 18 | x2 << 14) ^ x2 >>> 3;
}
function gamma1(x2) {
  return (x2 >>> 17 | x2 << 15) ^ (x2 >>> 19 | x2 << 13) ^ x2 >>> 10;
}
Sha256$1.prototype._update = function(M) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e = this._e | 0;
  var f2 = this._f | 0;
  var g2 = this._g | 0;
  var h2 = this._h | 0;
  for (var i2 = 0; i2 < 16; ++i2)
    W2[i2] = M.readInt32BE(i2 * 4);
  for (; i2 < 64; ++i2)
    W2[i2] = gamma1(W2[i2 - 2]) + W2[i2 - 7] + gamma0(W2[i2 - 15]) + W2[i2 - 16] | 0;
  for (var j2 = 0; j2 < 64; ++j2) {
    var T1 = h2 + sigma1$1(e) + ch(e, f2, g2) + K$2[j2] + W2[j2] | 0;
    var T2 = sigma0$1(a2) + maj$1(a2, b2, c2) | 0;
    h2 = g2;
    g2 = f2;
    f2 = e;
    e = d2 + T1 | 0;
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = T1 + T2 | 0;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f2 + this._f | 0;
  this._g = g2 + this._g | 0;
  this._h = h2 + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var H2 = Buffer$6.allocUnsafe(32);
  H2.writeInt32BE(this._a, 0);
  H2.writeInt32BE(this._b, 4);
  H2.writeInt32BE(this._c, 8);
  H2.writeInt32BE(this._d, 12);
  H2.writeInt32BE(this._e, 16);
  H2.writeInt32BE(this._f, 20);
  H2.writeInt32BE(this._g, 24);
  H2.writeInt32BE(this._h, 28);
  return H2;
};
var sha256$1 = Sha256$1;
var inherits$7 = inherits_browserExports;
var Sha256 = sha256$1;
var Hash$3 = hash$2;
var Buffer$5 = safeBufferExports.Buffer;
var W$2 = new Array(64);
function Sha224() {
  this.init();
  this._w = W$2;
  Hash$3.call(this, 64, 56);
}
inherits$7(Sha224, Sha256);
Sha224.prototype.init = function() {
  this._a = 3238371032;
  this._b = 914150663;
  this._c = 812702999;
  this._d = 4144912697;
  this._e = 4290775857;
  this._f = 1750603025;
  this._g = 1694076839;
  this._h = 3204075428;
  return this;
};
Sha224.prototype._hash = function() {
  var H2 = Buffer$5.allocUnsafe(28);
  H2.writeInt32BE(this._a, 0);
  H2.writeInt32BE(this._b, 4);
  H2.writeInt32BE(this._c, 8);
  H2.writeInt32BE(this._d, 12);
  H2.writeInt32BE(this._e, 16);
  H2.writeInt32BE(this._f, 20);
  H2.writeInt32BE(this._g, 24);
  return H2;
};
var sha224 = Sha224;
var inherits$6 = inherits_browserExports;
var Hash$2 = hash$2;
var Buffer$4 = safeBufferExports.Buffer;
var K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
var W$1 = new Array(160);
function Sha512() {
  this.init();
  this._w = W$1;
  Hash$2.call(this, 128, 112);
}
inherits$6(Sha512, Hash$2);
Sha512.prototype.init = function() {
  this._ah = 1779033703;
  this._bh = 3144134277;
  this._ch = 1013904242;
  this._dh = 2773480762;
  this._eh = 1359893119;
  this._fh = 2600822924;
  this._gh = 528734635;
  this._hh = 1541459225;
  this._al = 4089235720;
  this._bl = 2227873595;
  this._cl = 4271175723;
  this._dl = 1595750129;
  this._el = 2917565137;
  this._fl = 725511199;
  this._gl = 4215389547;
  this._hl = 327033209;
  return this;
};
function Ch(x2, y2, z2) {
  return z2 ^ x2 & (y2 ^ z2);
}
function maj(x2, y2, z2) {
  return x2 & y2 | z2 & (x2 | y2);
}
function sigma0(x2, xl) {
  return (x2 >>> 28 | xl << 4) ^ (xl >>> 2 | x2 << 30) ^ (xl >>> 7 | x2 << 25);
}
function sigma1(x2, xl) {
  return (x2 >>> 14 | xl << 18) ^ (x2 >>> 18 | xl << 14) ^ (xl >>> 9 | x2 << 23);
}
function Gamma0(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ x2 >>> 7;
}
function Gamma0l(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ (x2 >>> 7 | xl << 25);
}
function Gamma1(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ x2 >>> 6;
}
function Gamma1l(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ (x2 >>> 6 | xl << 26);
}
function getCarry(a2, b2) {
  return a2 >>> 0 < b2 >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M) {
  var W2 = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch2 = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl2 = this._hl | 0;
  for (var i2 = 0; i2 < 32; i2 += 2) {
    W2[i2] = M.readInt32BE(i2 * 4);
    W2[i2 + 1] = M.readInt32BE(i2 * 4 + 4);
  }
  for (; i2 < 160; i2 += 2) {
    var xh = W2[i2 - 15 * 2];
    var xl = W2[i2 - 15 * 2 + 1];
    var gamma02 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W2[i2 - 2 * 2];
    xl = W2[i2 - 2 * 2 + 1];
    var gamma12 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);
    var Wi7h = W2[i2 - 7 * 2];
    var Wi7l = W2[i2 - 7 * 2 + 1];
    var Wi16h = W2[i2 - 16 * 2];
    var Wi16l = W2[i2 - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma02 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma12 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W2[i2] = Wih;
    W2[i2 + 1] = Wil;
  }
  for (var j2 = 0; j2 < 160; j2 += 2) {
    Wih = W2[j2];
    Wil = W2[j2 + 1];
    var majh = maj(ah, bh, ch2);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);
    var Kih = K$1[j2];
    var Kil = K$1[j2 + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl2 + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl2) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl2 = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }
  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl2 | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch2 + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl2) | 0;
};
Sha512.prototype._hash = function() {
  var H2 = Buffer$4.allocUnsafe(64);
  function writeInt64BE(h2, l2, offset) {
    H2.writeInt32BE(h2, offset);
    H2.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H2;
};
var sha512 = Sha512;
var inherits$5 = inherits_browserExports;
var SHA512 = sha512;
var Hash$1 = hash$2;
var Buffer$3 = safeBufferExports.Buffer;
var W = new Array(160);
function Sha384() {
  this.init();
  this._w = W;
  Hash$1.call(this, 128, 112);
}
inherits$5(Sha384, SHA512);
Sha384.prototype.init = function() {
  this._ah = 3418070365;
  this._bh = 1654270250;
  this._ch = 2438529370;
  this._dh = 355462360;
  this._eh = 1731405415;
  this._fh = 2394180231;
  this._gh = 3675008525;
  this._hh = 1203062813;
  this._al = 3238371032;
  this._bl = 914150663;
  this._cl = 812702999;
  this._dl = 4144912697;
  this._el = 4290775857;
  this._fl = 1750603025;
  this._gl = 1694076839;
  this._hl = 3204075428;
  return this;
};
Sha384.prototype._hash = function() {
  var H2 = Buffer$3.allocUnsafe(48);
  function writeInt64BE(h2, l2, offset) {
    H2.writeInt32BE(h2, offset);
    H2.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H2;
};
var sha384 = Sha384;
var exports = sha_js.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports[algorithm];
  if (!Algorithm)
    throw new Error(algorithm + " is not supported (we accept pull requests)");
  return new Algorithm();
};
exports.sha = sha$1;
exports.sha1 = sha1;
exports.sha224 = sha224;
exports.sha256 = sha256$1;
exports.sha384 = sha384;
exports.sha512 = sha512;
var Buffer$2 = safeBufferExports.Buffer;
var Transform = require$$0$1.Transform;
var StringDecoder = string_decoder.StringDecoder;
var inherits$4 = inherits_browserExports;
function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === "string";
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
inherits$4(CipherBase, Transform);
CipherBase.prototype.update = function(data2, inputEnc, outputEnc) {
  if (typeof data2 === "string") {
    data2 = Buffer$2.from(data2, inputEnc);
  }
  var outData = this._update(data2);
  if (this.hashMode)
    return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function() {
};
CipherBase.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data2, _2, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data2);
    } else {
      this.push(this._update(data2));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase.prototype._flush = function(done2) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done2(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
  var outData = this.__final() || Buffer$2.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc)
    throw new Error("can't switch encodings");
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var cipherBase = CipherBase;
var inherits$3 = inherits_browserExports;
var MD5 = md5_js;
var RIPEMD160 = ripemd160;
var sha = sha_jsExports;
var Base$3 = cipherBase;
function Hash(hash3) {
  Base$3.call(this, "digest");
  this._hash = hash3;
}
inherits$3(Hash, Base$3);
Hash.prototype._update = function(data2) {
  this._hash.update(data2);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser = function createHash2(alg) {
  alg = alg.toLowerCase();
  if (alg === "md5")
    return new MD5();
  if (alg === "rmd160" || alg === "ripemd160")
    return new RIPEMD160();
  return new Hash(sha(alg));
};
var _Buffer = safeBufferExports.Buffer;
function base$2(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode4(source) {
    if (Array.isArray(source) || source instanceof Uint8Array) {
      source = _Buffer.from(source);
    }
    if (!_Buffer.isBuffer(source)) {
      throw new TypeError("Expected Buffer");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return _Buffer.alloc(0);
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0, 0, zeroes);
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string) {
    var buffer2 = decodeUnsafe2(string);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var src = base$2;
var basex = src;
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET);
var base58 = bs58;
var Buffer$1 = safeBufferExports.Buffer;
var base$1 = function(checksumFn) {
  function encode4(payload) {
    var checksum = checksumFn(payload);
    return base58.encode(Buffer$1.concat([
      payload,
      checksum
    ], payload.length + 4));
  }
  function decodeRaw(buffer2) {
    var payload = buffer2.slice(0, -4);
    var checksum = buffer2.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3])
      return;
    return payload;
  }
  function decodeUnsafe2(string) {
    var buffer2 = base58.decodeUnsafe(string);
    if (!buffer2)
      return;
    return decodeRaw(buffer2);
  }
  function decode2(string) {
    var buffer2 = base58.decode(string);
    var payload = decodeRaw(buffer2);
    if (!payload)
      throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode4,
    decode: decode2,
    decodeUnsafe: decodeUnsafe2
  };
};
var createHash = browser;
var bs58checkBase = base$1;
function sha256x2(buffer2) {
  var tmp = createHash("sha256").update(buffer2).digest();
  return createHash("sha256").update(tmp).digest();
}
var bs58check = bs58checkBase(sha256x2);
var elliptic = {};
const name = "elliptic";
const version = "6.5.4";
const description = "EC cryptography";
const main = "lib/elliptic.js";
const files = [
  "lib"
];
const scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
};
const repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
};
const keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
];
const author = "Fedor Indutny <fedor@indutny.com>";
const license = "MIT";
const bugs = {
  url: "https://github.com/indutny/elliptic/issues"
};
const homepage = "https://github.com/indutny/elliptic";
const devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
};
const dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
};
const require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$c = {};
var bnExports = {};
var bn = {
  get exports() {
    return bnExports;
  },
  set exports(v2) {
    bnExports = v2;
  }
};
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base2, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$1.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init5(number, base2, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base2, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start2 = 0;
      if (number[0] === "-") {
        start2++;
        this.negative = 1;
      }
      if (start2 < number.length) {
        if (base2 === 16) {
          this._parseHex(number, start2, endian);
        } else {
          this._parseBase(number, base2, start2);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base2, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
          w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string, index) {
      var c2 = string.charCodeAt(index);
      if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        return c2 - 48 & 15;
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r2 = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string, index - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start2, endian) {
      this.length = Math.ceil((number.length - start2) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number.length - 1; i2 >= start2; i2 -= 2) {
          w2 = parseHexByte(number, start2, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start2;
        for (i2 = parseLength % 2 === 0 ? start2 + 1 : start2; i2 < number.length; i2 += 2) {
          w2 = parseHexByte(number, start2, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start2, end, mul7) {
      var r2 = 0;
      var len2 = Math.min(str.length, end);
      for (var i2 = start2; i2 < len2; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul7;
        if (c2 >= 49) {
          r2 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r2 += c2 - 17 + 10;
        } else {
          r2 += c2;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base2, start2) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number.length - start2;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start2;
      var word = 0;
      for (var i2 = start2; i2 < end; i2 += limbLen) {
        word = parseBase(number, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i2, number.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer(endian, length) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i2;
      var q = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q.isZero(); i2++) {
          b2 = q.andln(255);
          q.iushrn(8);
          res[reqLength - i2 - 1] = b2;
        }
      } else {
        for (i2 = 0; !q.isZero(); i2++) {
          b2 = q.andln(255);
          q.iushrn(8);
          res[i2] = b2;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t = w2;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t = w2;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len2; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j2 = Math.max(0, k - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c2 !== 0) {
        o[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j2 = Math.max(0, k - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    FFTM.prototype.makeRBT = function makeRBT(N2) {
      var t = new Array(N2);
      var l2 = BN2.prototype._countBits(N2) - 1;
      for (var i2 = 0; i2 < N2; i2++) {
        t[i2] = this.revBin(i2, l2, N2);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N2) {
      if (x2 === 0 || x2 === N2 - 1)
        return x2;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x2 & 1) << l2 - i2 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
      for (var i2 = 0; i2 < N2; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N2);
      for (var s2 = 1; s2 < N2; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N2; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s2; j2++) {
            var re = rtws[p2 + j2];
            var ie = itws[p2 + j2];
            var ro = rtws[p2 + j2 + s2];
            var io = itws[p2 + j2 + s2];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j2] = re + ro;
            itws[p2 + j2] = ie + io;
            rtws[p2 + j2 + s2] = re - ro;
            itws[p2 + j2 + s2] = ie - io;
            if (j2 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
      var N2 = Math.max(m2, n) | 1;
      var odd = N2 & 1;
      var i2 = 0;
      for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
      if (N2 <= 1)
        return;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var t = rws[i2];
        rws[i2] = rws[N2 - i2 - 1];
        rws[N2 - i2 - 1] = t;
        t = iws[i2];
        iws[i2] = -iws[N2 - i2 - 1];
        iws[N2 - i2 - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
        ws[i2] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < len2; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len2; i2 < N2; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N2) {
      var ph = new Array(N2);
      for (var i2 = 0; i2 < N2; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y2, out) {
      var N2 = 2 * this.guessLen13b(x2.length, y2.length);
      var rbt = this.makeRBT(N2);
      var _2 = this.stub(N2);
      var rws = new Array(N2);
      var rwst = new Array(N2);
      var iwst = new Array(N2);
      var nrws = new Array(N2);
      var nrwst = new Array(N2);
      var niwst = new Array(N2);
      var rmws = out.words;
      rmws.length = N2;
      this.convert13b(x2.words, x2.length, rws, N2);
      this.convert13b(y2.words, y2.length, nrws, N2);
      this.transform(rws, _2, rwst, iwst, N2, rbt);
      this.transform(nrws, _2, nrwst, niwst, N2, rbt);
      for (var i2 = 0; i2 < N2; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N2);
      this.transform(rwst, iwst, rmws, _2, N2, rbt);
      this.conjugate(rmws, _2, N2);
      this.normalize13b(rmws, N2);
      out.negative = x2.negative ^ y2.negative;
      out.length = x2.length + y2.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q = res.sqr(); i2 < w2.length; i2++, q = q.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul7;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m2 + 1;
        q.words = new Array(q.length);
        for (var i2 = 0; i2 < q.length; i2++) {
          q.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q) {
          q.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q) {
          q.words[j2] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a2.strip();
      if (mode !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B.isOdd()) {
              A2.iadd(yp);
              B.isub(xp);
            }
            A2.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C);
          B.isub(D);
        } else {
          y2.isub(x2);
          C.isub(A2);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t = a2;
          a2 = b2;
          b2 = t;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg6(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add7(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul7(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q);
      var r2 = this.pow(a2, q.addn(1).iushrn(1));
      var t = this.pow(a2, q);
      var m2 = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t = t.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start2 = num.bitLength() % 26;
      if (start2 === 0) {
        start2 = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j2 = start2 - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start2 = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t = a2.imul(b2);
      var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t = a2.mul(b2);
      var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var utils$b = {};
(function(exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode4(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
})(utils$b);
(function(exports2) {
  var utils2 = exports2;
  var BN2 = bnExports;
  var minAssert = minimalisticAssert$1;
  var minUtils = utils$b;
  utils2.assert = minAssert;
  utils2.toArray = minUtils.toArray;
  utils2.zero2 = minUtils.zero2;
  utils2.toHex = minUtils.toHex;
  utils2.encode = minUtils.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z2;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i2] = z2;
      k.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes) {
    return new BN2(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
})(utils$c);
var brorandExports = {};
var brorand = {
  get exports() {
    return brorandExports;
  },
  set exports(v2) {
    brorandExports = v2;
  }
};
var r;
brorand.exports = function rand2(len2) {
  if (!r)
    r = new Rand(null);
  return r.generate(len2);
};
function Rand(rand3) {
  this.rand = rand3;
}
brorandExports.Rand = Rand;
Rand.prototype.generate = function generate2(len2) {
  return this._rand(len2);
};
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);
  var res = new Uint8Array(n);
  for (var i2 = 0; i2 < res.length; i2++)
    res[i2] = this.rand.getByte();
  return res;
};
if (typeof self === "object") {
  if (self.crypto && self.crypto.getRandomValues) {
    Rand.prototype._rand = function _rand2(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    Rand.prototype._rand = function _rand2(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else if (typeof window === "object") {
    Rand.prototype._rand = function() {
      throw new Error("Not implemented yet");
    };
  }
} else {
  try {
    var crypto$1 = require$$0$1;
    if (typeof crypto$1.randomBytes !== "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function _rand2(n) {
      return crypto$1.randomBytes(n);
    };
  } catch (e) {
  }
}
var curve = {};
var BN$7 = bnExports;
var utils$a = utils$c;
var getNAF = utils$a.getNAF;
var getJSF = utils$a.getJSF;
var assert$9 = utils$a.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$7(conf.p, 16);
  this.red = conf.prime ? BN$7.red(conf.prime) : BN$7.mont(this.p);
  this.zero = new BN$7(0).toRed(this.red);
  this.one = new BN$7(1).toRed(this.red);
  this.two = new BN$7(2).toRed(this.red);
  this.n = conf.n && new BN$7(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point3() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate5() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul2(p2, k) {
  assert$9(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul2(p2, k) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z2 = naf[i2];
    assert$9(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len2; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max = Math.max(naf[a2].length, max);
      max = Math.max(naf[b2].length, max);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b2]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max = Math.max(jsf[0].length, max);
    naf[a2] = new Array(max);
    naf[b2] = new Array(max);
    for (j2 = 0; j2 < max; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max; i2 >= 0; i2--) {
    var k = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len2; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i2--;
    }
    if (i2 >= 0)
      k++;
    acc = acc.dblp(k);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len2; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len2; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq4() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate6() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint2(bytes, enc) {
  bytes = utils$a.toArray(bytes, enc);
  var len2 = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
    if (bytes[0] === 6)
      assert$9(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$9(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len2),
      bytes.slice(1 + len2, 1 + 2 * len2)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2) {
    return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed2(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode3(compact2) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact2)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint.prototype.encode = function encode3(enc, compact2) {
  return utils$a.encode(this._encode(compact2), enc);
};
BasePoint.prototype.precompute = function precompute2(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles2(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles2(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl7 = max === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max; i2++)
    res[i2] = res[i2 - 1].add(dbl7);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta3() {
  return null;
};
BasePoint.prototype.dblp = function dblp3(k) {
  var r2 = this;
  for (var i2 = 0; i2 < k; i2++)
    r2 = r2.dbl();
  return r2;
};
var utils$9 = utils$c;
var BN$6 = bnExports;
var inherits$2 = inherits_browserExports;
var Base$2 = base;
var assert$8 = utils$9.assert;
function ShortCurve(conf) {
  Base$2.call(this, "short", conf);
  this.a = new BN$6(conf.a, 16).toRed(this.red);
  this.b = new BN$6(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$2(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism2(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$6(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$6(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$8(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$6(vec.a, 16),
        b: new BN$6(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots2(num) {
  var red = num === this.p ? this.red : BN$6.mont(num);
  var tinv = new BN$6(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$6(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$6(1);
  var y1 = new BN$6(0);
  var x2 = new BN$6(0);
  var y2 = new BN$6(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q = v2.div(u2);
    r2 = v2.sub(q.mul(u2));
    x3 = x2.sub(q.mul(x1));
    var y3 = y2.sub(q.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit2(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve.prototype.pointFromX = function pointFromX2(x2, odd) {
  x2 = new BN$6(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate7(point7) {
  if (point7.inf)
    return true;
  var x2 = point7.x;
  var y2 = point7.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point$2(curve2, x2, y2, isRed) {
  Base$2.BasePoint.call(this, curve2, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$6(x2, 16);
    this.y = new BN$6(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$2(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function point4(x2, y2, isRed) {
  return new Point$2(this, x2, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON2(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};
Point$2.prototype._getBeta = function _getBeta4() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p2) {
      return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$2.prototype.toJSON = function toJSON2() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$2.fromJSON = function fromJSON2(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$2.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function isInfinity3() {
  return this.inf;
};
Point$2.prototype.add = function add3(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.dbl = function dbl3() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.getX = function getX2() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function getY2() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function mul3(k) {
  k = new BN$6(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point$2.prototype.mulAdd = function mulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$2.prototype.jmulAdd = function jmulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$2.prototype.eq = function eq5(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point$2.prototype.neg = function neg3(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$2.prototype.toJ = function toJ2() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve2, x2, y2, z2) {
  Base$2.BasePoint.call(this, curve2, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$6(0);
  } else {
    this.x = new BN$6(x2, 16);
    this.y = new BN$6(y2, 16);
    this.z = new BN$6(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits$2(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function jpoint2(x2, y2, z2) {
  return new JPoint(this, x2, y2, z2);
};
JPoint.prototype.toP = function toP2() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg4() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add4(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd2(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp4(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m2.redSqr().redISub(s2).redISub(s2);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl2() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl2() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t.redISub(u2)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul4(k, kbase) {
  k = new BN$6(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq6(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP2(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect5() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity4() {
  return this.z.cmpn(0) === 0;
};
var BN$5 = bnExports;
var inherits$1 = inherits_browserExports;
var Base$1 = base;
var utils$8 = utils$c;
function MontCurve(conf) {
  Base$1.call(this, "mont", conf);
  this.a = new BN$5(conf.a, 16).toRed(this.red);
  this.b = new BN$5(conf.b, 16).toRed(this.red);
  this.i4 = new BN$5(4).toRed(this.red).redInvm();
  this.two = new BN$5(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$1(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function validate8(point7) {
  var x2 = point7.normalize().x;
  var x22 = x2.redSqr();
  var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
  var y2 = rhs.redSqrt();
  return y2.redSqr().cmp(rhs) === 0;
};
function Point$1(curve2, x2, z2) {
  Base$1.BasePoint.call(this, curve2, "projective");
  if (x2 === null && z2 === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$5(x2, 16);
    this.z = new BN$5(z2, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$1(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint3(bytes, enc) {
  return this.point(utils$8.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point5(x2, z2) {
  return new Point$1(this, x2, z2);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON3(obj) {
  return Point$1.fromJSON(this, obj);
};
Point$1.prototype.precompute = function precompute3() {
};
Point$1.prototype._encode = function _encode4() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function fromJSON3(curve2, obj) {
  return new Point$1(curve2, obj[0], obj[1] || curve2.one);
};
Point$1.prototype.inspect = function inspect6() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function isInfinity5() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function dbl5() {
  var a2 = this.x.redAdd(this.z);
  var aa = a2.redSqr();
  var b2 = this.x.redSub(this.z);
  var bb = b2.redSqr();
  var c2 = aa.redSub(bb);
  var nx = aa.redMul(bb);
  var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
  return this.curve.point(nx, nz);
};
Point$1.prototype.add = function add5() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function diffAdd(p2, diff) {
  var a2 = this.x.redAdd(this.z);
  var b2 = this.x.redSub(this.z);
  var c2 = p2.x.redAdd(p2.z);
  var d2 = p2.x.redSub(p2.z);
  var da = d2.redMul(a2);
  var cb = c2.redMul(b2);
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point$1.prototype.mul = function mul5(k) {
  var t = k.clone();
  var a2 = this;
  var b2 = this.curve.point(null, null);
  var c2 = this;
  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));
  for (var i2 = bits.length - 1; i2 >= 0; i2--) {
    if (bits[i2] === 0) {
      a2 = a2.diffAdd(b2, c2);
      b2 = b2.dbl();
    } else {
      b2 = a2.diffAdd(b2, c2);
      a2 = a2.dbl();
    }
  }
  return b2;
};
Point$1.prototype.mulAdd = function mulAdd3() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function eq7(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point$1.prototype.normalize = function normalize2() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point$1.prototype.getX = function getX3() {
  this.normalize();
  return this.x.fromRed();
};
var utils$7 = utils$c;
var BN$4 = bnExports;
var inherits = inherits_browserExports;
var Base = base;
var assert$7 = utils$7.assert;
function EdwardsCurve(conf) {
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, "edwards", conf);
  this.a = new BN$4(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$4(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$4(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert$7(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};
EdwardsCurve.prototype.jpoint = function jpoint3(x2, y2, z2, t) {
  return this.point(x2, y2, z2, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX3(x2, odd) {
  x2 = new BN$4(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var x22 = x2.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x22));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
  var y2 = rhs.redMul(lhs.redInvm());
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y2, odd) {
  y2 = new BN$4(y2, 16);
  if (!y2.red)
    y2 = y2.toRed(this.red);
  var y22 = y2.redSqr();
  var lhs = y22.redSub(this.c2);
  var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error("invalid point");
    else
      return this.point(this.zero, y2);
  }
  var x3 = x2.redSqrt();
  if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  if (x3.fromRed().isOdd() !== odd)
    x3 = x3.redNeg();
  return this.point(x3, y2);
};
EdwardsCurve.prototype.validate = function validate9(point7) {
  if (point7.isInfinity())
    return true;
  point7.normalize();
  var x2 = point7.x.redSqr();
  var y2 = point7.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};
function Point(curve2, x2, y2, z2, t) {
  Base.BasePoint.call(this, curve2, "projective");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$4(x2, 16);
    this.y = new BN$4(y2, 16);
    this.z = z2 ? new BN$4(z2, 16) : this.curve.one;
    this.t = t && new BN$4(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON4(obj) {
  return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point6(x2, y2, z2, t) {
  return new Point(this, x2, y2, z2, t);
};
Point.fromJSON = function fromJSON4(curve2, obj) {
  return new Point(curve2, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect7() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity6() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
  var a2 = this.x.redSqr();
  var b2 = this.y.redSqr();
  var c2 = this.z.redSqr();
  c2 = c2.redIAdd(c2);
  var d2 = this.curve._mulA(a2);
  var e = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
  var g2 = d2.redAdd(b2);
  var f2 = g2.redSub(c2);
  var h2 = d2.redSub(b2);
  var nx = e.redMul(f2);
  var ny = g2.redMul(h2);
  var nt = e.redMul(h2);
  var nz = f2.redMul(g2);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
  var b2 = this.x.redAdd(this.y).redSqr();
  var c2 = this.x.redSqr();
  var d2 = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e;
  var h2;
  var j2;
  if (this.curve.twisted) {
    e = this.curve._mulA(c2);
    var f2 = e.redAdd(d2);
    if (this.zOne) {
      nx = b2.redSub(c2).redSub(d2).redMul(f2.redSub(this.curve.two));
      ny = f2.redMul(e.redSub(d2));
      nz = f2.redSqr().redSub(f2).redSub(f2);
    } else {
      h2 = this.z.redSqr();
      j2 = f2.redSub(h2).redISub(h2);
      nx = b2.redSub(c2).redISub(d2).redMul(j2);
      ny = f2.redMul(e.redSub(d2));
      nz = f2.redMul(j2);
    }
  } else {
    e = c2.redAdd(d2);
    h2 = this.curve._mulC(this.z).redSqr();
    j2 = e.redSub(h2).redSub(h2);
    nx = this.curve._mulC(b2.redISub(e)).redMul(j2);
    ny = this.curve._mulC(e).redMul(c2.redISub(d2));
    nz = e.redMul(j2);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl6() {
  if (this.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p2) {
  var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
  var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
  var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
  var d2 = this.z.redMul(p2.z.redAdd(p2.z));
  var e = b2.redSub(a2);
  var f2 = d2.redSub(c2);
  var g2 = d2.redAdd(c2);
  var h2 = b2.redAdd(a2);
  var nx = e.redMul(f2);
  var ny = g2.redMul(h2);
  var nt = e.redMul(h2);
  var nz = f2.redMul(g2);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p2) {
  var a2 = this.z.redMul(p2.z);
  var b2 = a2.redSqr();
  var c2 = this.x.redMul(p2.x);
  var d2 = this.y.redMul(p2.y);
  var e = this.curve.d.redMul(c2).redMul(d2);
  var f2 = b2.redSub(e);
  var g2 = b2.redAdd(e);
  var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d2);
  var nx = a2.redMul(f2).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    ny = a2.redMul(g2).redMul(d2.redSub(this.curve._mulA(c2)));
    nz = f2.redMul(g2);
  } else {
    ny = a2.redMul(g2).redMul(d2.redSub(c2));
    nz = this.curve._mulC(f2).redMul(g2);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add6(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extAdd(p2);
  else
    return this._projAdd(p2);
};
Point.prototype.mul = function mul6(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd4(k1, p2, k2) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd3(k1, p2, k2) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
};
Point.prototype.normalize = function normalize3() {
  if (this.zOne)
    return this;
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point.prototype.neg = function neg5() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function getX4() {
  this.normalize();
  return this.x.fromRed();
};
Point.prototype.getY = function getY3() {
  this.normalize();
  return this.y.fromRed();
};
Point.prototype.eq = function eq8(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP3(x2) {
  var rx = x2.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t = this.curve.redN.redMul(this.z);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(exports2) {
  var curve2 = exports2;
  curve2.base = base;
  curve2.short = short;
  curve2.mont = mont;
  curve2.edwards = edwards;
})(curve);
var curves$2 = {};
var secp256k1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1)
    return secp256k1;
  hasRequiredSecp256k1 = 1;
  secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1;
}
(function(exports2) {
  var curves2 = exports2;
  var hash3 = hash$3;
  var curve$1 = curve;
  var utils2 = utils$c;
  var assert2 = utils2.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve$1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve$1.edwards(options);
    else
      this.curve = new curve$1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = requireSecp256k1();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
})(curves$2);
var hash$1 = hash$3;
var utils$6 = utils$b;
var assert$6 = minimalisticAssert$1;
function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils$6.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils$6.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils$6.toArray(options.pers, options.persEnc || "hex");
  assert$6(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function init4(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function hmac3() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function update5(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG$1.prototype.reseed = function reseed2(entropy, entropyEnc, add7, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add7;
    add7 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils$6.toArray(entropy, entropyEnc);
  add7 = utils$6.toArray(add7, addEnc);
  assert$6(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add7 || []));
  this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function generate3(len2, enc, add7, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add7;
    add7 = enc;
    enc = null;
  }
  if (add7) {
    add7 = utils$6.toArray(add7, addEnc || "hex");
    this._update(add7);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add7);
  this._reseed++;
  return utils$6.encode(res, enc);
};
var BN$3 = bnExports;
var utils$5 = utils$c;
var assert$5 = utils$5.assert;
function KeyPair$3(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;
KeyPair$3.fromPublic = function fromPublic2(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$3)
    return pub2;
  return new KeyPair$3(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$3.fromPrivate = function fromPrivate2(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$3)
    return priv2;
  return new KeyPair$3(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$3.prototype.validate = function validate10() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$3.prototype.getPublic = function getPublic2(compact2, enc) {
  if (typeof compact2 === "string") {
    enc = compact2;
    compact2 = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact2);
};
KeyPair$3.prototype.getPrivate = function getPrivate2(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$3.prototype._importPrivate = function _importPrivate2(key2, enc) {
  this.priv = new BN$3(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function _importPublic2(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$5(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$5(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$3.prototype.derive = function derive2(pub2) {
  if (!pub2.validate()) {
    assert$5(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function sign3(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$3.prototype.verify = function verify3(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair$3.prototype.inspect = function inspect8() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$2 = bnExports;
var utils$4 = utils$c;
var assert$4 = utils$4.assert;
function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$2(options.r, 16);
  this.s = new BN$2(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len2 = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature$3.prototype._importDER = function _importDER2(data2, enc) {
  data2 = utils$4.toArray(data2, enc);
  var p2 = new Position();
  if (data2[p2.place++] !== 48) {
    return false;
  }
  var len2 = getLength(data2, p2);
  if (len2 === false) {
    return false;
  }
  if (len2 + p2.place !== data2.length) {
    return false;
  }
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data2, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data2, p2);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p2.place) {
    return false;
  }
  var s2 = data2.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$2(r2);
  this.s = new BN$2(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len2) {
  if (len2 < 128) {
    arr.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len2 >>> (octets << 3) & 255);
  }
  arr.push(len2);
}
Signature$3.prototype.toDER = function toDER2(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$4.encode(res, enc);
};
var BN$1 = bnExports;
var HmacDRBG = hmacDrbg;
var utils$3 = utils$c;
var curves$1 = curves$2;
var rand = brorandExports;
var assert$3 = utils$3.assert;
var KeyPair$2 = key$1;
var Signature$2 = signature$1;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$3(
      Object.prototype.hasOwnProperty.call(curves$1, options),
      "Unknown curve " + options
    );
    options = curves$1[options];
  }
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair2(options) {
  return new KeyPair$2(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate2(priv2, enc) {
  return KeyPair$2.fromPrivate(this, priv2, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic2(pub2, enc) {
  return KeyPair$2.fromPublic(this, pub2, enc);
};
EC.prototype.genKeyPair = function genKeyPair2(options) {
  if (!options)
    options = {};
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (; ; ) {
    var priv2 = new BN$1(drbg.generate(bytes));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC.prototype._truncateToN = function _truncateToN2(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign4(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$1(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$1(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new Signature$2({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify4(msg, signature2, key2, enc) {
  msg = this._truncateToN(new BN$1(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature2 = new Signature$2(signature2, "hex");
  var r2 = signature2.r;
  var s2 = signature2.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature2, j2, enc) {
  assert$3((3 & j2) === j2, "The recovery param is more than two bits");
  signature2 = new Signature$2(signature2, enc);
  var n = this.n;
  var e = new BN$1(msg);
  var r2 = signature2.r;
  var s2 = signature2.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature2.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
  signature2 = new Signature$2(signature2, enc);
  if (signature2.recoveryParam !== null)
    return signature2.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature2, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$2 = utils$c;
var assert$2 = utils$2.assert;
var parseBytes$3 = utils$2.parseBytes;
var cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(eddsa2, params) {
  this.eddsa = eddsa2;
  this._secret = parseBytes$3(params.secret);
  if (eddsa2.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$3(params.pub);
}
KeyPair$1.fromPublic = function fromPublic3(eddsa2, pub2) {
  if (pub2 instanceof KeyPair$1)
    return pub2;
  return new KeyPair$1(eddsa2, { pub: pub2 });
};
KeyPair$1.fromSecret = function fromSecret(eddsa2, secret2) {
  if (secret2 instanceof KeyPair$1)
    return secret2;
  return new KeyPair$1(eddsa2, { secret: secret2 });
};
KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function privBytes() {
  var eddsa2 = this.eddsa;
  var hash3 = this.hash();
  var lastIx = eddsa2.encodingLength - 1;
  var a2 = hash3.slice(0, eddsa2.encodingLength);
  a2[0] &= 248;
  a2[lastIx] &= 127;
  a2[lastIx] |= 64;
  return a2;
});
cachedProperty$1(KeyPair$1, "priv", function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function hash2() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function sign5(message) {
  assert$2(this._secret, "KeyPair can only verify");
  return this.eddsa.sign(message, this);
};
KeyPair$1.prototype.verify = function verify5(message, sig) {
  return this.eddsa.verify(message, sig, this);
};
KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$2(this._secret, "KeyPair is public only");
  return utils$2.encode(this.secret(), enc);
};
KeyPair$1.prototype.getPublic = function getPublic3(enc) {
  return utils$2.encode(this.pubBytes(), enc);
};
var key = KeyPair$1;
var BN = bnExports;
var utils$1 = utils$c;
var assert$1 = utils$1.assert;
var cachedProperty = utils$1.cachedProperty;
var parseBytes$2 = utils$1.parseBytes;
function Signature$1(eddsa2, sig) {
  this.eddsa = eddsa2;
  if (typeof sig !== "object")
    sig = parseBytes$2(sig);
  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa2.encodingLength),
      S: sig.slice(eddsa2.encodingLength)
    };
  }
  assert$1(sig.R && sig.S, "Signature without R or S");
  if (eddsa2.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature$1, "S", function S2() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function R2() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function toHex2() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1;
var hash = hash$3;
var curves = curves$2;
var utils = utils$c;
var assert = utils.assert;
var parseBytes$1 = utils.parseBytes;
var KeyPair = key;
var Signature = signature;
function EDDSA(curve2) {
  assert(curve2 === "ed25519", "only tested with ed25519 so far");
  if (!(this instanceof EDDSA))
    return new EDDSA(curve2);
  curve2 = curves[curve2].curve;
  this.curve = curve2;
  this.g = curve2.g;
  this.g.precompute(curve2.n.bitLength() + 1);
  this.pointClass = curve2.point().constructor;
  this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
  this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function sign6(message, secret2) {
  message = parseBytes$1(message);
  var key2 = this.keyFromSecret(secret2);
  var r2 = this.hashInt(key2.messagePrefix(), message);
  var R3 = this.g.mul(r2);
  var Rencoded2 = this.encodePoint(R3);
  var s_ = this.hashInt(Rencoded2, key2.pubBytes(), message).mul(key2.priv());
  var S3 = r2.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R3, S: S3, Rencoded: Rencoded2 });
};
EDDSA.prototype.verify = function verify6(message, sig, pub2) {
  message = parseBytes$1(message);
  sig = this.makeSignature(sig);
  var key2 = this.keyFromPublic(pub2);
  var h2 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key2.pub().mul(h2));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash3 = this.hash();
  for (var i2 = 0; i2 < arguments.length; i2++)
    hash3.update(arguments[i2]);
  return utils.intFromLE(hash3.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic3(pub2) {
  return KeyPair.fromPublic(this, pub2);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret2) {
  return KeyPair.fromSecret(this, secret2);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};
EDDSA.prototype.encodePoint = function encodePoint(point7) {
  var enc = point7.getY().toArray("le", this.encodingLength);
  enc[this.encodingLength - 1] |= point7.getX().isOdd() ? 128 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint4(bytes) {
  bytes = utils.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
  var xIsOdd = (bytes[lastIx] & 128) !== 0;
  var y2 = utils.intFromLE(normed);
  return this.curve.pointFromY(y2, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};
(function(exports2) {
  var elliptic2 = exports2;
  elliptic2.version = require$$0.version;
  elliptic2.utils = utils$c;
  elliptic2.rand = brorandExports;
  elliptic2.curve = curve;
  elliptic2.curves = curves$2;
  elliptic2.ec = ec;
  elliptic2.eddsa = eddsa;
})(elliptic);
var Prefix;
(function(Prefix2) {
  Prefix2["TZ1"] = "tz1";
  Prefix2["TZ2"] = "tz2";
  Prefix2["TZ3"] = "tz3";
  Prefix2["TZ4"] = "tz4";
  Prefix2["KT"] = "KT";
  Prefix2["KT1"] = "KT1";
  Prefix2["EDSK2"] = "edsk2";
  Prefix2["SPSK"] = "spsk";
  Prefix2["P2SK"] = "p2sk";
  Prefix2["EDPK"] = "edpk";
  Prefix2["SPPK"] = "sppk";
  Prefix2["P2PK"] = "p2pk";
  Prefix2["BLPK"] = "BLpk";
  Prefix2["EDESK"] = "edesk";
  Prefix2["SPESK"] = "spesk";
  Prefix2["P2ESK"] = "p2esk";
  Prefix2["EDSK"] = "edsk";
  Prefix2["EDSIG"] = "edsig";
  Prefix2["SPSIG"] = "spsig";
  Prefix2["P2SIG"] = "p2sig";
  Prefix2["SIG"] = "sig";
  Prefix2["NET"] = "Net";
  Prefix2["NCE"] = "nce";
  Prefix2["B"] = "B";
  Prefix2["O"] = "o";
  Prefix2["LO"] = "Lo";
  Prefix2["LLO"] = "LLo";
  Prefix2["P"] = "P";
  Prefix2["CO"] = "Co";
  Prefix2["ID"] = "id";
  Prefix2["EXPR"] = "expr";
  Prefix2["TZ"] = "TZ";
  Prefix2["VH"] = "vh";
  Prefix2["SASK"] = "sask";
  Prefix2["ZET1"] = "zet1";
  Prefix2["TXR1"] = "txr1";
  Prefix2["TXI"] = "txi";
  Prefix2["TXM"] = "txm";
  Prefix2["TXC"] = "txc";
  Prefix2["TXMR"] = "txmr";
  Prefix2["TXRL"] = "txM";
  Prefix2["TXW"] = "txw";
})(Prefix || (Prefix = {}));
const prefix = {
  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),
  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),
  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),
  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),
  [Prefix.KT]: new Uint8Array([2, 90, 121]),
  [Prefix.KT1]: new Uint8Array([2, 90, 121]),
  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),
  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),
  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),
  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),
  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),
  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),
  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),
  [Prefix.BLPK]: new Uint8Array([6, 149, 135, 204]),
  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),
  [Prefix.SPESK]: new Uint8Array([9, 237, 241, 174, 150]),
  [Prefix.P2ESK]: new Uint8Array([9, 48, 57, 115, 171]),
  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),
  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),
  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),
  [Prefix.SIG]: new Uint8Array([4, 130, 43]),
  [Prefix.NET]: new Uint8Array([87, 82, 0]),
  [Prefix.NCE]: new Uint8Array([69, 220, 169]),
  [Prefix.B]: new Uint8Array([1, 52]),
  [Prefix.O]: new Uint8Array([5, 116]),
  [Prefix.LO]: new Uint8Array([133, 233]),
  [Prefix.LLO]: new Uint8Array([29, 159, 109]),
  [Prefix.P]: new Uint8Array([2, 170]),
  [Prefix.CO]: new Uint8Array([79, 179]),
  [Prefix.ID]: new Uint8Array([153, 103]),
  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),
  // Legacy prefix
  [Prefix.TZ]: new Uint8Array([2, 90, 121]),
  [Prefix.VH]: new Uint8Array([1, 106, 242]),
  [Prefix.SASK]: new Uint8Array([11, 237, 20, 92]),
  [Prefix.ZET1]: new Uint8Array([18, 71, 40, 223]),
  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),
  [Prefix.TXI]: new Uint8Array([79, 148, 196]),
  [Prefix.TXM]: new Uint8Array([79, 149, 30]),
  [Prefix.TXC]: new Uint8Array([79, 148, 17]),
  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),
  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),
  [Prefix.TXW]: new Uint8Array([79, 150, 72])
};
const prefixLength = {
  [Prefix.TZ1]: 20,
  [Prefix.TZ2]: 20,
  [Prefix.TZ3]: 20,
  [Prefix.TZ4]: 20,
  [Prefix.KT]: 20,
  [Prefix.KT1]: 20,
  [Prefix.EDPK]: 32,
  [Prefix.SPPK]: 33,
  [Prefix.P2PK]: 33,
  //working with value in comment for base58.ml line 445 but not consistent with the three above
  [Prefix.BLPK]: 48,
  [Prefix.EDSIG]: 64,
  [Prefix.SPSIG]: 64,
  [Prefix.P2SIG]: 64,
  [Prefix.SIG]: 64,
  [Prefix.NET]: 4,
  [Prefix.B]: 32,
  [Prefix.P]: 32,
  [Prefix.O]: 32,
  [Prefix.VH]: 32,
  [Prefix.SASK]: 169,
  [Prefix.ZET1]: 43,
  [Prefix.TXR1]: 20,
  [Prefix.TXI]: 32,
  [Prefix.TXM]: 32,
  [Prefix.TXC]: 32,
  [Prefix.TXMR]: 32,
  [Prefix.TXRL]: 32,
  [Prefix.TXW]: 32
};
class InvalidPublicKeyError extends Error {
  constructor(publicKey, errorDetail) {
    super();
    this.publicKey = publicKey;
    this.name = "InvalidPublicKeyError";
    const baseMessage = `The public key '${publicKey}' is invalid.`;
    this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
  }
}
class InvalidContractAddressError extends Error {
  constructor(contractAddress) {
    super(`The contract address '${contractAddress}' is invalid`);
    this.contractAddress = contractAddress;
    this.name = "InvalidContractAddressError";
  }
}
class InvalidAddressError extends Error {
  constructor(address, errorDetail) {
    super();
    this.address = address;
    this.name = "InvalidAddressError";
    const baseMessage = `The address '${address}' is invalid.`;
    this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
  }
}
class InvalidChainIdError extends Error {
  constructor(chainId) {
    super(`The chain id '${chainId}' is invalid`);
    this.chainId = chainId;
    this.name = "InvalidChainIdError";
  }
}
class InvalidKeyHashError extends Error {
  constructor(keyHash) {
    super(`The public key hash '${keyHash}' is invalid`);
    this.keyHash = keyHash;
    this.name = "InvalidKeyHashError";
  }
}
class InvalidOperationHashError extends Error {
  constructor(operationHash) {
    super(`The operation hash '${operationHash}' is invalid`);
    this.operationHash = operationHash;
    this.name = "InvalidOperationHashError";
  }
}
class InvalidOperationKindError extends Error {
  constructor(operationKind) {
    super(`The operation kind '${operationKind}' is unsupported`);
    this.operationKind = operationKind;
    this.name = "InvalidOperationKindError";
  }
}
class DeprecationError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "DeprecationError";
  }
}
class ValueConversionError extends Error {
  constructor(value, desiredType) {
    super(`Unable to convert ${value} to a ${desiredType}`);
    this.value = value;
    this.desiredType = desiredType;
    this.name = "ValueConversionError";
  }
}
var ValidationResult;
(function(ValidationResult2) {
  ValidationResult2[ValidationResult2["NO_PREFIX_MATCHED"] = 0] = "NO_PREFIX_MATCHED";
  ValidationResult2[ValidationResult2["INVALID_CHECKSUM"] = 1] = "INVALID_CHECKSUM";
  ValidationResult2[ValidationResult2["INVALID_LENGTH"] = 2] = "INVALID_LENGTH";
  ValidationResult2[ValidationResult2["VALID"] = 3] = "VALID";
})(ValidationResult || (ValidationResult = {}));
function isValidPrefix(value) {
  if (typeof value !== "string") {
    return false;
  }
  return value in prefix;
}
function validatePrefixedValue(value, prefixes) {
  const match = new RegExp(`^(${prefixes.join("|")})`).exec(value);
  if (!match || match.length === 0) {
    return ValidationResult.NO_PREFIX_MATCHED;
  }
  const prefixKey = match[0];
  if (!isValidPrefix(prefixKey)) {
    return ValidationResult.NO_PREFIX_MATCHED;
  }
  const contractAddress = /^(KT1\w{33})(%(.*))?/.exec(value);
  if (contractAddress) {
    value = contractAddress[1];
  }
  let decoded = bs58check.decodeUnsafe(value);
  if (!decoded) {
    return ValidationResult.INVALID_CHECKSUM;
  }
  decoded = decoded.slice(prefix[prefixKey].length);
  if (decoded.length !== prefixLength[prefixKey]) {
    return ValidationResult.INVALID_LENGTH;
  }
  return ValidationResult.VALID;
}
const implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];
const contractPrefix = [Prefix.KT1, Prefix.TXR1];
const signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];
const pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK, Prefix.BLPK];
const operationPrefix = [Prefix.O];
[Prefix.P];
const blockPrefix = [Prefix.B];
function validateAddress(value) {
  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);
}
function validateChain(value) {
  return validatePrefixedValue(value, [Prefix.NET]);
}
function validateContractAddress(value) {
  return validatePrefixedValue(value, contractPrefix);
}
function validateKeyHash(value) {
  return validatePrefixedValue(value, implicitPrefix);
}
function validateSignature(value) {
  return validatePrefixedValue(value, signaturePrefix);
}
function validatePublicKey(value) {
  return validatePrefixedValue(value, pkPrefix);
}
function validateOperation(value) {
  return validatePrefixedValue(value, operationPrefix);
}
function validateBlock(value) {
  return validatePrefixedValue(value, blockPrefix);
}
const TZ_DECIMALS = 6;
const MTZ_DECIMALS = 3;
function getDecimal(format2) {
  switch (format2) {
    case "tz":
      return TZ_DECIMALS;
    case "mtz":
      return MTZ_DECIMALS;
    case "mutez":
    default:
      return 0;
  }
}
function format(from2 = "mutez", to = "mutez", amount) {
  const bigNum = new BigNumber$1(amount);
  if (bigNum.isNaN()) {
    return amount;
  }
  return bigNum.multipliedBy(Math.pow(10, getDecimal(from2))).dividedBy(Math.pow(10, getDecimal(to)));
}
function encodeExpr(value) {
  const blakeHash = blakejs.blake2b(hex2buf(value), void 0, 32);
  return b58cencode(blakeHash, prefix["expr"]);
}
function b58cencode(value, prefix2) {
  const payloadAr = typeof value === "string" ? Uint8Array.from(buffer.Buffer.from(value, "hex")) : value;
  const n = new Uint8Array(prefix2.length + payloadAr.length);
  n.set(prefix2);
  n.set(payloadAr, prefix2.length);
  return bs58check.encode(buffer.Buffer.from(n.buffer));
}
const b58cdecode = (enc, prefixArg) => bs58check.decode(enc).slice(prefixArg.length);
function b58decode(payload) {
  const buf = bs58check.decode(payload);
  const prefixMap = {
    [prefix.tz1.toString()]: "0000",
    [prefix.tz2.toString()]: "0001",
    [prefix.tz3.toString()]: "0002"
  };
  const rollupPrefMap = {
    [prefix.txr1.toString()]: "02"
  };
  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];
  const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()];
  if (pref) {
    const hex = buf2hex(buf.slice(3));
    return pref + hex;
  } else if (rollupPref) {
    const hex = buf2hex(buf.slice(4));
    return rollupPref + hex + "00";
  } else {
    return "01" + buf2hex(buf.slice(3, 42)) + "00";
  }
}
function b58decodeL2Address(payload) {
  const buf = bs58check.decode(payload);
  return buf2hex(buf.slice(3, 42));
}
function encodePubKey(value) {
  if (value.substring(0, 2) === "00") {
    const pref = {
      "0000": prefix.tz1,
      "0001": prefix.tz2,
      "0002": prefix.tz3
    };
    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);
  } else if (value.substring(0, 2) === "02") {
    return b58cencode(value.substring(2, value.length - 2), prefix.txr1);
  }
  return b58cencode(value.substring(2, 42), prefix.KT);
}
function encodeL2Address(value) {
  return b58cencode(value, prefix.tz4);
}
function encodeKey(value) {
  if (value[0] === "0") {
    const pref = {
      "00": new Uint8Array([13, 15, 37, 217]),
      "01": new Uint8Array([3, 254, 226, 86]),
      "02": new Uint8Array([3, 178, 139, 127])
    };
    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
  }
}
function encodeKeyHash(value) {
  if (value[0] === "0") {
    const pref = {
      "00": new Uint8Array([6, 161, 159]),
      "01": new Uint8Array([6, 161, 161]),
      "02": new Uint8Array([6, 161, 164])
    };
    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
  }
}
const hex2buf = (hex) => {
  const match = hex.match(/[\da-f]{2}/gi);
  if (match) {
    return new Uint8Array(match.map((h2) => parseInt(h2, 16)));
  } else {
    throw new ValueConversionError(hex, "Uint8Array");
  }
};
const buf2hex = (buffer2) => {
  const byteArray = new Uint8Array(buffer2);
  const hexParts = [];
  byteArray.forEach((byte) => {
    const hex = byte.toString(16);
    const paddedHex = `00${hex}`.slice(-2);
    hexParts.push(paddedHex);
  });
  return hexParts.join("");
};
function stripHexPrefix(hex) {
  return hex.startsWith("0x") ? hex.slice(2) : hex;
}
function __rest$3(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __awaiter$9(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
const defaultChain = "main";
const defaultRPCOptions = { block: "head" };
var RPCMethodName;
(function(RPCMethodName2) {
  RPCMethodName2["GET_BAKING_RIGHTS"] = "getBakingRights";
  RPCMethodName2["GET_BALLOTS"] = "getBallots";
  RPCMethodName2["GET_BALLOT_LIST"] = "getBallotList";
  RPCMethodName2["GET_BIG_MAP_KEY"] = "getBigMapKey";
  RPCMethodName2["GET_BIG_MAP_EXPR"] = "getBigMapExpr";
  RPCMethodName2["GET_BLOCK_HASH"] = "getBlockHash";
  RPCMethodName2["GET_BLOCK"] = "getBlock";
  RPCMethodName2["GET_BLOCK_HEADER"] = "getBlockHeader";
  RPCMethodName2["GET_BLOCK_METADATA"] = "getBlockMetadata";
  RPCMethodName2["GET_BALANCE"] = "getBalance";
  RPCMethodName2["GET_CHAIN_ID"] = "getChainId";
  RPCMethodName2["GET_CONSTANTS"] = "getConstants";
  RPCMethodName2["GET_CONTRACT"] = "getContract";
  RPCMethodName2["GET_CURRENT_PERIOD"] = "getCurrentPeriod";
  RPCMethodName2["GET_CURRENT_PROPOSAL"] = "getCurrentProposal";
  RPCMethodName2["GET_CURRENT_QUORUM"] = "getCurrentQuorum";
  RPCMethodName2["GET_DELEGATE"] = "getDelegate";
  RPCMethodName2["GET_DELEGATES"] = "getDelegates";
  RPCMethodName2["GET_VOTING_INFO"] = "getVotingInfo";
  RPCMethodName2["GET_ENDORSING_RIGHTS"] = "getEndorsingRights";
  RPCMethodName2["GET_ENTRYPOINTS"] = "getEntrypoints";
  RPCMethodName2["GET_LIVE_BLOCKS"] = "getLiveBlocks";
  RPCMethodName2["GET_MANAGER_KEY"] = "getManagerKey";
  RPCMethodName2["GET_NORMALIZED_SCRIPT"] = "getNormalizedScript";
  RPCMethodName2["GET_PROPOSALS"] = "getProposals";
  RPCMethodName2["GET_PROTOCOLS"] = "getProtocols";
  RPCMethodName2["GET_SAPLING_DIFF_BY_CONTRACT"] = "getSaplingDiffByContract";
  RPCMethodName2["GET_SAPLING_DIFF_BY_ID"] = "getSaplingDiffById";
  RPCMethodName2["GET_SCRIPT"] = "getScript";
  RPCMethodName2["GET_STORAGE"] = "getStorage";
  RPCMethodName2["GET_SUCCESSOR_PERIOD"] = "getSuccessorPeriod";
  RPCMethodName2["GET_TX_ROLLUP_INBOX"] = "getTxRollupInbox";
  RPCMethodName2["GET_TX_ROLLUP_STATE"] = "getTxRollupState";
  RPCMethodName2["GET_VOTES_LISTINGS"] = "getVotesListings";
  RPCMethodName2["PACK_DATA"] = "packData";
  RPCMethodName2["GET_STORAGE_USED_SPACE"] = "getStorageUsedSpace";
  RPCMethodName2["GET_STORAGE_PAID_SPACE"] = "getStoragePaidSpace";
})(RPCMethodName || (RPCMethodName = {}));
function castToBigNumber(data2, keys) {
  const returnArray = Array.isArray(data2);
  if (typeof keys === "undefined") {
    keys = Object.keys(data2);
  }
  const response = returnArray ? [] : {};
  keys.forEach((key2) => {
    const item = data2[key2];
    let res;
    if (typeof item === "undefined") {
      return;
    }
    if (Array.isArray(item)) {
      res = castToBigNumber(item);
      response[key2] = res;
      return;
    }
    res = new BigNumber$1(item);
    response[key2] = res;
  });
  return response;
}
var OPERATION_METADATA;
(function(OPERATION_METADATA2) {
  OPERATION_METADATA2["TOO_LARGE"] = "too large";
})(OPERATION_METADATA || (OPERATION_METADATA = {}));
var METADATA_BALANCE_UPDATES_CATEGORY;
(function(METADATA_BALANCE_UPDATES_CATEGORY2) {
  METADATA_BALANCE_UPDATES_CATEGORY2["BAKING_REWARDS"] = "baking rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["REWARDS"] = "rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["FEES"] = "fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["DEPOSITS"] = "deposits";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_REWARDS"] = "legacy_rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_FEES"] = "legacy_fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_DEPOSITS"] = "legacy_deposits";
  METADATA_BALANCE_UPDATES_CATEGORY2["BLOCK_FEES"] = "block fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["NONCE_REVELATION_REWARDS"] = "nonce revelation rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["DOUBLE_SIGNING_EVIDENCE_REWARDS"] = "double signing evidence rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["ENDORSING_REWARDS"] = "endorsing rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["BAKING_BONUSES"] = "baking bonuses";
  METADATA_BALANCE_UPDATES_CATEGORY2["STORAGE_FEES"] = "storage fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["PUNISHMENTS"] = "punishments";
  METADATA_BALANCE_UPDATES_CATEGORY2["LOST_ENDORSING_REWARDS"] = "lost endorsing rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["SUBSIDY"] = "subsidy";
  METADATA_BALANCE_UPDATES_CATEGORY2["BURNED"] = "burned";
  METADATA_BALANCE_UPDATES_CATEGORY2["COMMITMENT"] = "commitment";
  METADATA_BALANCE_UPDATES_CATEGORY2["BOOTSTRAP"] = "bootstrap";
  METADATA_BALANCE_UPDATES_CATEGORY2["INVOICE"] = "invoice";
  METADATA_BALANCE_UPDATES_CATEGORY2["MINTED"] = "minted";
  METADATA_BALANCE_UPDATES_CATEGORY2["TX_ROLLUP_REJECTION_REWARDS"] = "tx_rollup_rejection_rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["TX_ROLLUP_REJECTION_PUNISHMENTS"] = "tx_rollup_rejection_punishments";
  METADATA_BALANCE_UPDATES_CATEGORY2["BONDS"] = "bonds";
})(METADATA_BALANCE_UPDATES_CATEGORY || (METADATA_BALANCE_UPDATES_CATEGORY = {}));
var OpKind;
(function(OpKind2) {
  OpKind2["ORIGINATION"] = "origination";
  OpKind2["DELEGATION"] = "delegation";
  OpKind2["REVEAL"] = "reveal";
  OpKind2["TRANSACTION"] = "transaction";
  OpKind2["ACTIVATION"] = "activate_account";
  OpKind2["ENDORSEMENT"] = "endorsement";
  OpKind2["PREENDORSEMENT"] = "preendorsement";
  OpKind2["SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
  OpKind2["DOUBLE_PREENDORSEMENT_EVIDENCE"] = "double_preendorsement_evidence";
  OpKind2["ENDORSEMENT_WITH_SLOT"] = "endorsement_with_slot";
  OpKind2["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  OpKind2["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
  OpKind2["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
  OpKind2["PROPOSALS"] = "proposals";
  OpKind2["BALLOT"] = "ballot";
  OpKind2["FAILING_NOOP"] = "failing_noop";
  OpKind2["REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
  OpKind2["TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
  OpKind2["TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
  OpKind2["TX_ROLLUP_COMMIT"] = "tx_rollup_commit";
  OpKind2["TX_ROLLUP_RETURN_BOND"] = "tx_rollup_return_bond";
  OpKind2["TX_ROLLUP_FINALIZE_COMMITMENT"] = "tx_rollup_finalize_commitment";
  OpKind2["TX_ROLLUP_REMOVE_COMMITMENT"] = "tx_rollup_remove_commitment";
  OpKind2["TX_ROLLUP_REJECTION"] = "tx_rollup_rejection";
  OpKind2["TX_ROLLUP_DISPATCH_TICKETS"] = "tx_rollup_dispatch_tickets";
  OpKind2["TRANSFER_TICKET"] = "transfer_ticket";
  OpKind2["INCREASE_PAID_STORAGE"] = "increase_paid_storage";
  OpKind2["UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
  OpKind2["DRAIN_DELEGATE"] = "drain_delegate";
  OpKind2["VDF_REVELATION"] = "vdf_revelation";
  OpKind2["EVENT"] = "event";
  OpKind2["TICKET_UPDATES"] = "ticket_updates";
})(OpKind || (OpKind = {}));
class RpcClient {
  /**
   *
   * @param url rpc root url
   * @param chain chain (default main)
   * @param httpBackend Http backend that issue http request.
   * You can override it by providing your own if you which to hook in the request/response
   *
   * @example new RpcClient('https://mainnet.api.tez.ie/', 'main') this will use https://mainnet.api.tez.ie//chains/main
   */
  constructor(url, chain = defaultChain, httpBackend = new HttpBackend()) {
    this.url = url;
    this.chain = chain;
    this.httpBackend = httpBackend;
  }
  createURL(path) {
    return `${this.url.replace(/\/+$/g, "")}${path}`;
  }
  validateAddress(address) {
    if (validateAddress(address) !== ValidationResult.VALID) {
      throw new InvalidAddressError(address);
    }
  }
  validateContract(address) {
    if (validateContractAddress(address) !== ValidationResult.VALID) {
      throw new InvalidAddressError(address);
    }
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Get the block's hash, its unique identifier.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
   */
  getBlockHash({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const hash3 = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/hash`),
        method: "GET"
      });
      return hash3;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
   */
  getLiveBlocks({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const blocks = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/live_blocks`),
        method: "GET"
      });
      return blocks;
    });
  }
  /**
   *
   * @param address address from which we want to retrieve the balance
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the balance of a contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
   */
  getBalance(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      const balance = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/balance`),
        method: "GET"
      });
      return new BigNumber$1(balance);
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the storage
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the data of the contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
   */
  getStorage(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateContract(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/storage`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the script
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the code and data of the contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
   */
  getScript(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateContract(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the script
   * @param unparsingMode default is { unparsing_mode: "Readable" }
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the script of the contract and normalize it using the requested unparsing mode.
   *
   */
  getNormalizedScript(address, unparsingMode = { unparsing_mode: "Readable" }, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateContract(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script/normalized`),
        method: "POST"
      }, unparsingMode);
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the complete status of a contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
   */
  getContract(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      const contractResponse = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}`),
        method: "GET"
      });
      return Object.assign(Object.assign({}, contractResponse), { balance: new BigNumber$1(contractResponse.balance) });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the manager
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the manager key of a contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
   */
  getManagerKey(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/manager_key`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the delegate (baker)
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the delegate of a contract, if any.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
   */
  getDelegate(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      let delegate;
      try {
        delegate = yield this.httpBackend.createRequest({
          url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/delegate`),
          method: "GET"
        });
      } catch (ex) {
        if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {
          delegate = null;
        } else {
          throw ex;
        }
      }
      return delegate;
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the big map key
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a key in the big map storage of the contract.
   *
   * @deprecated Deprecated in favor of getBigMapKeyByID
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
   */
  getBigMapKey(address, key2, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/big_map_get`),
        method: "POST"
      }, key2);
    });
  }
  /**
   *
   * @param id Big Map ID
   * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a key in a big map.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
   */
  getBigMapExpr(id2, expr, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/big_maps/${id2}/${expr}`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address delegate address which we want to retrieve
   * @param options contains generic configuration for rpc calls
   *
   * @description Fetches information about a delegate from RPC.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
   */
  getDelegates(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}`),
        method: "GET"
      });
      const castedResponse = castToBigNumber(response, [
        "balance",
        "full_balance",
        "current_frozen_deposits",
        "frozen_deposits",
        "frozen_balance",
        "frozen_deposits_limit",
        "staking_balance",
        "delegated_balance",
        "voting_power"
      ]);
      return Object.assign(Object.assign(Object.assign({}, response), castedResponse), { frozen_balance_by_cycle: response.frozen_balance_by_cycle ? response.frozen_balance_by_cycle.map((_a2) => {
        var { deposit, deposits, fees, rewards } = _a2, rest = __rest$3(_a2, ["deposit", "deposits", "fees", "rewards"]);
        const castedToBigNumber = castToBigNumber({ deposit, deposits, fees, rewards }, [
          "deposit",
          "deposits",
          "fees",
          "rewards"
        ]);
        return Object.assign(Object.assign({}, rest), { deposit: castedToBigNumber.deposit, deposits: castedToBigNumber.deposits, fees: castedToBigNumber.fees, rewards: castedToBigNumber.rewards });
      }) : void 0 });
    });
  }
  /**
   *
   * @param address delegate address which we want to retrieve
   * @param options contains generic configuration for rpc calls
   *
   * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period.
   *
   * @see https://tezos.gitlab.io/kathmandu/rpc.html#get-block-id-context-delegates-pkh-voting-info
   */
  getVotingInfo(address, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateAddress(address);
      return yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}/voting_info`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description All constants
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
   */
  getConstants({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/constants`),
        method: "GET"
      });
      const castedResponse = castToBigNumber(response, [
        "time_between_blocks",
        "hard_gas_limit_per_operation",
        "hard_gas_limit_per_block",
        "proof_of_work_threshold",
        "tokens_per_roll",
        "seed_nonce_revelation_tip",
        "block_security_deposit",
        "endorsement_security_deposit",
        "block_reward",
        "endorsement_reward",
        "cost_per_byte",
        "hard_storage_limit_per_operation",
        "test_chain_duration",
        "baking_reward_per_endorsement",
        "delay_per_missing_endorsement",
        "minimal_block_delay",
        "liquidity_baking_subsidy",
        "cache_layout",
        "baking_reward_fixed_portion",
        "baking_reward_bonus_per_slot",
        "endorsing_reward_per_slot",
        "double_baking_punishment",
        "delay_increment_per_round",
        "tx_rollup_commitment_bond",
        "vdf_difficulty",
        "sc_rollup_stake_amount",
        "minimal_stake"
      ]);
      return Object.assign(Object.assign({}, response), castedResponse);
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.
   *
   * @description All the information about a block
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
   * @example getBlock() will default to /main/chains/block/head.
   * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.
   * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..
   */
  getBlock({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description The whole block header
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
   */
  getBlockHeader({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/header`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description All the metadata associated to the block
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
   */
  getBlockMetadata({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/metadata`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param args contains optional query arguments
   * @param options contains generic configuration for rpc calls
   *
   * @description Retrieves the list of delegates allowed to bake a block.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
   */
  getBakingRights(args = {}, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/baking_rights`),
        method: "GET",
        query: args
      });
      return response;
    });
  }
  /**
   *
   * @param args contains optional query arguments
   * @param options contains generic configuration for rpc calls
   *
   * @description Retrieves the list of delegates allowed to bake a block.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
   */
  getEndorsingRights(args = {}, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/endorsing_rights`),
        method: "GET",
        query: args
      });
      return response;
    });
  }
  /**
   * @param options contains generic configuration for rpc calls
   *
   * @description Ballots casted so far during a voting period
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
   */
  getBallotList({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballot_list`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Sum of ballots casted so far during a voting period.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
   */
  getBallots({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballots`),
        method: "GET"
      });
      const casted = castToBigNumber(response, ["yay", "nay", "pass"]);
      return casted;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Current proposal under evaluation.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
   */
  getCurrentProposal({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_proposal`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Current expected quorum.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
   */
  getCurrentQuorum({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_quorum`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description List of delegates with their voting weight, in number of rolls.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
   */
  getVotesListings({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/listings`),
        method: "GET"
      });
      response.map((item) => {
        if (item.voting_power) {
          item.voting_power = new BigNumber$1(item.voting_power);
        }
        return item;
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description List of proposals with number of supporters.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
   */
  getProposals({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/proposals`),
        method: "GET"
      });
      response.map((item) => {
        return item[1] = new BigNumber$1(item[1]);
      });
      return response;
    });
  }
  /**
   *
   * @param data operation contents to forge
   * @param options contains generic configuration for rpc calls
   *
   * @description Forge an operation returning the unsigned bytes
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
   */
  forgeOperations(data2, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/forge/operations`),
        method: "POST"
      }, data2);
    });
  }
  /**
   *
   * @param signedOpBytes signed bytes to inject
   *
   * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
   */
  injectOperation(signedOpBytes) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/injection/operation`),
        method: "POST"
      }, signedOpBytes);
    });
  }
  /**
   *
   * @param ops Operations to apply
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate the validation of an operation
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
   */
  preapplyOperations(ops, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/preapply/operations`),
        method: "POST"
      }, ops);
      return response;
    });
  }
  /**
   *
   * @param contract address of the contract we want to get the entrypoints of
   *
   * @description Return the list of entrypoints of the contract
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
   *
   * @version 005_PsBABY5H
   */
  getEntrypoints(contract, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.validateContract(contract);
      const contractResponse = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/entrypoints`),
        method: "GET"
      });
      return contractResponse;
    });
  }
  /**
   * @param op Operation to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Run an operation without signature checks
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
   */
  runOperation(op, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_operation`),
        method: "POST"
      }, op);
      return response;
    });
  }
  /**
   * @param code Code to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Run a piece of code in the current context
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
   */
  runCode(code2, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_code`),
        method: "POST"
      }, code2);
      return response;
    });
  }
  /**
   * @param viewScriptParams Parameters of the script view to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate a call to a michelson view
   *
   */
  runScriptView(_a2, { block } = defaultRPCOptions) {
    var { unparsing_mode = "Readable" } = _a2, rest = __rest$3(_a2, ["unparsing_mode"]);
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_script_view`),
        method: "POST"
      }, Object.assign({ unparsing_mode }, rest));
    });
  }
  /**
   * @param viewParams Parameters of the view to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
   *
   */
  runView(_a2, { block } = defaultRPCOptions) {
    var { unparsing_mode = "Readable" } = _a2, rest = __rest$3(_a2, ["unparsing_mode"]);
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_view`),
        method: "POST"
      }, Object.assign({ unparsing_mode }, rest));
    });
  }
  getChainId() {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/chain_id`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param data Data to pack
   * @param options contains generic configuration for rpc calls
   *
   * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
   * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.
   * This precaution helps protect you and your applications users from RPC nodes that have been compromised.
   * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.
   * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.
   *
   * @example packData({ data: { string: "test" }, type: { prim: "string" } })
   *
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
   */
  packData(data2, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const _a2 = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/pack_data`),
        method: "POST"
      }, data2), { gas } = _a2, rest = __rest$3(_a2, ["gas"]);
      let formattedGas = gas;
      const tryBigNumber = new BigNumber$1(gas || "");
      if (!tryBigNumber.isNaN()) {
        formattedGas = tryBigNumber;
      }
      return Object.assign({ gas: formattedGas }, rest);
    });
  }
  /**
   *
   * @description Return rpc root url
   */
  getRpcUrl() {
    return this.url;
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Voting period of current block.
   *
   * @example getCurrentPeriod() will default to current voting period for /main/chains/block/head.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
   */
  getCurrentPeriod({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_period`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Voting period of next block.
   *
   * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
   */
  getSuccessorPeriod({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/successor_period`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param id Sapling state ID
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a sapling state ID.
   *
   * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
   */
  getSaplingDiffById(id2, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/sapling/${id2}/get_diff`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract address of the contract we want to get the sapling diff
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a sapling state.
   *
   * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
   */
  getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/single_sapling_get_diff`),
        method: "GET"
      });
    });
  }
  getProtocols({ block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/protocols`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param tx_rollup_id the transaction rollup ID
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the state of a rollup
   *
   * @see https://tezos.gitlab.io/jakarta/rpc.html#get-block-id-context-tx-rollup-tx-rollup-id-state
   */
  getTxRollupState(txRollupId, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/tx_rollup/${txRollupId}/state`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param tx_rollup_id the transaction rollup ID
   * @param block_level the block level
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the inbox of a transaction rollup
   *
   * @see https://tezos.gitlab.io/jakarta/rpc.html#get-block-id-context-tx-rollup-tx-rollup-id-inbox-block-level
   */
  getTxRollupInbox(txRollupId, blockLevel, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/tx_rollup/${txRollupId}/inbox/${blockLevel}`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract address of the contract we want to retrieve storage information of
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the amount of used space in a contract's storage
   *
   * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
   */
  getStorageUsedSpace(contract, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/used_space`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract address of the contract we want to retrieve storage information of
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the amount of paid space in a contract's storage
   *
   * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
   */
  getStoragePaidSpace(contract, { block } = defaultRPCOptions) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/paid_space`),
        method: "GET"
      });
    });
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function isFunction$1(x2) {
  return typeof x2 === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = /* @__PURE__ */ new Error();
      /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$1 = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};
var isArray = /* @__PURE__ */ function() {
  return Array.isArray || function(x2) {
    return x2 && typeof x2.length === "number";
  };
}();
function isObject(x2) {
  return x2 !== null && typeof x2 === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors;
    if (this.closed) {
      return;
    }
    var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }
    if (isFunction$1(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }
    if (isArray(_subscriptions)) {
      var index = -1;
      var len2 = _subscriptions.length;
      while (++index < len2) {
        var sub = _subscriptions[index];
        if (isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];
            if (e instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }
    if (errors) {
      throw new UnsubscriptionError(errors);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$1;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$1;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;
    if (isFunction$1(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$1) {
        context = Object.create(observerOrNext);
        if (isFunction$1(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty$1);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe) {
    this._isScalar = false;
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len2 = observers.length;
      var copy = observers.slice();
      for (var i2 = 0; i2 < len2; i2++) {
        copy[i2].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len2 = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len2; i2++) {
      copy[i2].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len2 = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len2; i2++) {
      copy[i2].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && this.delay === delay && this.pending === false) {
      return id2;
    }
    clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, delay) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state2);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id2 = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay > 0) {
      return _super.prototype.schedule.call(this, state2, delay);
    }
    this.delay = delay;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay) {
    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay) : this._execute(state2, delay);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay, state2) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state2, delay);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay, state2) {
    if (delay === void 0) {
      delay = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay, state2);
    } else {
      return _super.prototype.schedule.call(this, work, delay, state2);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue = queueScheduler;
var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i2 = 0, len2 = array.length; i2 < len2 && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  };
};
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i2 = 0;
    sub.add(scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i2++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch$2, 0, { error, subscriber });
    });
  }
}
function dispatch$2(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler;
    _this.delay = delay;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
var ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime === void 0) {
      windowTime = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime < 1 ? 1 : windowTime;
    if (windowTime === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var len2 = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (var i2 = 0; i2 < len2 && !subscriber.closed; i2++) {
        subscriber.next(_events[i2]);
      }
    } else {
      for (var i2 = 0; i2 < len2 && !subscriber.closed; i2++) {
        subscriber.next(_events[i2].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value) {
    this.time = time;
    this.value = value;
  }
  return ReplayEvent2;
}();
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
function noop() {
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$1 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$1.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$1.return === "function") {
      subscriber.add(function() {
        if (iterator$1.return) {
          iterator$1.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len2 = observables.length;
    if (len2 === 0) {
      this.destination.complete();
    } else {
      this.active = len2;
      this.toRespond = len2;
      for (var i2 = 0; i2 < len2; i2++) {
        var observable2 = observables[i2];
        this.add(subscribeToResult(this, observable2, void 0, i2));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator$1;
    sub.add(function() {
      if (iterator$1 && typeof iterator$1.return === "function") {
        iterator$1.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator$1 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done2;
        try {
          var result = iterator$1.next();
          value = result.value;
          done2 = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a2, i2) {
        return from(project(a2, i2)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty();
    return source.subscribe(subscriber);
  });
}
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
var NEVER = /* @__PURE__ */ new Observable(noop);
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
function range(start2, count, scheduler) {
  if (start2 === void 0) {
    start2 = 0;
  }
  return new Observable(function(subscriber) {
    if (count === void 0) {
      count = start2;
      start2 = 0;
    }
    var index = 0;
    var current = start2;
    if (scheduler) {
      return scheduler.schedule(dispatch$1, 0, {
        index,
        count,
        start: start2,
        subscriber
      });
    } else {
      do {
        if (index++ >= count) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch$1(state2) {
  var start2 = state2.start, index = state2.index, count = state2.count, subscriber = state2.subscriber;
  if (index >= count) {
    subscriber.complete();
    return;
  }
  subscriber.next(start2);
  if (subscriber.closed) {
    return;
  }
  state2.index = index + 1;
  state2.start = start2 + 1;
  this.schedule(state2);
}
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state2) {
  var index = state2.index, period = state2.period, subscriber = state2.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state2.index = index + 1;
  this.schedule(state2, period);
}
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = false;
    this.destination.next(value);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function distinctUntilChanged(compare, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare === "function") {
      _this.compare = compare;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x2, y2) {
    return x2 === y2;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key2;
    try {
      var keySelector = this.keySelector;
      key2 = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare = this.compare;
        result = compare(this.key, key2);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key2;
      this.destination.next(value);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key2, compare) {
  return distinctUntilChanged(function(x2, y2) {
    return compare ? compare(x2[key2], y2[key2]) : x2[key2] === y2[key2];
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = true;
    this.destination.next(value);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e) {
        err = e;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count) {
  return function(source) {
    if (count === 0) {
      return empty();
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count = ++this.count;
    if (count <= total) {
      this.destination.next(value);
      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function endWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, array));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v2, i2) {
      return predicate(v2, i2, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x2) {
    var currentProp = x2;
    for (var i2 = 0; i2 < length; i2++) {
      var p2 = currentProp != null ? currentProp[props[i2]] : void 0;
      if (p2 !== void 0) {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
function retry(count) {
  if (count === void 0) {
    count = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count, source));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count, source) {
    this.count = count;
    this.source = source;
  }
  RetryOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count;
    _this.source = source;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count = _a2.count;
      if (count === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count > -1) {
        this.count = count - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function startWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  var scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return function(source) {
      return concat(array, source, scheduler);
    };
  } else {
    return function(source) {
      return concat(array, source);
    };
  }
}
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a2, i2) {
        return from(project(a2, i2)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value) {
    var result;
    var index = this.index++;
    try {
      result = this.project(value, index);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop;
    _this._tapError = noop;
    _this._tapComplete = noop;
    _this._tapError = error || noop;
    _this._tapComplete = complete || noop;
    if (isFunction$1(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop;
      _this._tapError = observerOrNext.error || noop;
      _this._tapComplete = observerOrNext.complete || noop;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
var fastJsonStableStringify = function(data2, opts) {
  if (!opts)
    opts = {};
  if (typeof opts === "function")
    opts = { cmp: opts };
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var cmp = opts.cmp && function(f2) {
    return function(node2) {
      return function(a2, b2) {
        var aobj = { key: a2, value: node2[a2] };
        var bobj = { key: b2, value: node2[b2] };
        return f2(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen2 = [];
  return function stringify(node2) {
    if (node2 && node2.toJSON && typeof node2.toJSON === "function") {
      node2 = node2.toJSON();
    }
    if (node2 === void 0)
      return;
    if (typeof node2 == "number")
      return isFinite(node2) ? "" + node2 : "null";
    if (typeof node2 !== "object")
      return JSON.stringify(node2);
    var i2, out;
    if (Array.isArray(node2)) {
      out = "[";
      for (i2 = 0; i2 < node2.length; i2++) {
        if (i2)
          out += ",";
        out += stringify(node2[i2]) || "null";
      }
      return out + "]";
    }
    if (node2 === null)
      return "null";
    if (seen2.indexOf(node2) !== -1) {
      if (cycles)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    var seenIndex = seen2.push(node2) - 1;
    var keys = Object.keys(node2).sort(cmp && cmp(node2));
    out = "";
    for (i2 = 0; i2 < keys.length; i2++) {
      var key2 = keys[i2];
      var value = stringify(node2[key2]);
      if (!value)
        continue;
      if (out)
        out += ",";
      out += JSON.stringify(key2) + ":" + value;
    }
    seen2.splice(seenIndex, 1);
    return "{" + out + "}";
  }(data2);
};
var _a$1;
class InvalidMapTypeError extends Error {
  constructor(mapType) {
    super(`The map type '${mapType}' is invalid`);
    this.mapType = mapType;
    this.name = "InvalidMapTypeError";
  }
}
const michelsonMapTypeSymbol = Symbol.for("taquito-michelson-map-type-symbol");
const isMapType = (value) => {
  return "args" in value && Array.isArray(value.args) && value.args.length === 2;
};
class MapTypecheckError extends Error {
  constructor(value, type, errorType) {
    super(`${errorType} not compliant with underlying michelson type`);
    this.value = value;
    this.type = type;
    this.name = "MapTypecheckError";
  }
}
class MichelsonMap {
  /**
   * @param mapType If specified key and value will be type-checked before being added to the map
   *
   * @example new MichelsonMap({ prim: "map", args: [{prim: "string"}, {prim: "int"}]})
   */
  constructor(mapType) {
    this.valueMap = /* @__PURE__ */ new Map();
    this.keyMap = /* @__PURE__ */ new Map();
    this[_a$1] = true;
    if (mapType) {
      this.setType(mapType);
    }
  }
  // Used to check if an object is a michelson map.
  // Using instanceof was not working for project that had multiple instance of taquito dependencies
  // as the class constructor is different
  static isMichelsonMap(obj) {
    return obj && obj[michelsonMapTypeSymbol] === true;
  }
  setType(mapType) {
    if (!isMapType(mapType)) {
      throw new InvalidMapTypeError(mapType.toString());
    }
    this.keySchema = new Schema(mapType.args[0]);
    this.valueSchema = new Schema(mapType.args[1]);
  }
  removeType() {
    this.keySchema = void 0;
    this.valueSchema = void 0;
  }
  static fromLiteral(obj, mapType) {
    const map2 = new MichelsonMap(mapType);
    Object.keys(obj).forEach((key2) => {
      map2.set(key2, obj[key2]);
    });
    return map2;
  }
  typecheckKey(key2) {
    if (this.keySchema) {
      return this.keySchema.Typecheck(key2);
    }
    return true;
  }
  typecheckValue(value) {
    if (this.valueSchema) {
      return this.valueSchema.Typecheck(value);
    }
    return true;
  }
  assertTypecheckValue(value) {
    if (!this.typecheckValue(value)) {
      throw new MapTypecheckError(value, this.valueSchema, "value");
    }
  }
  assertTypecheckKey(key2) {
    if (!this.typecheckKey(key2)) {
      throw new MapTypecheckError(key2, this.keySchema, "key");
    }
  }
  serializeDeterministically(key2) {
    return fastJsonStableStringify(key2);
  }
  *keys() {
    for (const [key2] of this.entries()) {
      yield key2;
    }
  }
  *values() {
    for (const [, value] of this.entries()) {
      yield value;
    }
  }
  *entries() {
    for (const key2 of this.valueMap.keys()) {
      yield [this.keyMap.get(key2), this.valueMap.get(key2)];
    }
  }
  get(key2) {
    this.assertTypecheckKey(key2);
    const strKey = this.serializeDeterministically(key2);
    return this.valueMap.get(strKey);
  }
  /**
   *
   * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.
   *
   * @example map.set("myKey", "myValue") // Using a string as key
   *
   * @example map.set({0: "test", 1: "test1"}, "myValue") // Using a pair as key
   *
   * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.
   *
   * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, "myValue") and map.set(null, "myValue").
   *
   * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.
   */
  set(key2, value) {
    this.assertTypecheckKey(key2);
    this.assertTypecheckValue(value);
    const strKey = this.serializeDeterministically(key2);
    this.keyMap.set(strKey, key2);
    this.valueMap.set(strKey, value);
  }
  delete(key2) {
    this.assertTypecheckKey(key2);
    this.keyMap.delete(this.serializeDeterministically(key2));
    this.valueMap.delete(this.serializeDeterministically(key2));
  }
  has(key2) {
    this.assertTypecheckKey(key2);
    const strKey = this.serializeDeterministically(key2);
    return this.keyMap.has(strKey) && this.valueMap.has(strKey);
  }
  clear() {
    this.keyMap.clear();
    this.valueMap.clear();
  }
  get size() {
    return this.keyMap.size;
  }
  forEach(cb) {
    for (const [key2, value] of this.entries()) {
      cb(value, key2, this);
    }
  }
}
_a$1 = michelsonMapTypeSymbol;
class TokenValidationError extends Error {
  constructor(value, token, baseMessage) {
    super();
    this.value = value;
    this.token = token;
    this.name = "ValidationError";
    const annot = this.token.annot();
    const annotText = annot ? `[${annot}] ` : "";
    this.message = `${annotText}${baseMessage}`;
  }
}
class Token {
  constructor(val, idx, fac) {
    this.val = val;
    this.idx = idx;
    this.fac = fac;
    this.createToken = this.fac;
  }
  typeWithoutAnnotations() {
    const handleMichelsonExpression = (val) => {
      if (typeof val === "object") {
        if (Array.isArray(val)) {
          const array = val;
          return array.map((item) => handleMichelsonExpression(item));
        }
        const extended = val;
        if (extended.args) {
          return {
            prim: extended.prim,
            args: extended.args.map((x2) => handleMichelsonExpression(x2))
          };
        } else {
          return {
            prim: extended.prim
          };
        }
      }
      return val;
    };
    const handleMichelsonExtended = (val) => {
      if (val.args) {
        return {
          prim: val.prim,
          args: val.args.map((x2) => handleMichelsonExpression(x2))
        };
      } else {
        return {
          prim: val.prim
        };
      }
    };
    return handleMichelsonExtended(this.val);
  }
  annot() {
    return (Array.isArray(this.val.annots) && this.val.annots.length > 0 ? this.val.annots[0] : String(this.idx)).replace(/(%|:)(_Liq_entry_)?/, "");
  }
  hasAnnotations() {
    return Array.isArray(this.val.annots) && this.val.annots.length;
  }
  get tokenVal() {
    return this.val;
  }
  ExtractSignature() {
    return [[this.ExtractSchema()]];
  }
}
class ComparableToken extends Token {
  compare(o1, o2) {
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
}
class BigMapValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "BigMapValidationError";
  }
}
class BigMapToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get ValueSchema() {
    return this.createToken(this.val.args[1], 0);
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      big_map: {
        key: this.KeySchema.ExtractSchema(),
        value: this.ValueSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: BigMapToken.prim,
      schema: {
        key: this.KeySchema.generateSchema(),
        value: this.ValueSchema.generateSchema()
      }
    };
  }
  isValid(value) {
    if (MichelsonMap.isMichelsonMap(value)) {
      return null;
    }
    return new BigMapValidationError(value, this, "Value must be a MichelsonMap");
  }
  objLitToMichelsonMap(val) {
    if (val instanceof MichelsonMap)
      return val;
    if (typeof val === "object") {
      if (Object.keys(val).length === 0) {
        return new MichelsonMap();
      } else {
        return MichelsonMap.fromLiteral(val);
      }
    }
    return val;
  }
  Encode(args) {
    const val = this.objLitToMichelsonMap(args.pop());
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return Array.from(val.keys()).sort((a2, b2) => this.KeySchema.compare(a2, b2)).map((key2) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key2), this.ValueSchema.EncodeObject(val.get(key2))]
      };
    });
  }
  EncodeObject(args, semantic) {
    const val = this.objLitToMichelsonMap(args);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[BigMapToken.prim]) {
      return semantic[BigMapToken.prim](val, this.val);
    }
    return Array.from(val.keys()).sort((a2, b2) => this.KeySchema.compare(a2, b2)).map((key2) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key2), this.ValueSchema.EncodeObject(val.get(key2))]
      };
    });
  }
  Execute(val, semantic) {
    if (semantic && semantic[BigMapToken.prim]) {
      return semantic[BigMapToken.prim](val, this.val);
    }
    if (Array.isArray(val)) {
      const map2 = new MichelsonMap(this.val);
      val.forEach((current) => {
        map2.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));
      });
      return map2;
    } else if ("int" in val) {
      return val.int;
    } else {
      throw new BigMapValidationError(val, this, `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(val)}`);
    }
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (BigMapToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
BigMapToken.prim = "big_map";
class OrTokenDecodingError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "OrTokenDecodingError";
  }
}
class OrToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    const label = args[args.length - 1];
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {
      args.pop();
      return { prim: "Left", args: [leftToken.Encode(args)] };
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {
      args.pop();
      return { prim: "Right", args: [rightToken.Encode(args)] };
    } else {
      if (leftToken instanceof OrToken) {
        const val = leftToken.Encode(args);
        if (val) {
          return { prim: "Left", args: [val] };
        }
      }
      if (rightToken instanceof OrToken) {
        const val = rightToken.Encode(args);
        if (val) {
          return { prim: "Right", args: [val] };
        }
      }
      return null;
    }
  }
  ExtractSignature() {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    const newSig = [];
    if (leftToken instanceof OrToken) {
      newSig.push(...leftToken.ExtractSignature());
    } else {
      for (const sig of leftToken.ExtractSignature()) {
        newSig.push([leftToken.annot(), ...sig]);
      }
    }
    if (rightToken instanceof OrToken) {
      newSig.push(...rightToken.ExtractSignature());
    } else {
      for (const sig of rightToken.ExtractSignature()) {
        newSig.push([rightToken.annot(), ...sig]);
      }
    }
    return newSig;
  }
  EncodeObject(args, semantic) {
    const label = Object.keys(args)[0];
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {
      return { prim: "Left", args: [leftToken.EncodeObject(args[label], semantic)] };
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {
      return { prim: "Right", args: [rightToken.EncodeObject(args[label], semantic)] };
    } else {
      if (leftToken instanceof OrToken) {
        const val = leftToken.EncodeObject(args, semantic);
        if (val) {
          return { prim: "Left", args: [val] };
        }
      }
      if (rightToken instanceof OrToken) {
        const val = rightToken.EncodeObject(args, semantic);
        if (val) {
          return { prim: "Right", args: [val] };
        }
      }
      return null;
    }
  }
  Execute(val, semantics) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (val.prim === "Right") {
      if (rightToken instanceof OrToken) {
        return rightToken.Execute(val.args[0], semantics);
      } else {
        return {
          [rightToken.annot()]: rightToken.Execute(val.args[0], semantics)
        };
      }
    } else if (val.prim === "Left") {
      if (leftToken instanceof OrToken) {
        return leftToken.Execute(val.args[0], semantics);
      }
      return {
        [leftToken.annot()]: leftToken.Execute(val.args[0], semantics)
      };
    } else {
      throw new OrTokenDecodingError(`Was expecting Left or Right prim but got: ${val.prim}`);
    }
  }
  traversal(getLeftValue, getRightValue, concat2) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    let leftValue;
    if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {
      leftValue = getLeftValue(leftToken);
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    } else {
      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    let rightValue;
    if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {
      rightValue = getRightValue(rightToken);
    } else {
      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
    }
    const res = concat2(leftValue, rightValue);
    return res;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema(), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));
  }
  generateSchema() {
    return {
      __michelsonType: OrToken.prim,
      schema: this.traversal((leftToken) => {
        if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {
          return leftToken.generateSchema().schema;
        } else {
          return leftToken.generateSchema();
        }
      }, (rightToken) => {
        if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {
          return rightToken.generateSchema().schema;
        } else {
          return rightToken.generateSchema();
        }
      }, (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue))
    };
  }
  findToken(label) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken) && leftToken instanceof ComparableToken) {
      return leftToken;
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken) && rightToken instanceof ComparableToken) {
      return rightToken;
    } else {
      if (leftToken instanceof OrToken) {
        const tok = leftToken.findToken(label);
        if (tok) {
          return tok;
        }
      }
      if (rightToken instanceof OrToken) {
        const tok = rightToken.findToken(label);
        if (tok) {
          return tok;
        }
      }
      return null;
    }
  }
  compare(val1, val2) {
    const labelVal1 = Object.keys(val1)[0];
    const labelVal2 = Object.keys(val2)[0];
    if (labelVal1 === labelVal2) {
      const token = this.findToken(labelVal1);
      if (token instanceof ComparableToken) {
        return token.compare(val1[labelVal1], val2[labelVal1]);
      }
    } else {
      const encoded1 = JSON.stringify(this.EncodeObject(val1));
      const encoded2 = JSON.stringify(this.EncodeObject(val2));
      return encoded1 < encoded2 ? -1 : 1;
    }
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (OrToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.traversal((leftToken) => leftToken.findAndReturnTokens(tokenToFind, tokens2), (rightToken) => rightToken.findAndReturnTokens(tokenToFind, tokens2), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));
    return tokens2;
  }
}
OrToken.prim = "or";
class TokenArgumentValidationError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "TokenArgumentValidationError";
  }
}
class TokenComparisonError extends Error {
  constructor(val1, val2) {
    super(`Tokens ${val1} and ${val2} are not comparable`);
    this.val1 = val1;
    this.val2 = val2;
    this.name = "TokenComparisonError";
  }
}
function collapse$1(val, prim = PairToken.prim) {
  if (Array.isArray(val)) {
    return collapse$1({
      prim,
      args: val
    }, prim);
  }
  if (val.args === void 0) {
    throw new TokenArgumentValidationError("Encountered an invalid PairToken with no arguments, a pair must have two or more arguments");
  }
  if (val.args.length > 2) {
    return [
      val.args[0],
      {
        prim,
        args: val.args.slice(1)
      }
    ];
  }
  return [val.args[0], val.args[1]];
}
class PairToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(Array.isArray(val) ? {
      prim: PairToken.prim,
      args: val
    } : val.prim ? val : {
      prim: PairToken.prim,
      args: val
    }, idx, fac);
  }
  args() {
    return collapse$1(this.val);
  }
  tokens() {
    let cnt = 0;
    return this.args().map((a2) => {
      const tok = this.createToken(a2, this.idx + cnt);
      if (tok instanceof PairToken) {
        cnt += Object.keys(tok.ExtractSchema()).length;
      } else {
        cnt++;
      }
      return tok;
    });
  }
  Encode(args) {
    return {
      prim: "Pair",
      args: this.tokens().map((t) => t.Encode(args))
    };
  }
  ExtractSignature() {
    const args = this.args();
    const leftToken = this.createToken(args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(args[1], this.idx + keyCount);
    const newSig = [];
    for (const leftSig of leftToken.ExtractSignature()) {
      for (const rightSig of rightToken.ExtractSignature()) {
        newSig.push([...leftSig, ...rightSig]);
      }
    }
    return newSig;
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  EncodeObject(args, semantic) {
    const [leftToken, rightToken] = this.tokens();
    let leftValue;
    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
      leftValue = args;
    } else {
      leftValue = args[leftToken.annot()];
    }
    let rightValue;
    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
      rightValue = args;
    } else {
      rightValue = args[rightToken.annot()];
    }
    return {
      prim: "Pair",
      args: [
        leftToken.EncodeObject(leftValue, semantic),
        rightToken.EncodeObject(rightValue, semantic)
      ]
    };
  }
  traversal(getLeftValue, getRightValue) {
    const args = this.args();
    const leftToken = this.createToken(args[0], this.idx);
    let keyCount = 1;
    let leftValue;
    if (leftToken instanceof PairToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
      leftValue = getLeftValue(leftToken);
    } else {
      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
    }
    const rightToken = this.createToken(args[1], this.idx + keyCount);
    let rightValue;
    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
      rightValue = getRightValue(rightToken);
    } else {
      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
    }
    const res = Object.assign(Object.assign({}, leftValue), rightValue);
    return res;
  }
  Execute(val, semantics) {
    const args = collapse$1(val, "Pair");
    return this.traversal((leftToken) => leftToken.Execute(args[0], semantics), (rightToken) => rightToken.Execute(args[1], semantics));
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema());
  }
  generateSchema() {
    return {
      __michelsonType: PairToken.prim,
      schema: this.traversal((leftToken) => {
        if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
          return leftToken.generateSchema().schema;
        } else {
          return leftToken.generateSchema();
        }
      }, (rightToken) => {
        if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
          return rightToken.generateSchema().schema;
        } else {
          return rightToken.generateSchema();
        }
      })
    };
  }
  compare(val1, val2) {
    const [leftToken, rightToken] = this.tokens();
    const getValue = (token, args) => {
      if (token instanceof PairToken && !token.hasAnnotations()) {
        return args;
      } else {
        return args[token.annot()];
      }
    };
    if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {
      const result = leftToken.compare(getValue(leftToken, val1), getValue(leftToken, val2));
      if (result === 0) {
        return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));
      }
      return result;
    }
    throw new TokenComparisonError(val1, val2);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (PairToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.tokens().map((t) => t.findAndReturnTokens(tokenToFind, tokens2));
    return tokens2;
  }
}
PairToken.prim = "pair";
class NatValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "NatValidationError";
  }
}
class NatToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new BigNumber$1(val[Object.keys(val)[0]]);
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { int: new BigNumber$1(val).toFixed() };
  }
  isValid(val) {
    const bigNumber = new BigNumber$1(val);
    if (bigNumber.isNaN()) {
      return new NatValidationError(val, this, `Value is not a number: ${val}`);
    } else if (bigNumber.isNegative()) {
      return new NatValidationError(val, this, `Value cannot be negative: ${val}`);
    } else {
      return null;
    }
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[NatToken.prim]) {
      return semantic[NatToken.prim](val);
    }
    return { int: new BigNumber$1(val).toFixed() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return NatToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: NatToken.prim,
      schema: NatToken.prim
    };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: NatToken.prim }
    };
  }
  ToKey({ int: int2 }) {
    return new BigNumber$1(int2);
  }
  compare(nat1, nat2) {
    const o1 = Number(nat1);
    const o2 = Number(nat2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (NatToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
NatToken.prim = "nat";
class StringToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return val[Object.keys(val)[0]];
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return StringToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: StringToken.prim,
      schema: StringToken.prim
    };
  }
  Encode(args) {
    const val = args.pop();
    return { string: val };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[StringToken.prim]) {
      return semantic[StringToken.prim](val);
    }
    return { string: val };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: StringToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (StringToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
StringToken.prim = "string";
class AddressValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "AddressValidationError";
  }
}
class AddressToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    const decoded = b58decode(val);
    return {
      key: { bytes: decoded },
      type: { prim: "bytes" }
    };
  }
  isValid(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      return new AddressValidationError(value, this, `Address is not valid: ${value}`);
    }
    return null;
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { string: val };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[AddressToken.prim]) {
      return semantic[AddressToken.prim](val);
    }
    return { string: val };
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new AddressValidationError(val, this, `cannot be missing both string and bytes: ${val}`);
    }
    return encodePubKey(val.bytes);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return AddressToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: AddressToken.prim,
      schema: AddressToken.prim
    };
  }
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    if (!bytes) {
      throw new AddressValidationError({ bytes, string }, this, `cannot be missing both string and bytes ${{ string, bytes }}`);
    }
    return encodePubKey(bytes);
  }
  compare(address1, address2) {
    const isImplicit = (address) => {
      return address.startsWith("tz");
    };
    const implicit1 = isImplicit(address1);
    const implicit2 = isImplicit(address2);
    if (implicit1 && !implicit2) {
      return -1;
    } else if (implicit2 && !implicit1) {
      return 1;
    }
    return super.compare(address1, address2);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (AddressToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
AddressToken.prim = "address";
class MapValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "MapValidationError";
  }
}
class MapToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get ValueSchema() {
    return this.createToken(this.val.args[1], 0);
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  isValid(value) {
    if (MichelsonMap.isMichelsonMap(value)) {
      return null;
    }
    return new MapValidationError(value, this, "Value must be a MichelsonMap");
  }
  Execute(val, semantics) {
    const map2 = new MichelsonMap(this.val);
    val.forEach((current) => {
      map2.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));
    });
    return map2;
  }
  objLitToMichelsonMap(val) {
    if (val instanceof MichelsonMap)
      return val;
    if (typeof val === "object") {
      if (Object.keys(val).length === 0) {
        return new MichelsonMap();
      } else {
        return MichelsonMap.fromLiteral(val);
      }
    }
    return val;
  }
  Encode(args) {
    const val = this.objLitToMichelsonMap(args.pop());
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return Array.from(val.keys()).sort((a2, b2) => this.KeySchema.compare(a2, b2)).map((key2) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key2), this.ValueSchema.EncodeObject(val.get(key2))]
      };
    });
  }
  EncodeObject(args, semantic) {
    const val = this.objLitToMichelsonMap(args);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[MapToken.prim]) {
      return semantic[MapToken.prim](val);
    }
    return Array.from(val.keys()).sort((a2, b2) => this.KeySchema.compare(a2, b2)).map((key2) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key2), this.ValueSchema.EncodeObject(val.get(key2))]
      };
    });
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      map: {
        key: this.KeySchema.ExtractSchema(),
        value: this.ValueSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: MapToken.prim,
      schema: {
        key: this.KeySchema.generateSchema(),
        value: this.ValueSchema.generateSchema()
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (MapToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
MapToken.prim = "map";
class BoolToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return String(val.prim).toLowerCase() === "true" ? true : false;
  }
  Encode(args) {
    const val = args.pop();
    return { prim: val ? "True" : "False" };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[BoolToken.prim]) {
      return semantic[BoolToken.prim](val);
    }
    return { prim: val ? "True" : "False" };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return BoolToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: BoolToken.prim,
      schema: BoolToken.prim
    };
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: { prim: BoolToken.prim }
    };
  }
  ToKey(val) {
    return this.EncodeObject(val);
  }
  compare(val1, val2) {
    if (val1 && val2 || !val1 && !val2) {
      return 0;
    } else if (val1) {
      return 1;
    } else {
      return -1;
    }
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (BoolToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
BoolToken.prim = "bool";
class TxRollupL2AddressValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "TxRollupL2AddressValidationError";
  }
}
class TxRollupL2AddressToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    const decoded = b58decodeL2Address(val);
    return {
      key: { bytes: decoded },
      type: { prim: "bytes" }
    };
  }
  isValid(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new TxRollupL2AddressValidationError(value, this, `tx_rollup_l2_address is not valid: ${value}`);
    }
    return null;
  }
  Encode(args) {
    const val = args.pop();
    if (!val) {
      throw new TxRollupL2AddressValidationError(val, this, `arg missing to encode: this -> "${val}"`);
    }
    this.isValid(val);
    return { string: val };
  }
  EncodeObject(val, semantic) {
    this.isValid(val);
    if (semantic && semantic[TxRollupL2AddressToken.prim]) {
      return semantic[TxRollupL2AddressToken.prim](val);
    }
    return { string: val };
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new TxRollupL2AddressValidationError(val, this, `value cannot be missing string and byte value. must have one ${JSON.stringify(val)}`);
    }
    return encodeL2Address(val.bytes);
  }
  ExtractSchema() {
    return TxRollupL2AddressToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: TxRollupL2AddressToken.prim,
      schema: TxRollupL2AddressToken.prim
    };
  }
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    if (!bytes) {
      throw new TxRollupL2AddressValidationError(bytes, this, `value cannot be missing string and byte value. must have one: bytes = ${bytes}`);
    }
    return encodeL2Address(bytes);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (TxRollupL2AddressToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
TxRollupL2AddressToken.prim = "tx_rollup_l2_address";
class ContractValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ContractValidationError";
  }
}
class ContractToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      return new ContractValidationError(value, this, "Contract address is not valid");
    }
    return null;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new ContractValidationError(val, this, "must contain bytes or string");
    }
    return encodePubKey(val.bytes);
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { string: val };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[ContractToken.prim]) {
      return semantic[ContractToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return ContractToken.prim;
  }
  generateSchema() {
    const valueSchema = this.createToken(this.val.args[0], 0);
    return {
      __michelsonType: ContractToken.prim,
      schema: {
        parameter: this.val.args[0] ? valueSchema.generateSchema() : {}
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (ContractToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
ContractToken.prim = "contract";
class ListValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ListValidationError";
  }
}
class ListToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueSchema() {
    return this.createToken(this.val.args[0], this.idx);
  }
  isValid(value) {
    if (Array.isArray(value)) {
      return null;
    }
    return new ListValidationError(value, this, "Value must be an array");
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    const schema = this.createToken(this.val.args[0], 0);
    return val.reduce((prev, current) => {
      return [...prev, schema.EncodeObject(current)];
    }, []);
  }
  Execute(val, semantics) {
    const schema = this.createToken(this.val.args[0], 0);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return val.reduce((prev, current) => {
      return [...prev, schema.Execute(current, semantics)];
    }, []);
  }
  EncodeObject(args, semantic) {
    const schema = this.createToken(this.val.args[0], 0);
    const err = this.isValid(args);
    if (err) {
      throw err;
    }
    if (semantic && semantic[ListToken.prim]) {
      return semantic[ListToken.prim](args);
    }
    return args.reduce((prev, current) => {
      return [...prev, schema.EncodeObject(current)];
    }, []);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [ListToken.prim]: this.valueSchema.ExtractSchema()
    };
  }
  generateSchema() {
    return {
      __michelsonType: ListToken.prim,
      schema: this.valueSchema.generateSchema()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (ListToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
ListToken.prim = "list";
class MutezValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "MutezValidationError";
  }
}
class MutezToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new BigNumber$1(val[Object.keys(val)[0]]);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return MutezToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: MutezToken.prim,
      schema: MutezToken.prim
    };
  }
  isValid(val) {
    const bigNumber = new BigNumber$1(val);
    if (bigNumber.isNaN()) {
      return new MutezValidationError(val, this, `Value is not a number: ${val}`);
    } else {
      return null;
    }
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { int: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[MutezToken.prim]) {
      return semantic[MutezToken.prim](val);
    }
    return { int: String(val).toString() };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: MutezToken.prim }
    };
  }
  ToKey({ int: int2 }) {
    return int2;
  }
  compare(mutez1, mutez2) {
    const o1 = Number(mutez1);
    const o2 = Number(mutez2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (MutezToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
MutezToken.prim = "mutez";
class BytesValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "BytesValidationError";
  }
}
class BytesToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    return {
      key: { bytes: val },
      type: { prim: BytesToken.prim }
    };
  }
  isValid(val) {
    if (typeof val === "string" && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return null;
    } else {
      return new BytesValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = stripHexPrefix(this.convertUint8ArrayToHexString(val));
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    if (typeof val === "string") {
      val = stripHexPrefix(val);
    }
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[BytesToken.prim]) {
      return semantic[BytesToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return BytesToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: BytesToken.prim,
      schema: BytesToken.prim
    };
  }
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    return bytes;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (BytesToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
BytesToken.prim = "bytes";
class OptionToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  subToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  schema() {
    return this.createToken(this.val.args[0], 0);
  }
  annot() {
    return Array.isArray(this.val.annots) ? super.annot() : this.createToken(this.val.args[0], this.idx).annot();
  }
  Encode(args) {
    const value = args;
    if (value === void 0 || value === null) {
      return { prim: "None" };
    } else if (Array.isArray(value) && (value[value.length - 1] === void 0 || value[value.length - 1] === null)) {
      value.pop();
      return { prim: "None" };
    }
    return { prim: "Some", args: [this.schema().Encode(args)] };
  }
  EncodeObject(args, semantic) {
    const value = args;
    if (value === void 0 || value === null) {
      return { prim: "None" };
    }
    return { prim: "Some", args: [this.schema().EncodeObject(value, semantic)] };
  }
  Execute(val, semantics) {
    if (val.prim === "None") {
      return null;
    }
    return this.schema().Execute(val.args[0], semantics);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.schema().ExtractSchema();
  }
  generateSchema() {
    return {
      __michelsonType: OptionToken.prim,
      schema: this.schema().generateSchema()
    };
  }
  ExtractSignature() {
    return [...this.schema().ExtractSignature(), []];
  }
  get KeySchema() {
    return this.schema();
  }
  compare(val1, val2) {
    if (!val1) {
      return -1;
    } else if (!val2) {
      return 1;
    }
    return this.KeySchema.compare(val1, val2);
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (OptionToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.subToken().findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
OptionToken.prim = "option";
class TimestampToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string && /^\d+$/.test(val.string)) {
      return new Date(Number(val.string) * 1e3).toISOString();
    } else if (val.string) {
      return new Date(val.string).toISOString();
    } else if (val.int) {
      return new Date(Number(val.int) * 1e3).toISOString();
    }
  }
  Encode(args) {
    const val = args.pop();
    if (typeof val === "number") {
      return { int: String(val) };
    } else {
      return { string: val };
    }
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[TimestampToken.prim]) {
      return semantic[TimestampToken.prim](val);
    }
    if (typeof val === "number") {
      return { int: String(val) };
    } else {
      return { string: val };
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return TimestampToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: TimestampToken.prim,
      schema: TimestampToken.prim
    };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: TimestampToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (TimestampToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
TimestampToken.prim = "timestamp";
class IntValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "IntValidationError";
  }
}
class IntToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new BigNumber$1(val[Object.keys(val)[0]]);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return IntToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: IntToken.prim,
      schema: IntToken.prim
    };
  }
  isValid(val) {
    const bigNumber = new BigNumber$1(val);
    if (bigNumber.isNaN()) {
      return new IntValidationError(val, this, `Value is not a number: ${val}`);
    } else {
      return null;
    }
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { int: new BigNumber$1(val).toFixed() };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[IntToken.prim]) {
      return semantic[IntToken.prim](val);
    }
    return { int: new BigNumber$1(val).toFixed() };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: IntToken.prim }
    };
  }
  ToKey({ int: int2 }) {
    return int2;
  }
  compare(int1, int2) {
    const o1 = Number(int1);
    const o2 = Number(int2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (IntToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
IntToken.prim = "int";
class UnitToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    args.pop();
    return { prim: "Unit" };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[UnitToken.prim]) {
      return semantic[UnitToken.prim](val);
    }
    return { prim: "Unit" };
  }
  Execute(_val) {
    return UnitValue;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return UnitToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: UnitToken.prim,
      schema: UnitToken.prim
    };
  }
  compare(_val1, _val2) {
    return 0;
  }
  ToKey(_val) {
    return UnitValue;
  }
  ToBigMapKey(_val) {
    return {
      key: { prim: "Unit" },
      type: { prim: UnitToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (UnitToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
UnitToken.prim = "unit";
const publicKeyPrefixLength = 4;
class KeyValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "KeyValidationError";
  }
}
class KeyToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return encodeKey(val.bytes);
  }
  isValid(value) {
    if (validatePublicKey(value) !== ValidationResult.VALID) {
      return new KeyValidationError(value, this, "Key is not valid");
    }
    return null;
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { string: val };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[KeyToken.prim]) {
      return semantic[KeyToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return KeyToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: KeyToken.prim,
      schema: KeyToken.prim
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: KeyToken.prim }
    };
  }
  compare(key1, key2) {
    const keyPrefix1 = this.getPrefix(key1);
    const keyPrefix2 = this.getPrefix(key2);
    if (keyPrefix1 === Prefix.EDPK && keyPrefix2 !== Prefix.EDPK) {
      return -1;
    } else if (keyPrefix1 === Prefix.SPPK && keyPrefix2 !== Prefix.SPPK) {
      return keyPrefix2 === Prefix.EDPK ? 1 : -1;
    } else if (keyPrefix1 === Prefix.P2PK) {
      if (keyPrefix2 !== Prefix.P2PK) {
        return 1;
      }
      const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);
      const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);
      return Buffer.compare(keyBytes1, keyBytes2);
    }
    return super.compare(key1, key2);
  }
  getPrefix(val) {
    return val.substring(0, publicKeyPrefixLength);
  }
  getP256PublicKeyComparableBytes(p2pk) {
    return b58cdecode(p2pk, prefix[Prefix.P2PK]).slice(1);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (KeyToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
KeyToken.prim = "key";
class KeyHashValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "KeyHashValidationError";
  }
}
class KeyHashToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return encodeKeyHash(val.bytes);
  }
  isValid(value) {
    if (validateKeyHash(value) !== ValidationResult.VALID) {
      return new KeyHashValidationError(value, this, `KeyHash is not valid: ${value}`);
    }
    return null;
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { string: val };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[KeyHashToken.prim]) {
      return semantic[KeyHashToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return KeyHashToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: KeyHashToken.prim,
      schema: KeyHashToken.prim
    };
  }
  ToKey({ string, bytes }) {
    if (string) {
      return string;
    }
    return encodeKeyHash(bytes);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: KeyHashToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (KeyHashToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
KeyHashToken.prim = "key_hash";
class SignatureValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SignatureValidationError";
  }
}
class SignatureToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return val.bytes;
  }
  isValid(value) {
    if (validateSignature(value) !== ValidationResult.VALID) {
      return new SignatureValidationError(value, this, "Signature is not valid");
    }
    return null;
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { string: val };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[SignatureToken.prim]) {
      return semantic[SignatureToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return SignatureToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: SignatureToken.prim,
      schema: SignatureToken.prim
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: SignatureToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (SignatureToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
SignatureToken.prim = "signature";
class LambdaToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get paramSchema() {
    return this.createToken(this.val.args[0], this.idx);
  }
  get returnSchema() {
    return this.createToken(this.val.args[1], this.idx + 1);
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    } else {
      return val;
    }
  }
  Encode(args) {
    const val = args.pop();
    return val;
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[LambdaToken.prim]) {
      return semantic[LambdaToken.prim](val);
    }
    return val;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [LambdaToken.prim]: {
        parameters: this.paramSchema.ExtractSchema(),
        returns: this.returnSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: LambdaToken.prim,
      schema: {
        parameters: this.paramSchema.generateSchema(),
        returns: this.returnSchema.generateSchema()
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (LambdaToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
LambdaToken.prim = "lambda";
class OperationToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return val.string;
  }
  Encode(...args) {
    const val = args.pop();
    return { string: val };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[OperationToken.prim]) {
      return semantic[OperationToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return OperationToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: OperationToken.prim,
      schema: OperationToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (OperationToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
OperationToken.prim = "operation";
class SetValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SetValidationError";
  }
}
class SetToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  isValid(value) {
    if (Array.isArray(value)) {
      return null;
    }
    return new SetValidationError(value, this, "Value must be an array");
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return val.sort((a2, b2) => this.KeySchema.compare(a2, b2)).reduce((prev, current) => {
      return [...prev, this.KeySchema.EncodeObject(current)];
    }, []);
  }
  Execute(val, semantics) {
    return val.reduce((prev, current) => {
      return [...prev, this.KeySchema.Execute(current, semantics)];
    }, []);
  }
  EncodeObject(args, semantic) {
    const err = this.isValid(args);
    if (err) {
      throw err;
    }
    if (semantic && semantic[SetToken.prim]) {
      return semantic[SetToken.prim](args);
    }
    return args.sort((a2, b2) => this.KeySchema.compare(a2, b2)).reduce((prev, current) => {
      return [...prev, this.KeySchema.EncodeObject(current)];
    }, []);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return SetToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: SetToken.prim,
      schema: this.KeySchema.generateSchema()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (SetToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
SetToken.prim = "set";
class ChainIDValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChainIDValidationError";
  }
}
class ChainIDToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(value) {
    if (validateChain(value) !== ValidationResult.VALID) {
      return new ChainIDValidationError(value, this, "ChainID is not valid");
    }
    return null;
  }
  Execute(val) {
    return val[Object.keys(val)[0]];
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return ChainIDToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: ChainIDToken.prim,
      schema: ChainIDToken.prim
    };
  }
  Encode(args) {
    const val = args.pop();
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { string: val };
  }
  EncodeObject(val, semantic) {
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[ChainIDToken.prim]) {
      return semantic[ChainIDToken.prim](val);
    }
    return { string: val };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: ChainIDToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (ChainIDToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
ChainIDToken.prim = "chain_id";
class EncodeTicketError extends Error {
  constructor() {
    super("Tickets cannot be sent to the blockchain; they are created on-chain");
    this.name = "TicketEncodeError";
  }
}
const ticketerType$1 = { prim: "contract" };
const amountType$1 = { prim: "int" };
class TicketToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  Encode(_args) {
    throw new EncodeTicketError();
  }
  EncodeObject(args, semantic) {
    if (semantic && semantic[TicketToken.prim]) {
      return semantic[TicketToken.prim](args, this.val);
    }
    throw new EncodeTicketError();
  }
  Execute(val, semantics) {
    if (semantics && semantics[TicketToken.prim]) {
      return semantics[TicketToken.prim](val, this.val);
    }
    const ticketer = this.createToken(ticketerType$1, this.idx);
    const value = this.valueToken;
    const amount = this.createToken(amountType$1, this.idx);
    if (void 0 === val.args[2] && void 0 !== val.args[1].args) {
      return {
        ticketer: ticketer.Execute(val.args[0], semantics),
        value: value.Execute(val.args[1].args[0], semantics),
        amount: amount.Execute(val.args[1].args[1], semantics)
      };
    }
    return {
      ticketer: ticketer.Execute(val.args[0], semantics),
      value: value.Execute(val.args[1], semantics),
      amount: amount.Execute(val.args[2], semantics)
    };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      ticketer: ContractToken.prim,
      value: this.valueToken.ExtractSchema(),
      amount: IntToken.prim
    };
  }
  generateSchema() {
    return {
      __michelsonType: TicketToken.prim,
      schema: {
        value: this.valueToken.generateSchema(),
        ticketer: {
          __michelsonType: ContractToken.prim,
          schema: ContractToken.prim
        },
        amount: {
          __michelsonType: IntToken.prim,
          schema: IntToken.prim
        }
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (TicketToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.valueToken.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
TicketToken.prim = "ticket";
class EncodeTicketDeprecatedError extends Error {
  constructor() {
    super("Ticket_deprecated cannot be sent to the blockchain; they are created on-chain");
    this.name = "TicketDeprecatedEncodeError";
  }
}
const ticketerType = { prim: "contract" };
const amountType = { prim: "int" };
class TicketDeprecatedToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  Encode(_args) {
    throw new EncodeTicketDeprecatedError();
  }
  EncodeObject(args, semantic) {
    if (semantic && semantic[TicketDeprecatedToken.prim]) {
      return semantic[TicketDeprecatedToken.prim](args, this.val);
    }
    throw new EncodeTicketDeprecatedError();
  }
  Execute(val, semantics) {
    if (semantics && semantics[TicketDeprecatedToken.prim]) {
      return semantics[TicketDeprecatedToken.prim](val, this.val);
    }
    const ticketer = this.createToken(ticketerType, this.idx);
    const value = this.valueToken;
    const amount = this.createToken(amountType, this.idx);
    if (void 0 === val.args[2] && void 0 !== val.args[1].args) {
      return {
        ticketer: ticketer.Execute(val.args[0], semantics),
        value: value.Execute(val.args[1].args[0], semantics),
        amount: amount.Execute(val.args[1].args[1], semantics)
      };
    }
    return {
      ticketer: ticketer.Execute(val.args[0], semantics),
      value: value.Execute(val.args[1], semantics),
      amount: amount.Execute(val.args[2], semantics)
    };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      ticketer: ContractToken.prim,
      value: this.valueToken.ExtractSchema(),
      amount: IntToken.prim
    };
  }
  generateSchema() {
    return {
      __michelsonType: TicketDeprecatedToken.prim,
      schema: {
        value: this.valueToken.generateSchema(),
        ticketer: {
          __michelsonType: ContractToken.prim,
          schema: ContractToken.prim
        },
        amount: {
          __michelsonType: IntToken.prim,
          schema: IntToken.prim
        }
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (TicketDeprecatedToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.valueToken.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
}
TicketDeprecatedToken.prim = "ticket_deprecated";
class NeverTokenError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "NeverTokenError";
  }
}
class NeverToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    const val = args.pop();
    throw new NeverTokenError(val, this, "Assigning a value to the type never is forbidden.");
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[NeverToken.prim]) {
      return semantic[NeverToken.prim](val);
    }
    throw new NeverTokenError(val, this, "Assigning a value to the type never is forbidden.");
  }
  Execute(val) {
    throw new NeverTokenError(val, this, "There is no literal value for the type never.");
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return NeverToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: NeverToken.prim,
      schema: NeverToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (NeverToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
NeverToken.prim = "never";
class SaplingStateValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingStateValidationError";
  }
}
class SaplingStateToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    return typeof val === "object" && Object.keys(val).length === 0;
  }
  Execute(val, semantic) {
    if (semantic && semantic[SaplingStateToken.prim]) {
      return semantic[SaplingStateToken.prim](val, this.val);
    }
    if ("int" in val) {
      return val.int;
    } else {
      throw new SaplingStateValidationError(val, this, `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`);
    }
  }
  Encode(args) {
    const val = args.pop();
    if (this.isValid(val)) {
      return [];
    } else {
      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${val} while expecting: {}`);
    }
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[SaplingStateToken.prim]) {
      return semantic[SaplingStateToken.prim](val);
    }
    if (this.isValid(val)) {
      return [];
    } else {
      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${val} while expecting: {}`);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [SaplingStateToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: SaplingStateToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (SaplingStateToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
SaplingStateToken.prim = "sapling_state";
class SaplingTransactionValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingTransactionValidationError";
  }
}
class SaplingTransactionToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(_val) {
    throw new SaplingTransactionValidationError(_val, this, "There is no literal value for the sapling_transaction type.");
  }
  validateBytes(val) {
    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
    if (bytes && bytes[2].length % 2 === 0) {
      return bytes[2];
    } else {
      throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    if (semantic && semantic[SaplingTransactionToken.prim]) {
      return semantic[SaplingTransactionToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [SaplingTransactionToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: SaplingTransactionToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (SaplingTransactionToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
SaplingTransactionToken.prim = "sapling_transaction";
class SaplingTransactionDeprecatedValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingTransactionDeprecatedValidationError";
  }
}
class SaplingTransactionDeprecatedToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(_val) {
    throw new SaplingTransactionDeprecatedValidationError(_val, this, "There is no literal value for the sapling_transaction_deprecated type.");
  }
  validateBytes(val) {
    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
    if (bytes && bytes[2].length % 2 === 0) {
      return bytes[2];
    } else {
      throw new SaplingTransactionDeprecatedValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    if (semantic && semantic[SaplingTransactionDeprecatedToken.prim]) {
      return semantic[SaplingTransactionDeprecatedToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [SaplingTransactionDeprecatedToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: SaplingTransactionDeprecatedToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (SaplingTransactionDeprecatedToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
SaplingTransactionDeprecatedToken.prim = "sapling_transaction_deprecated";
class Bls12381frValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381frValidationError";
  }
}
class Bls12381frToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return null;
    } else {
      return new Bls12381frValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    if (typeof val === "number") {
      return { int: val.toString() };
    } else {
      val = this.convertUint8ArrayToHexString(val);
      const err = this.isValid(val);
      if (err) {
        throw err;
      }
      return { bytes: val };
    }
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[Bls12381frToken.prim]) {
      return semantic[Bls12381frToken.prim](val);
    }
    if (typeof val === "number") {
      return { int: val.toString() };
    } else {
      val = this.convertUint8ArrayToHexString(val);
      const err = this.isValid(val);
      if (err) {
        throw err;
      }
      return { bytes: val };
    }
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return Bls12381frToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: Bls12381frToken.prim,
      schema: Bls12381frToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (Bls12381frToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
Bls12381frToken.prim = "bls12_381_fr";
class Bls12381g1ValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381g1ValidationError";
  }
}
class Bls12381g1Token extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return null;
    } else {
      return new Bls12381g1ValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { bytes: val };
  }
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[Bls12381g1Token.prim]) {
      return semantic[Bls12381g1Token.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return Bls12381g1Token.prim;
  }
  generateSchema() {
    return {
      __michelsonType: Bls12381g1Token.prim,
      schema: Bls12381g1Token.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (Bls12381g1Token.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
Bls12381g1Token.prim = "bls12_381_g1";
class Bls12381g2ValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381g2ValidationError";
  }
}
class Bls12381g2Token extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return null;
    } else {
      return new Bls12381g2ValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { bytes: val };
  }
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[Bls12381g2Token.prim]) {
      return semantic[Bls12381g2Token.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return Bls12381g2Token.prim;
  }
  generateSchema() {
    return {
      __michelsonType: Bls12381g2Token.prim,
      schema: Bls12381g2Token.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (Bls12381g2Token.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
Bls12381g2Token.prim = "bls12_381_g2";
class ChestValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChestValidationError";
  }
}
class ChestToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return null;
    } else {
      return new ChestValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { bytes: val };
  }
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[ChestToken.prim]) {
      return semantic[ChestToken.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return ChestToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: ChestToken.prim,
      schema: ChestToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (ChestToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
ChestToken.prim = "chest";
class ChestKeyValidationError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChestKeyValidationError";
  }
}
class ChestKeyToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return null;
    } else {
      return new ChestKeyValidationError(val, this, `Invalid bytes: ${val}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    return { bytes: val };
  }
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    const err = this.isValid(val);
    if (err) {
      throw err;
    }
    if (semantic && semantic[ChestKeyToken.prim]) {
      return semantic[ChestKeyToken.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return ChestKeyToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: ChestKeyToken.prim,
      schema: ChestKeyToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (ChestKeyToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
ChestKeyToken.prim = "chest_key";
class GlobalConstantEncodingError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "GlobalConstantEncodingError";
  }
}
class GlobalConstantDecodingError extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "GlobalConstantDecodingError";
  }
}
class GlobalConstantToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val, semantic) {
    if (semantic && semantic[GlobalConstantToken.prim]) {
      return semantic[GlobalConstantToken.prim](val, this.val);
    } else {
      throw new GlobalConstantDecodingError(val, this, `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
    }
  }
  Encode(args) {
    throw new GlobalConstantEncodingError(args, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[GlobalConstantToken.prim]) {
      return semantic[GlobalConstantToken.prim](val);
    }
    throw new GlobalConstantEncodingError(val, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return GlobalConstantToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: GlobalConstantToken.prim,
      schema: {
        hash: this.val.args[0]["string"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (GlobalConstantToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
}
GlobalConstantToken.prim = "constant";
const tokens = [
  PairToken,
  NatToken,
  StringToken,
  BigMapToken,
  AddressToken,
  TxRollupL2AddressToken,
  MapToken,
  BoolToken,
  OrToken,
  ContractToken,
  ListToken,
  MutezToken,
  BytesToken,
  OptionToken,
  TimestampToken,
  IntToken,
  UnitToken,
  KeyToken,
  KeyHashToken,
  SignatureToken,
  LambdaToken,
  OperationToken,
  SetToken,
  ChainIDToken,
  TicketToken,
  TicketDeprecatedToken,
  NeverToken,
  SaplingStateToken,
  SaplingTransactionToken,
  SaplingTransactionDeprecatedToken,
  Bls12381frToken,
  Bls12381g1Token,
  Bls12381g2Token,
  ChestToken,
  ChestKeyToken,
  GlobalConstantToken
];
class InvalidTokenError extends Error {
  constructor(message, data2) {
    super(message);
    this.message = message;
    this.data = data2;
    this.name = "Invalid token error";
  }
}
function createToken(val, idx) {
  if (Array.isArray(val)) {
    return new PairToken(val, idx, createToken);
  }
  const t = tokens.find((x2) => x2.prim === val.prim);
  if (!t) {
    throw new InvalidTokenError("Malformed data expected a value with a valid prim property", val);
  }
  return new t(val, idx, createToken);
}
class ViewEncodingError extends Error {
  constructor(smartContractViewName, originalError) {
    super(`Unable to encode the parameter of the view: ${smartContractViewName}.`);
    this.smartContractViewName = smartContractViewName;
    this.originalError = originalError;
    this.name = "ViewEncodingError";
  }
}
class InvalidScriptError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidScriptError";
  }
}
class InvalidRpcResponseError extends Error {
  constructor(script) {
    super(`Invalid RPC response passed as argument(s)`);
    this.script = script;
    this.name = "InvalidRpcResponseError";
  }
}
class ParameterEncodingError extends Error {
  constructor(message, args, originalError) {
    super(`
      ${message}. Error encountered when trying to encode arguments: 

      [${args}]
    `);
    this.message = message;
    this.args = args;
    this.originalError = originalError;
    this.name = "ParameterEncodingError";
  }
}
class InvalidBigMapSchema extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidBigMapSchema";
  }
}
class InvalidBigMapDiff extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidBigMapDiff";
  }
}
class BigMapEncodingError extends Error {
  constructor(obj, details) {
    super(`Unable to encode ${obj}. ${details}`);
    this.obj = obj;
    this.details = details;
    this.name = "BigMapEncodingError";
  }
}
class StorageEncodingError extends Error {
  constructor(obj, details) {
    super(`Unable to encode ${obj}. ${details}`);
    this.obj = obj;
    this.details = details;
    this.name = "StorageEncodingError";
  }
}
class MissingArgumentError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "MissingArgumentError";
  }
}
var _a;
const schemaTypeSymbol = Symbol.for("taquito-schema-type-symbol");
function collapse(val, prim = PairToken.prim) {
  var _b, _c;
  if (Array.isArray(val)) {
    return collapse({
      prim,
      args: val
    }, prim);
  }
  const extended = val;
  if (extended.prim === prim && extended.args && extended.args.length > 2) {
    return Object.assign(Object.assign({}, extended), { args: [
      (_b = extended.args) === null || _b === void 0 ? void 0 : _b[0],
      {
        prim,
        args: (_c = extended.args) === null || _c === void 0 ? void 0 : _c.slice(1)
      }
    ] });
  }
  return extended;
}
function deepEqual(a2, b2) {
  const ac = collapse(a2);
  const bc = collapse(b2);
  return ac.prim === bc.prim && (ac.args === void 0 && bc.args === void 0 || ac.args !== void 0 && bc.args !== void 0 && ac.args.length === bc.args.length && ac.args.every((v2, i2) => {
    var _b, _c;
    return deepEqual(v2, (_c = (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i2]) !== null && _c !== void 0 ? _c : {});
  })) && (ac.annots === void 0 && bc.annots === void 0 || ac.annots !== void 0 && bc.annots !== void 0 && ac.annots.length === bc.annots.length && ac.annots.every((v2, i2) => {
    var _b;
    return v2 === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i2]);
  }));
}
class Schema {
  constructor(val) {
    this.val = val;
    this[_a] = true;
    this.root = createToken(val, 0);
    if (this.root instanceof BigMapToken) {
      this.bigMap = this.root;
    } else if (this.isExpressionExtended(val) && val.prim === "pair") {
      const exp = val.args[0];
      if (this.isExpressionExtended(exp) && exp.prim === "big_map") {
        this.bigMap = new BigMapToken(exp, 0, createToken);
      }
    }
  }
  static isSchema(obj) {
    return obj && obj[schemaTypeSymbol] === true;
  }
  static fromRPCResponse(val) {
    const storage = val && val.script && Array.isArray(val.script.code) && val.script.code.find((x2) => {
      if (!Array.isArray(x2)) {
        const checkExtended = x2;
        if (checkExtended.prim) {
          return checkExtended.prim === "storage";
        } else {
          return false;
        }
      } else {
        this.fromRPCResponse({ script: { code: x2, storage: val.script.storage } });
      }
    });
    if (!storage || !Array.isArray(storage.args)) {
      throw new InvalidRpcResponseError(val.script);
    }
    return new Schema(storage.args[0]);
  }
  isExpressionExtended(val) {
    return "prim" in val && Array.isArray(val.args);
  }
  removeTopLevelAnnotation(obj) {
    if (this.root instanceof PairToken || this.root instanceof OrToken) {
      if (this.root.hasAnnotations() && typeof obj === "object" && Object.keys(obj).length === 1) {
        return obj[Object.keys(obj)[0]];
      }
    }
    return obj;
  }
  Execute(val, semantics) {
    const storage = this.root.Execute(val, semantics);
    return this.removeTopLevelAnnotation(storage);
  }
  Typecheck(val) {
    if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {
      return true;
    }
    if (this.root instanceof TicketToken && val.ticketer && val.value && val.amount) {
      return true;
    }
    if (this.root instanceof TicketDeprecatedToken && val.ticketer && val.value && val.amount) {
      return true;
    }
    if (this.root instanceof MapToken && this.root.ValueSchema instanceof BigMapToken) {
      return true;
    }
    try {
      this.root.EncodeObject(val);
      return true;
    } catch (ex) {
      return false;
    }
  }
  ExecuteOnBigMapDiff(diff, semantics) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchema("Big map schema is undefined");
    }
    if (!Array.isArray(diff)) {
      throw new InvalidBigMapDiff("Big map diff must be an array");
    }
    const eltFormat = diff.map(({ key: key2, value }) => ({ args: [key2, value] }));
    return this.bigMap.Execute(eltFormat, semantics);
  }
  ExecuteOnBigMapValue(key2, semantics) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchema("No big map schema");
    }
    return this.bigMap.ValueSchema.Execute(key2, semantics);
  }
  EncodeBigMapKey(key2) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchema("Big map schema is undefined");
    }
    try {
      return this.bigMap.KeySchema.ToBigMapKey(key2);
    } catch (ex) {
      throw new BigMapEncodingError("big map key", ex);
    }
  }
  Encode(value, semantics) {
    try {
      return this.root.EncodeObject(value, semantics);
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new StorageEncodingError("storage object", ex);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.removeTopLevelAnnotation(this.root.ExtractSchema());
  }
  /**
   * @description Produce a representation of the storage schema.
   * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.
   */
  generateSchema() {
    return this.removeTopLevelAnnotation(this.root.generateSchema());
  }
  /**
   * @deprecated
   */
  ComputeState(tx, state2) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchema("Big map schema is undefined");
    }
    const bigMap = tx.reduce((prev, current) => {
      return Object.assign(Object.assign({}, prev), this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));
    }, {});
    return Object.assign(Object.assign({}, this.Execute(state2)), { [this.bigMap.annot()]: bigMap });
  }
  /**
   * @description Look up in top-level pairs of the storage to find a value matching the specified type
   *
   * @returns The first value found that match the type or `undefined` if no value is found
   *
   * @param storage storage to parse to find the value
   * @param valueType type of value to look for
   *
   */
  FindFirstInTopLevelPair(storage, valueType) {
    return this.findValue(this.root["val"], storage, valueType);
  }
  // TODO check these type casts
  findValue(schema, storage, valueToFind) {
    if (deepEqual(valueToFind, schema)) {
      return storage;
    }
    if (Array.isArray(schema) || schema.prim === "pair") {
      const sch = collapse(schema);
      const strg = collapse(storage, "Pair");
      if (sch.args === void 0 || strg.args === void 0) {
        throw new MissingArgumentError("Tokens have no arguments");
      }
      if (sch.args[0])
        return (
          // unsafe
          this.findValue(sch.args[0], strg.args[0], valueToFind) || this.findValue(sch.args[1], strg.args[1], valueToFind)
        );
    }
  }
  /**
   * @description Look up the schema to find any occurrence of a particular token.
   *
   * @returns an array of tokens of the specified kind or an empty array if no token was found
   *
   * @param tokenToFind string representing the prim property of the token to find
   *
   * @example
   * ```
   * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:
   *
   * const schema = new Schema(script);
   * const allGlobalConstantTokens = schema.findToken('constant');
   * ```
   *
   */
  findToken(tokenToFind) {
    const tokens2 = [];
    return this.root.findAndReturnTokens(tokenToFind, tokens2);
  }
}
_a = schemaTypeSymbol;
class ParameterSchema {
  constructor(val) {
    this.root = createToken(val, 0);
  }
  static fromRPCResponse(val) {
    const parameter = val && val.script && Array.isArray(val.script.code) && val.script.code.find((x2) => x2.prim === "parameter");
    if (!parameter || !Array.isArray(parameter.args)) {
      throw new InvalidRpcResponseError(val.script);
    }
    return new ParameterSchema(parameter.args[0]);
  }
  get isMultipleEntryPoint() {
    return this.root instanceof OrToken || this.root instanceof OptionToken && this.root.subToken() instanceof OrToken;
  }
  get hasAnnotation() {
    if (this.isMultipleEntryPoint) {
      return Object.keys(this.ExtractSchema())[0] !== "0";
    } else {
      return true;
    }
  }
  Execute(val, semantics) {
    return this.root.Execute(val, semantics);
  }
  Encode(...args) {
    try {
      return this.root.Encode(args.reverse());
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new ParameterEncodingError("Unable to encode parameter", args.toString(), ex);
    }
  }
  EncodeObject(value, semantics) {
    try {
      return this.root.EncodeObject(value, semantics);
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new ParameterEncodingError("Unable to encode parameter object", value, ex);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.root.ExtractSchema();
  }
  /**
   * @description Produce a schema grouping together all the entry points of a contract.
   */
  generateSchema() {
    return this.root.generateSchema();
  }
  ExtractSignatures() {
    return this.root.ExtractSignature();
  }
}
class ViewSchema {
  constructor(val) {
    if (val.length !== 4 || !("string" in val[0])) {
      throw new InvalidScriptError(`Invalid on-chain view: ${JSON.stringify(val)}`);
    }
    this.viewName = val[0]["string"];
    this.viewArgsType = val[1];
    this.viewReturnType = val[2];
    this.instructions = val[3];
    this.rootArgsType = createToken(this.viewArgsType, 0);
    this.rootReturnType = createToken(this.viewReturnType, 0);
  }
  /**
   *
   * @description Create an instance of ViewSchema for each view in a script
   *
   * @param val contract script obtained from the RPC
   * @returns array of ViewSchema or empty array if there is no view in the contract
   */
  static fromRPCResponse(val) {
    const allViewSchema = [];
    const views = val && val.script && Array.isArray(val.script.code) && val.script.code.filter((x2) => x2.prim === "view");
    if (views) {
      views.forEach((view) => {
        if (!view.args || view.args.length !== 4) {
          throw new InvalidScriptError(`Invalid on-chain view found in the script: ${JSON.stringify(view)}`);
        }
        allViewSchema.push(new ViewSchema(view.args));
      });
    }
    return allViewSchema;
  }
  /**
   *
   * @description Transform the view parameter into Michelson
   *
   * @param args parameter of the view in js format
   * @returns parameter of the view in Michelson
   */
  encodeViewArgs(args) {
    try {
      return this.rootArgsType.EncodeObject(args);
    } catch (ex) {
      throw new ViewEncodingError(this.viewName, ex);
    }
  }
  /**
   *
   * @description Transform the view result from Michelson to readable data
   *
   * @param val result of the view in JSON Michelson
   * @param semantics optional semantics to override the default decoding behavior
   * @returns result of the view in a readable format
   */
  decodeViewResult(val, semantics) {
    return this.rootReturnType.Execute(val, semantics);
  }
  /**
   *
   * @description Return the signature of the view parameter
   */
  extractArgsSchema() {
    return this.rootArgsType.ExtractSchema();
  }
  /**
   *
   * @description Return the format of the view result
   */
  extractResultSchema() {
    return this.rootReturnType.ExtractSchema();
  }
}
const UnitValue = Symbol();
const sourceReference = Symbol("source_reference");
class ScanError extends Error {
  constructor(src2, idx, message) {
    super(message);
    this.src = src2;
    this.idx = idx;
    Object.setPrototypeOf(this, ScanError.prototype);
  }
}
var Literal;
(function(Literal2) {
  Literal2[Literal2["Comment"] = 0] = "Comment";
  Literal2[Literal2["Number"] = 1] = "Number";
  Literal2[Literal2["String"] = 2] = "String";
  Literal2[Literal2["Bytes"] = 3] = "Bytes";
  Literal2[Literal2["Ident"] = 4] = "Ident";
})(Literal || (Literal = {}));
const isSpace = new RegExp("\\s");
const isIdentStart = new RegExp("[:@%_A-Za-z]");
const isIdent = new RegExp("[@%_\\.A-Za-z0-9]");
const isDigit = new RegExp("[0-9]");
const isHex = new RegExp("[0-9a-fA-F]");
function* scan(src2, scanComments = false) {
  let i2 = 0;
  while (i2 < src2.length) {
    while (i2 < src2.length && isSpace.test(src2[i2])) {
      i2++;
    }
    if (i2 === src2.length) {
      return;
    }
    const s2 = src2[i2];
    const start2 = i2;
    if (isIdentStart.test(s2)) {
      i2++;
      while (i2 < src2.length && isIdent.test(src2[i2])) {
        i2++;
      }
      yield { t: Literal.Ident, v: src2.slice(start2, i2), first: start2, last: i2 };
    } else if (src2.length - i2 > 1 && src2.substr(i2, 2) === "0x") {
      i2 += 2;
      while (i2 < src2.length && isHex.test(src2[i2])) {
        i2++;
      }
      if ((i2 - start2 & 1) !== 0) {
        throw new ScanError(src2, i2, "Bytes literal length is expected to be power of two");
      }
      yield { t: Literal.Bytes, v: src2.slice(start2, i2), first: start2, last: i2 };
    } else if (isDigit.test(s2) || s2 === "-") {
      if (s2 === "-") {
        i2++;
      }
      const ii = i2;
      while (i2 < src2.length && isDigit.test(src2[i2])) {
        i2++;
      }
      if (ii === i2) {
        throw new ScanError(src2, i2, "Number literal is too short");
      }
      yield { t: Literal.Number, v: src2.slice(start2, i2), first: start2, last: i2 };
    } else if (s2 === '"') {
      i2++;
      let esc = false;
      for (; i2 < src2.length && (esc || src2[i2] !== '"'); i2++) {
        if (!esc && src2[i2] === "\\") {
          esc = true;
        } else {
          esc = false;
        }
      }
      if (i2 === src2.length) {
        throw new ScanError(src2, i2, "Unterminated string literal");
      }
      i2++;
      yield { t: Literal.String, v: src2.slice(start2, i2), first: start2, last: i2 };
    } else if (s2 === "#") {
      i2++;
      while (i2 < src2.length && src2[i2] !== "\n") {
        i2++;
      }
      if (scanComments) {
        yield { t: Literal.Comment, v: src2.slice(start2, i2), first: start2, last: i2 };
      }
    } else if (src2.length - i2 > 1 && src2.substr(i2, 2) === "/*") {
      i2 += 2;
      while (i2 < src2.length && !(src2.length - i2 > 1 && src2.substr(i2, 2) === "*/")) {
        i2++;
      }
      if (i2 === src2.length) {
        throw new ScanError(src2, i2, "Unterminated C style comment");
      }
      i2 += 2;
      if (scanComments) {
        yield { t: Literal.Comment, v: src2.slice(start2, i2), first: start2, last: i2 };
      }
    } else if (s2 === "(" || s2 === ")" || s2 === "{" || s2 === "}" || s2 === ";") {
      i2++;
      yield { t: s2, v: s2, first: start2, last: i2 };
    } else {
      throw new ScanError(src2, i2, `Invalid character at offset ${i2}: \`${s2}'`);
    }
  }
}
const refContract = Symbol("ref_contract");
var Protocol;
(function(Protocol2) {
  Protocol2["Ps9mPmXa"] = "Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P";
  Protocol2["PtCJ7pwo"] = "PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY";
  Protocol2["PsYLVpVv"] = "PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt";
  Protocol2["PsddFKi3"] = "PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP";
  Protocol2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  Protocol2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  Protocol2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  Protocol2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  Protocol2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  Protocol2["PtEdoTez"] = "PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq";
  Protocol2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  Protocol2["PsFLoren"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocol2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocol2["PtGRANAD"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocol2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocol2["PtHangzH"] = "PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r";
  Protocol2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  Protocol2["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
  Protocol2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  Protocol2["PtJakarta"] = "PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw";
  Protocol2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  Protocol2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  Protocol2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  Protocol2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(Protocol || (Protocol = {}));
const DefaultProtocol = Protocol.Psithaca2;
const protoLevel$1 = {
  Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P: 0,
  PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY: 1,
  PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt: 2,
  PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP: 3,
  Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
  PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
  PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
  PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
  PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
  PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq: 8,
  PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
  PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
  PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
  PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r: 11,
  PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
  PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP: 12,
  Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
  PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw: 13,
  PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,
  PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg: 14,
  PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW: 15,
  ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 16
};
function ProtoInferiorTo$1(a2, b2) {
  return protoLevel$1[a2] < protoLevel$1[b2];
}
class MacroError extends Error {
  constructor(prim, message) {
    super(message);
    this.prim = prim;
    Object.setPrototypeOf(this, MacroError.prototype);
  }
}
function assertArgs$1(ex, n) {
  var _a2, _b;
  if (n === 0 && ex.args === void 0 || ((_a2 = ex.args) === null || _a2 === void 0 ? void 0 : _a2.length) === n) {
    return true;
  }
  throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${(_b = ex.args) === null || _b === void 0 ? void 0 : _b.length}`);
}
function assertNoAnnots(ex) {
  if (ex.annots === void 0) {
    return true;
  }
  throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);
}
function assertIntArg(ex, arg) {
  if ("int" in arg) {
    return true;
  }
  throw new MacroError(ex, `macro ${ex.prim} expects int argument`);
}
function parsePairUnpairExpr(p2, expr, annotations, agg) {
  let i2 = 0;
  let ai = 0;
  const ann = [null, null];
  let lexpr;
  if (i2 === expr.length) {
    throw new MacroError(p2, `unexpected end: ${p2.prim}`);
  }
  let c2 = expr[i2++];
  switch (c2) {
    case "P": {
      const { r: r2, n, an } = parsePairUnpairExpr(p2, expr.slice(i2), annotations.slice(ai), agg);
      lexpr = r2;
      i2 += n;
      ai += an;
      break;
    }
    case "A":
      if (ai !== annotations.length) {
        ann[0] = annotations[ai++];
      }
      break;
    default:
      throw new MacroError(p2, `${p2.prim}: unexpected character: ${c2}`);
  }
  let rexpr;
  if (i2 === expr.length) {
    throw new MacroError(p2, `unexpected end: ${p2.prim}`);
  }
  c2 = expr[i2++];
  switch (c2) {
    case "P": {
      const { r: r2, n, an } = parsePairUnpairExpr(p2, expr.slice(i2), annotations.slice(ai), agg);
      rexpr = r2.map(([v2, a2]) => [v2 + 1, a2]);
      i2 += n;
      ai += an;
      break;
    }
    case "I":
      if (ai !== annotations.length) {
        ann[1] = annotations[ai++];
      }
      break;
    default:
      throw new MacroError(p2, `${p2.prim}: unexpected character: ${c2}`);
  }
  return { r: agg(lexpr, rexpr, [0, ann]), n: i2, an: ai };
}
function parseSetMapCadr(p2, expr, vann, term) {
  const c2 = expr[0];
  switch (c2) {
    case "A":
      return expr.length > 1 ? [
        { prim: "DUP" },
        {
          prim: "DIP",
          args: [
            [{ prim: "CAR", annots: ["@%%"] }, parseSetMapCadr(p2, expr.slice(1), [], term)]
          ]
        },
        { prim: "CDR", annots: ["@%%"] },
        { prim: "SWAP" },
        { prim: "PAIR", annots: ["%@", "%@", ...vann] }
      ] : term.a;
    case "D":
      return expr.length > 1 ? [
        { prim: "DUP" },
        {
          prim: "DIP",
          args: [
            [{ prim: "CDR", annots: ["@%%"] }, parseSetMapCadr(p2, expr.slice(1), [], term)]
          ]
        },
        { prim: "CAR", annots: ["@%%"] },
        { prim: "PAIR", annots: ["%@", "%@", ...vann] }
      ] : term.d;
    default:
      throw new MacroError(p2, `${p2.prim}: unexpected character: ${c2}`);
  }
}
function trimLast(a2, v2) {
  let l2 = a2.length;
  while (l2 > 0 && a2[l2 - 1] === v2) {
    l2--;
  }
  return a2.slice(0, l2);
}
function filterAnnotations(a2) {
  const fields = [];
  const rest = [];
  if (a2 !== void 0) {
    for (const v2 of a2) {
      (v2.length !== 0 && v2[0] === "%" ? fields : rest).push(v2);
    }
  }
  return { fields, rest };
}
function mkPrim({ prim, annots, args }) {
  return Object.assign(Object.assign({ prim }, annots && { annots }), args && { args });
}
const pairRe = /^P[PAI]{3,}R$/;
const unpairRe = /^UNP[PAI]{2,}R$/;
const cadrRe = /^C[AD]{2,}R$/;
const setCadrRe = /^SET_C[AD]+R$/;
const mapCadrRe = /^MAP_C[AD]+R$/;
const diipRe = /^DI{2,}P$/;
const duupRe = /^DU+P$/;
function expandMacros(ex, opt) {
  const proto = (opt === null || opt === void 0 ? void 0 : opt.protocol) || DefaultProtocol;
  function mayRename(annots) {
    return annots !== void 0 ? [{ prim: "RENAME", annots }] : [];
  }
  switch (ex.prim) {
    case "CMPEQ":
    case "CMPNEQ":
    case "CMPLT":
    case "CMPGT":
    case "CMPLE":
    case "CMPGE":
      if (assertArgs$1(ex, 0)) {
        return [{ prim: "COMPARE" }, mkPrim({ prim: ex.prim.slice(3), annots: ex.annots })];
      }
      break;
    case "IFEQ":
    case "IFNEQ":
    case "IFLT":
    case "IFGT":
    case "IFLE":
    case "IFGE":
      if (assertArgs$1(ex, 2)) {
        return [
          { prim: ex.prim.slice(2) },
          mkPrim({ prim: "IF", annots: ex.annots, args: ex.args })
        ];
      }
      break;
    case "IFCMPEQ":
    case "IFCMPNEQ":
    case "IFCMPLT":
    case "IFCMPGT":
    case "IFCMPLE":
    case "IFCMPGE":
      if (assertArgs$1(ex, 2)) {
        return [
          { prim: "COMPARE" },
          { prim: ex.prim.slice(5) },
          mkPrim({ prim: "IF", annots: ex.annots, args: ex.args })
        ];
      }
      break;
    case "FAIL":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [{ prim: "UNIT" }, { prim: "FAILWITH" }];
      }
      break;
    case "ASSERT":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          {
            prim: "IF",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_EQ":
    case "ASSERT_NEQ":
    case "ASSERT_LT":
    case "ASSERT_GT":
    case "ASSERT_LE":
    case "ASSERT_GE":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          { prim: ex.prim.slice(7) },
          {
            prim: "IF",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_CMPEQ":
    case "ASSERT_CMPNEQ":
    case "ASSERT_CMPLT":
    case "ASSERT_CMPGT":
    case "ASSERT_CMPLE":
    case "ASSERT_CMPGE":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          [{ prim: "COMPARE" }, { prim: ex.prim.slice(10) }],
          {
            prim: "IF",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_NONE":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          {
            prim: "IF_NONE",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_SOME":
      if (assertArgs$1(ex, 0)) {
        return [
          {
            prim: "IF_NONE",
            args: [[[{ prim: "UNIT" }, { prim: "FAILWITH" }]], mayRename(ex.annots)]
          }
        ];
      }
      break;
    case "ASSERT_LEFT":
      if (assertArgs$1(ex, 0)) {
        return [
          {
            prim: "IF_LEFT",
            args: [mayRename(ex.annots), [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_RIGHT":
      if (assertArgs$1(ex, 0)) {
        return [
          {
            prim: "IF_LEFT",
            args: [[[{ prim: "UNIT" }, { prim: "FAILWITH" }]], mayRename(ex.annots)]
          }
        ];
      }
      break;
    case "IF_SOME":
      if (assertArgs$1(ex, 2)) {
        return [mkPrim({ prim: "IF_NONE", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
      }
      break;
    case "IF_RIGHT":
      if (assertArgs$1(ex, 2)) {
        return [mkPrim({ prim: "IF_LEFT", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
      }
      break;
    case "CAR":
    case "CDR":
      if (ex.args !== void 0) {
        if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
          const n = parseInt(ex.args[0].int, 10);
          return mkPrim({
            prim: "GET",
            args: [{ int: ex.prim === "CAR" ? String(n * 2 + 1) : String(n * 2) }],
            annots: ex.annots
          });
        }
      } else {
        return ex;
      }
  }
  if (pairRe.test(ex.prim)) {
    if (assertArgs$1(ex, 0)) {
      const { fields, rest } = filterAnnotations(ex.annots);
      const { r: r2 } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (l2, r3, top) => [
        ...l2 || [],
        ...r3 || [],
        top
      ]);
      return r2.map(([v2, a2], i2) => {
        const ann = [
          ...trimLast(a2, null).map((v3) => v3 === null ? "%" : v3),
          ...v2 === 0 && i2 === r2.length - 1 ? rest : []
        ];
        const leaf = mkPrim({ prim: "PAIR", annots: ann.length !== 0 ? ann : void 0 });
        return v2 === 0 ? leaf : {
          prim: "DIP",
          args: v2 === 1 ? [[leaf]] : [{ int: String(v2) }, [leaf]]
        };
      });
    }
  }
  if (unpairRe.test(ex.prim)) {
    if (ProtoInferiorTo$1(proto, Protocol.PtEdo2Zk) && assertArgs$1(ex, 0)) {
      const { r: r2 } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (l2, r3, top) => [
        top,
        ...r3 || [],
        ...l2 || []
      ]);
      return r2.map(([v2, a2]) => {
        const leaf = [
          { prim: "DUP" },
          mkPrim({ prim: "CAR", annots: a2[0] !== null ? [a2[0]] : void 0 }),
          {
            prim: "DIP",
            args: [[mkPrim({ prim: "CDR", annots: a2[1] !== null ? [a2[1]] : void 0 })]]
          }
        ];
        return v2 === 0 ? leaf : {
          prim: "DIP",
          args: v2 === 1 ? [[leaf]] : [{ int: String(v2) }, [leaf]]
        };
      });
    } else {
      if (ex.prim === "UNPAIR") {
        return ex;
      }
      if (assertArgs$1(ex, 0)) {
        const { r: r2 } = parsePairUnpairExpr(ex, ex.prim.slice(3), [], (l2, r3, top) => [
          top,
          ...r3 || [],
          ...l2 || []
        ]);
        return r2.map(([v2]) => {
          const leaf = mkPrim({
            prim: "UNPAIR"
          });
          return v2 === 0 ? leaf : {
            prim: "DIP",
            args: v2 === 1 ? [[leaf]] : [{ int: String(v2) }, [leaf]]
          };
        });
      }
    }
  }
  if (cadrRe.test(ex.prim)) {
    if (assertArgs$1(ex, 0)) {
      const ch2 = [...ex.prim.slice(1, ex.prim.length - 1)];
      return ch2.map((c2, i2) => {
        const ann = i2 === ch2.length - 1 ? ex.annots : void 0;
        switch (c2) {
          case "A":
            return mkPrim({ prim: "CAR", annots: ann });
          case "D":
            return mkPrim({ prim: "CDR", annots: ann });
          default:
            throw new MacroError(ex, `unexpected character: ${c2}`);
        }
      });
    }
  }
  if (setCadrRe.test(ex.prim)) {
    if (assertArgs$1(ex, 0)) {
      const { fields, rest } = filterAnnotations(ex.annots);
      if (fields.length > 1) {
        throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);
      }
      const term = fields.length !== 0 ? {
        a: [
          { prim: "DUP" },
          { prim: "CAR", annots: fields },
          { prim: "DROP" },
          { prim: "CDR", annots: ["@%%"] },
          { prim: "SWAP" },
          { prim: "PAIR", annots: [fields[0], "%@"] }
        ],
        d: [
          { prim: "DUP" },
          { prim: "CDR", annots: fields },
          { prim: "DROP" },
          { prim: "CAR", annots: ["@%%"] },
          { prim: "PAIR", annots: ["%@", fields[0]] }
        ]
      } : {
        a: [
          { prim: "CDR", annots: ["@%%"] },
          { prim: "SWAP" },
          { prim: "PAIR", annots: ["%", "%@"] }
        ],
        d: [
          { prim: "CAR", annots: ["@%%"] },
          { prim: "PAIR", annots: ["%@", "%"] }
        ]
      };
      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);
    }
  }
  if (mapCadrRe.test(ex.prim)) {
    if (assertArgs$1(ex, 1)) {
      const { fields } = filterAnnotations(ex.annots);
      if (fields.length > 1) {
        throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);
      }
      const term = {
        a: [
          { prim: "DUP" },
          { prim: "CDR", annots: ["@%%"] },
          {
            prim: "DIP",
            args: [
              [
                mkPrim({
                  prim: "CAR",
                  annots: fields.length !== 0 ? ["@" + fields[0].slice(1)] : void 0
                }),
                ex.args[0]
              ]
            ]
          },
          { prim: "SWAP" },
          { prim: "PAIR", annots: [fields.length !== 0 ? fields[0] : "%", "%@"] }
        ],
        d: [
          { prim: "DUP" },
          mkPrim({
            prim: "CDR",
            annots: fields.length !== 0 ? ["@" + fields[0].slice(1)] : void 0
          }),
          ex.args[0],
          { prim: "SWAP" },
          { prim: "CAR", annots: ["@%%"] },
          { prim: "PAIR", annots: ["%@", fields.length !== 0 ? fields[0] : "%"] }
        ]
      };
      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);
    }
  }
  if (diipRe.test(ex.prim)) {
    if (assertArgs$1(ex, 1)) {
      let n = 0;
      while (ex.prim[1 + n] === "I") {
        n++;
      }
      return mkPrim({ prim: "DIP", args: [{ int: String(n) }, ex.args[0]] });
    }
  }
  if (duupRe.test(ex.prim)) {
    let n = 0;
    while (ex.prim[1 + n] === "U") {
      n++;
    }
    if (ProtoInferiorTo$1(proto, Protocol.PtEdo2Zk)) {
      if (n === 1) {
        if (ex.args === void 0) {
          return ex;
        }
        if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
          n = parseInt(ex.args[0].int, 10);
        }
      } else {
        assertArgs$1(ex, 0);
      }
      if (n === 1) {
        return [mkPrim({ prim: "DUP", annots: ex.annots })];
      } else if (n === 2) {
        return [
          {
            prim: "DIP",
            args: [[mkPrim({ prim: "DUP", annots: ex.annots })]]
          },
          { prim: "SWAP" }
        ];
      } else {
        return [
          {
            prim: "DIP",
            args: [{ int: String(n - 1) }, [mkPrim({ prim: "DUP", annots: ex.annots })]]
          },
          {
            prim: "DIG",
            args: [{ int: String(n) }]
          }
        ];
      }
    } else {
      if (n === 1) {
        return ex;
      }
      if (assertArgs$1(ex, 0)) {
        return mkPrim({ prim: "DUP", args: [{ int: String(n) }], annots: ex.annots });
      }
    }
  }
  return ex;
}
function expandGlobalConstants(ex, hashAndValue) {
  if (ex.args !== void 0 && ex.args.length === 1 && "string" in ex.args[0] && ex.args[0].string in hashAndValue) {
    return hashAndValue[ex.args[0].string];
  }
  return ex;
}
class MichelineParseError extends Error {
  /**
   * @param token A token caused the error
   * @param message An error message
   */
  constructor(token, message) {
    super(message);
    this.token = token;
    Object.setPrototypeOf(this, MichelineParseError.prototype);
  }
}
class JSONParseError extends Error {
  /**
   * @param node A node caused the error
   * @param message An error message
   */
  constructor(node2, message) {
    super(message);
    this.node = node2;
    Object.setPrototypeOf(this, JSONParseError.prototype);
  }
}
const errEOF = new MichelineParseError(null, "Unexpected EOF");
function isAnnotation(tok) {
  return tok.t === Literal.Ident && (tok.v[0] === "@" || tok.v[0] === "%" || tok.v[0] === ":");
}
const intRe = new RegExp("^-?[0-9]+$");
const bytesRe = new RegExp("^([0-9a-fA-F]{2})*$");
class Parser {
  constructor(opt) {
    this.opt = opt;
  }
  expand(ex) {
    var _a2, _b, _c;
    if (((_a2 = this.opt) === null || _a2 === void 0 ? void 0 : _a2.expandGlobalConstant) !== void 0 && ex.prim === "constant") {
      const ret = expandGlobalConstants(ex, this.opt.expandGlobalConstant);
      if (ret !== ex) {
        ret[sourceReference] = Object.assign(Object.assign({}, ex[sourceReference] || { first: 0, last: 0 }), { globalConstant: ex });
      }
      return ret;
    }
    if (((_b = this.opt) === null || _b === void 0 ? void 0 : _b.expandMacros) !== void 0 ? (_c = this.opt) === null || _c === void 0 ? void 0 : _c.expandMacros : true) {
      const ret = expandMacros(ex, this.opt);
      if (ret !== ex) {
        ret[sourceReference] = Object.assign(Object.assign({}, ex[sourceReference] || { first: 0, last: 0 }), { macro: ex });
      }
      return ret;
    } else {
      return ex;
    }
  }
  parseListExpr(scanner, start2) {
    var _a2;
    const ref = {
      first: start2.first,
      last: start2.last
    };
    const expectBracket = start2.t === "(";
    let tok;
    if (expectBracket) {
      tok = scanner.next();
      if (tok.done) {
        throw errEOF;
      }
      ref.last = tok.value.last;
    } else {
      tok = { value: start2 };
    }
    if (tok.value.t !== Literal.Ident) {
      throw new MichelineParseError(tok.value, `not an identifier: ${tok.value.v}`);
    }
    const ret = {
      prim: tok.value.v,
      [sourceReference]: ref
    };
    for (; ; ) {
      const tok2 = scanner.next();
      if (tok2.done) {
        if (expectBracket) {
          throw errEOF;
        }
        break;
      } else if (tok2.value.t === ")") {
        if (!expectBracket) {
          throw new MichelineParseError(tok2.value, "unexpected closing bracket");
        }
        ref.last = tok2.value.last;
        break;
      } else if (isAnnotation(tok2.value)) {
        ret.annots = ret.annots || [];
        ret.annots.push(tok2.value.v);
        ref.last = tok2.value.last;
      } else {
        ret.args = ret.args || [];
        const arg = this.parseExpr(scanner, tok2.value);
        ref.last = ((_a2 = arg[sourceReference]) === null || _a2 === void 0 ? void 0 : _a2.last) || ref.last;
        ret.args.push(arg);
      }
    }
    return this.expand(ret);
  }
  parseArgs(scanner, start2) {
    var _a2;
    const ref = {
      first: start2.first,
      last: start2.last
    };
    const p2 = {
      prim: start2.v,
      [sourceReference]: ref
    };
    for (; ; ) {
      const t = scanner.next();
      if (t.done || t.value.t === "}" || t.value.t === ";") {
        return [p2, t];
      }
      if (isAnnotation(t.value)) {
        ref.last = t.value.last;
        p2.annots = p2.annots || [];
        p2.annots.push(t.value.v);
      } else {
        const arg = this.parseExpr(scanner, t.value);
        ref.last = ((_a2 = arg[sourceReference]) === null || _a2 === void 0 ? void 0 : _a2.last) || ref.last;
        p2.args = p2.args || [];
        p2.args.push(arg);
      }
    }
  }
  parseSequenceExpr(scanner, start2) {
    var _a2, _b;
    const ref = {
      first: start2.first,
      last: start2.last
    };
    const seq = [];
    seq[sourceReference] = ref;
    const expectBracket = start2.t === "{";
    let tok = start2.t === "{" ? null : { value: start2 };
    for (; ; ) {
      if (tok === null) {
        tok = scanner.next();
        if (!tok.done) {
          ref.last = tok.value.last;
        }
      }
      if (tok.done) {
        if (expectBracket) {
          throw errEOF;
        } else {
          return seq;
        }
      }
      if (tok.value.t === "}") {
        if (!expectBracket) {
          throw new MichelineParseError(tok.value, "unexpected closing bracket");
        } else {
          return seq;
        }
      } else if (tok.value.t === Literal.Ident) {
        const [itm, n] = this.parseArgs(scanner, tok.value);
        ref.last = ((_a2 = itm[sourceReference]) === null || _a2 === void 0 ? void 0 : _a2.last) || ref.last;
        seq.push(this.expand(itm));
        tok = n;
      } else {
        const ex = this.parseExpr(scanner, tok.value);
        ref.last = ((_b = ex[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;
        seq.push(ex);
        tok = null;
      }
      if (tok === null) {
        tok = scanner.next();
        if (!tok.done) {
          ref.last = tok.value.last;
        }
      }
      if (!tok.done && tok.value.t === ";") {
        tok = null;
      }
    }
  }
  parseExpr(scanner, tok) {
    switch (tok.t) {
      case Literal.Ident:
        return this.expand({
          prim: tok.v,
          [sourceReference]: { first: tok.first, last: tok.last }
        });
      case Literal.Number:
        return { int: tok.v, [sourceReference]: { first: tok.first, last: tok.last } };
      case Literal.String:
        return {
          string: JSON.parse(tok.v),
          [sourceReference]: { first: tok.first, last: tok.last }
        };
      case Literal.Bytes:
        return { bytes: tok.v.slice(2), [sourceReference]: { first: tok.first, last: tok.last } };
      case "{":
        return this.parseSequenceExpr(scanner, tok);
      default:
        return this.parseListExpr(scanner, tok);
    }
  }
  /**
   * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
   */
  parseSequence(src2) {
    if (typeof src2 !== "string") {
      throw new TypeError(`string type was expected, got ${typeof src2} instead`);
    }
    const scanner = scan(src2);
    const tok = scanner.next();
    if (tok.done) {
      return null;
    }
    return this.parseSequenceExpr(scanner, tok.value);
  }
  /**
   * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
   * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
   * @returns An AST node or null for empty document.
   */
  parseList(src2) {
    if (typeof src2 !== "string") {
      throw new TypeError(`string type was expected, got ${typeof src2} instead`);
    }
    const scanner = scan(src2);
    const tok = scanner.next();
    if (tok.done) {
      return null;
    }
    return this.parseListExpr(scanner, tok.value);
  }
  /**
   * Parse any Michelson expression
   * @param src A Michelson expression such as `(Pair {Elt "0" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`
   * @returns An AST node or null for empty document.
   */
  parseMichelineExpression(src2) {
    if (typeof src2 !== "string") {
      throw new TypeError(`string type was expected, got ${typeof src2} instead`);
    }
    const scanner = scan(src2);
    const tok = scanner.next();
    if (tok.done) {
      return null;
    }
    return this.parseExpr(scanner, tok.value);
  }
  /**
   * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
   * An alias for `parseSequence`
   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
   */
  parseScript(src2) {
    return this.parseSequence(src2);
  }
  /**
   * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
   * An alias for `parseList`
   * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
   * @returns An AST node or null for empty document.
   */
  parseData(src2) {
    return this.parseList(src2);
  }
  /**
   * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).
   * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`
   */
  parseJSON(src2) {
    if (typeof src2 !== "object") {
      throw new TypeError(`object type was expected, got ${typeof src2} instead`);
    }
    if (Array.isArray(src2)) {
      const ret = [];
      for (const n of src2) {
        if (n === null || typeof n !== "object") {
          throw new JSONParseError(n, `unexpected sequence element: ${n}`);
        }
        ret.push(this.parseJSON(n));
      }
      return ret;
    } else if ("prim" in src2) {
      const p2 = src2;
      if (typeof p2.prim === "string" && (p2.annots === void 0 || Array.isArray(p2.annots)) && (p2.args === void 0 || Array.isArray(p2.args))) {
        const ret = {
          prim: p2.prim
        };
        if (p2.annots !== void 0) {
          for (const a2 of p2.annots) {
            if (typeof a2 !== "string") {
              throw new JSONParseError(a2, `string expected: ${a2}`);
            }
          }
          ret.annots = p2.annots;
        }
        if (p2.args !== void 0) {
          ret.args = [];
          for (const a2 of p2.args) {
            if (a2 === null || typeof a2 !== "object") {
              throw new JSONParseError(a2, `unexpected argument: ${a2}`);
            }
            ret.args.push(this.parseJSON(a2));
          }
        }
        return this.expand(ret);
      }
      throw new JSONParseError(src2, `malformed prim expression: ${src2}`);
    } else if ("string" in src2) {
      if (typeof src2.string === "string") {
        return { string: src2.string };
      }
      throw new JSONParseError(src2, `malformed string literal: ${src2}`);
    } else if ("int" in src2) {
      if (typeof src2.int === "string" && intRe.test(src2.int)) {
        return { int: src2.int };
      }
      throw new JSONParseError(src2, `malformed int literal: ${src2}`);
    } else if ("bytes" in src2) {
      if (typeof src2.bytes === "string" && bytesRe.test(src2.bytes)) {
        return { bytes: src2.bytes };
      }
      throw new JSONParseError(src2, `malformed bytes literal: ${src2}`);
    } else {
      throw new JSONParseError(src2, `unexpected object: ${src2}`);
    }
  }
}
const H = [
  1779033703 | 0,
  3144134277 | 0,
  1013904242 | 0,
  2773480762 | 0,
  1359893119 | 0,
  2600822924 | 0,
  528734635 | 0,
  1541459225 | 0
];
const K = [
  1116352408 | 0,
  1899447441 | 0,
  3049323471 | 0,
  3921009573 | 0,
  961987163 | 0,
  1508970993 | 0,
  2453635748 | 0,
  2870763221 | 0,
  3624381080 | 0,
  310598401 | 0,
  607225278 | 0,
  1426881987 | 0,
  1925078388 | 0,
  2162078206 | 0,
  2614888103 | 0,
  3248222580 | 0,
  3835390401 | 0,
  4022224774 | 0,
  264347078 | 0,
  604807628 | 0,
  770255983 | 0,
  1249150122 | 0,
  1555081692 | 0,
  1996064986 | 0,
  2554220882 | 0,
  2821834349 | 0,
  2952996808 | 0,
  3210313671 | 0,
  3336571891 | 0,
  3584528711 | 0,
  113926993 | 0,
  338241895 | 0,
  666307205 | 0,
  773529912 | 0,
  1294757372 | 0,
  1396182291 | 0,
  1695183700 | 0,
  1986661051 | 0,
  2177026350 | 0,
  2456956037 | 0,
  2730485921 | 0,
  2820302411 | 0,
  3259730800 | 0,
  3345764771 | 0,
  3516065817 | 0,
  3600352804 | 0,
  4094571909 | 0,
  275423344 | 0,
  430227734 | 0,
  506948616 | 0,
  659060556 | 0,
  883997877 | 0,
  958139571 | 0,
  1322822218 | 0,
  1537002063 | 0,
  1747873779 | 0,
  1955562222 | 0,
  2024104815 | 0,
  2227730452 | 0,
  2361852424 | 0,
  2428436474 | 0,
  2756734187 | 0,
  3204031479 | 0,
  3329325298 | 0
];
class Base58DecodingError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "Base58DecodingError";
  }
}
class InvalidMessageError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidMessageError";
  }
}
function sha256(msg) {
  const r2 = (msg.length + 9) % 64;
  const pad3 = r2 === 0 ? 0 : 64 - r2;
  if (msg.length > 268435455) {
    throw new InvalidMessageError(`SHA-256 -- message length is too big: ${msg.length}`);
  }
  const l2 = msg.length << 3;
  const buffer2 = [
    ...msg,
    128,
    ...new Array(pad3).fill(0),
    0,
    0,
    0,
    0,
    l2 >> 24 & 255,
    l2 >> 16 & 255,
    l2 >> 8 & 255,
    l2 & 255
  ];
  function ror(x2, n) {
    return x2 >>> n | x2 << 32 - n;
  }
  const h2 = [...H];
  const w2 = new Array(64);
  const v2 = new Array(8);
  for (let offset = 0; offset < buffer2.length; offset += 64) {
    let q = offset;
    let i2 = 0;
    while (i2 < 16) {
      w2[i2] = buffer2[q] << 24 | buffer2[q + 1] << 16 | buffer2[q + 2] << 8 | buffer2[q + 3];
      q += 4;
      i2++;
    }
    while (i2 < 64) {
      const s0 = ror(w2[i2 - 15], 7) ^ ror(w2[i2 - 15], 18) ^ w2[i2 - 15] >>> 3;
      const s1 = ror(w2[i2 - 2], 17) ^ ror(w2[i2 - 2], 19) ^ w2[i2 - 2] >>> 10;
      w2[i2] = (s1 | 0) + w2[i2 - 7] + s0 + w2[i2 - 16] | 0;
      i2++;
    }
    for (let i3 = 0; i3 < 8; i3++) {
      v2[i3] = h2[i3];
    }
    for (let i3 = 0; i3 < 64; i3++) {
      const b0 = ror(v2[0], 2) ^ ror(v2[0], 13) ^ ror(v2[0], 22);
      const b1 = ror(v2[4], 6) ^ ror(v2[4], 11) ^ ror(v2[4], 25);
      const t1 = v2[7] + b1 + (v2[4] & v2[5] ^ ~v2[4] & v2[6]) + K[i3] + w2[i3] | 0;
      const t2 = b0 + (v2[0] & v2[1] ^ v2[0] & v2[2] ^ v2[1] & v2[2]) | 0;
      v2[7] = v2[6];
      v2[6] = v2[5];
      v2[5] = v2[4];
      v2[4] = v2[3] + t1 | 0;
      v2[3] = v2[2];
      v2[2] = v2[1];
      v2[1] = v2[0];
      v2[0] = t1 + t2 | 0;
    }
    for (let i3 = 0; i3 < 8; i3++) {
      h2[i3] = h2[i3] + v2[i3] | 0;
    }
  }
  const digest9 = [];
  for (const v3 of h2) {
    digest9.push(v3 >> 24 & 255);
    digest9.push(v3 >> 16 & 255);
    digest9.push(v3 >> 8 & 255);
    digest9.push(v3 & 255);
  }
  return digest9;
}
const base58alphabetFwd = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  -1,
  17,
  18,
  19,
  20,
  21,
  -1,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  -1,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57
];
function byteAt(src2, i2) {
  const c2 = src2.charCodeAt(i2) - 49;
  if (c2 >= base58alphabetFwd.length || base58alphabetFwd[c2] === -1) {
    throw new Base58DecodingError(`Unexpected character at position ${i2}: ${src2[i2]}`);
  }
  return base58alphabetFwd[c2];
}
function decodeBase58(src2) {
  const acc = [];
  let i2 = 0;
  while (i2 < src2.length && byteAt(src2, i2) === 0) {
    i2++;
  }
  let zeros2 = i2;
  while (i2 < src2.length) {
    let carry = byteAt(src2, i2++);
    let ii = 0;
    while (carry !== 0 || ii < acc.length) {
      const m2 = (acc[ii] || 0) * 58 + carry;
      acc[ii++] = m2 % 256;
      carry = Math.floor(m2 / 256);
    }
  }
  while (zeros2-- > 0) {
    acc.push(0);
  }
  return acc.reverse();
}
function decodeBase58Check(src2) {
  const buffer2 = decodeBase58(src2);
  if (buffer2.length < 4) {
    throw new Base58DecodingError(`Data is too short ${buffer2.length}`);
  }
  const data2 = buffer2.slice(0, buffer2.length - 4);
  const sum = buffer2.slice(buffer2.length - 4);
  const computed = sha256(sha256(data2));
  if (sum[0] !== computed[0] || sum[1] !== computed[1] || sum[2] !== computed[2] || sum[3] !== computed[3]) {
    throw new Base58DecodingError("Invalid checksum");
  }
  return data2;
}
class InvalidContractError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidContractError";
  }
}
class InvalidTypeExpressionError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidTypeExpressionError";
  }
}
class InvalidDataExpressionError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidDataExpressionError";
  }
}
class InvalidEntrypointError extends Error {
  constructor(entrypoint) {
    super(`Contract has no entrypoint named: '${entrypoint}'`);
    this.entrypoint = entrypoint;
    this.name = "InvalidEntrypointError";
  }
}
class LongIntegerError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "LongIntegerError";
  }
}
class MichelsonError extends Error {
  /**
   * @param val Value of a AST node caused the error
   * @param path Path to a node caused the error
   * @param message An error message
   */
  constructor(val, message) {
    super(message);
    this.val = val;
    Object.setPrototypeOf(this, MichelsonError.prototype);
  }
}
class MichelsonTypeError extends MichelsonError {
  /**
   * @param val Value of a type node caused the error
   * @param data Value of a data node caused the error
   * @param message An error message
   */
  constructor(val, data2, message) {
    super(val, message);
    if (data2 !== void 0) {
      this.data = data2;
    }
    Object.setPrototypeOf(this, MichelsonTypeError.prototype);
  }
}
class LongInteger {
  constructor(arg) {
    this.neg = false;
    this.buf = [];
    if (arg === void 0) {
      return;
    }
    if (typeof arg === "string") {
      for (let i2 = 0; i2 < arg.length; i2++) {
        const c2 = arg.charCodeAt(i2);
        if (i2 === 0 && c2 === 45) {
          this.neg = true;
        } else {
          if (c2 < 48 || c2 > 57) {
            throw new LongIntegerError(`unexpected character in integer constant: ${arg[i2]}`);
          }
          this.append(c2 - 48);
        }
      }
    } else if (arg < 0) {
      this.neg = true;
      this.append(-arg);
    } else {
      this.append(arg);
    }
  }
  append(c2) {
    let i2 = 0;
    while (c2 !== 0 || i2 < this.buf.length) {
      const m2 = (this.buf[i2] || 0) * 10 + c2;
      this.buf[i2++] = m2 % 256;
      c2 = Math.floor(m2 / 256);
    }
  }
  cmp(arg) {
    if (this.neg !== arg.neg) {
      return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);
    } else {
      let ret = 0;
      if (this.buf.length !== arg.buf.length) {
        ret = this.buf.length < arg.buf.length ? -1 : 1;
      } else if (this.buf.length !== 0) {
        let i2 = arg.buf.length - 1;
        while (i2 >= 0 && this.buf[i2] === arg.buf[i2]) {
          i2--;
        }
        ret = i2 < 0 ? 0 : this.buf[i2] < arg.buf[i2] ? -1 : 1;
      }
      return !this.neg ? ret : ret === 0 ? 0 : -ret;
    }
  }
  get sign() {
    return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;
  }
}
function parseBytes(s2) {
  const ret = [];
  for (let i2 = 0; i2 < s2.length; i2 += 2) {
    const x2 = parseInt(s2.slice(i2, i2 + 2), 16);
    if (Number.isNaN(x2)) {
      return null;
    }
    ret.push(x2);
  }
  return ret;
}
function isDecimal(x2) {
  try {
    new LongInteger(x2);
    return true;
  } catch (_a2) {
    return false;
  }
}
function isNatural(x2) {
  try {
    return new LongInteger(x2).sign >= 0;
  } catch (_a2) {
    return false;
  }
}
const annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z.%@]*)?)$/;
function unpackAnnotations(p2, opt) {
  if (Array.isArray(p2)) {
    return {};
  }
  let field;
  let type;
  let vars;
  if (p2.annots !== void 0) {
    for (const v2 of p2.annots) {
      if (v2.length !== 0) {
        if (!annRe.test(v2) || !(opt === null || opt === void 0 ? void 0 : opt.specialVar) && (v2 === "@%" || v2 === "@%%") || !(opt === null || opt === void 0 ? void 0 : opt.specialFields) && v2 === "%@") {
          throw new MichelsonError(p2, `${p2.prim}: unexpected annotation: ${v2}`);
        }
        switch (v2[0]) {
          case "%":
            if ((opt === null || opt === void 0 ? void 0 : opt.emptyFields) || v2.length > 1) {
              field = field || [];
              field.push(v2);
            }
            break;
          case ":":
            if (v2.length > 1) {
              type = type || [];
              type.push(v2);
            }
            break;
          case "@":
            if ((opt === null || opt === void 0 ? void 0 : opt.emptyVar) || v2.length > 1) {
              vars = vars || [];
              vars.push(v2);
            }
            break;
        }
      }
    }
  }
  return { f: field, t: type, v: vars };
}
const tezosPrefix = {
  BlockHash: [32, [1, 52]],
  OperationHash: [32, [5, 116]],
  OperationListHash: [32, [133, 233]],
  OperationListListHash: [32, [29, 159, 109]],
  ProtocolHash: [32, [2, 170]],
  ContextHash: [32, [79, 199]],
  ED25519PublicKeyHash: [20, [6, 161, 159]],
  SECP256K1PublicKeyHash: [20, [6, 161, 161]],
  P256PublicKeyHash: [20, [6, 161, 164]],
  ContractHash: [20, [2, 90, 121]],
  CryptoboxPublicKeyHash: [16, [153, 103]],
  ED25519Seed: [32, [13, 15, 58, 7]],
  ED25519PublicKey: [32, [13, 15, 37, 217]],
  SECP256K1SecretKey: [32, [17, 162, 224, 201]],
  P256SecretKey: [32, [16, 81, 238, 189]],
  ED25519EncryptedSeed: [56, [7, 90, 60, 179, 41]],
  SECP256K1EncryptedSecretKey: [56, [9, 237, 241, 174, 150]],
  P256EncryptedSecretKey: [56, [9, 48, 57, 115, 171]],
  SECP256K1PublicKey: [33, [3, 254, 226, 86]],
  P256PublicKey: [33, [3, 178, 139, 127]],
  SECP256K1Scalar: [33, [38, 248, 136]],
  SECP256K1Element: [33, [5, 92, 0]],
  ED25519SecretKey: [64, [43, 246, 78, 7]],
  ED25519Signature: [64, [9, 245, 205, 134, 18]],
  SECP256K1Signature: [64, [13, 115, 101, 19, 63]],
  P256Signature: [64, [54, 240, 44, 52]],
  GenericSignature: [64, [4, 130, 43]],
  ChainID: [4, [87, 82, 0]],
  RollupAddress: [20, [1, 128, 120, 31]],
  TxRollupL2Address: [20, [6, 161, 166]]
};
function checkDecodeTezosID(id2, ...types) {
  const buf = decodeBase58Check(id2);
  for (const t of types) {
    const [plen, p2] = tezosPrefix[t];
    if (buf.length === plen + p2.length) {
      let i2 = 0;
      while (i2 < p2.length && buf[i2] === p2[i2]) {
        i2++;
      }
      if (i2 === p2.length) {
        return [t, buf.slice(p2.length)];
      }
    }
  }
  return null;
}
function unpackComb(id2, v2) {
  const vv = v2;
  const args = Array.isArray(vv) ? vv : vv.args;
  if (args.length === 2) {
    const ret = id2 === "pair" ? {
      prim: "pair",
      args
    } : {
      prim: "Pair",
      args
    };
    return ret;
  }
  return Object.assign(Object.assign({}, Array.isArray(vv) ? { prim: id2 } : vv), { args: [
    args[0],
    {
      prim: id2,
      args: args.slice(1)
    }
  ] });
}
function isPairType(t) {
  return Array.isArray(t) || t.prim === "pair";
}
function isPairData(d2) {
  return Array.isArray(d2) || "prim" in d2 && d2.prim === "Pair";
}
const rfc3339Re = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;
function parseDate(a2) {
  if ("string" in a2) {
    if (isNatural(a2.string)) {
      return new Date(parseInt(a2.string, 10));
    } else if (rfc3339Re.test(a2.string)) {
      const x2 = new Date(a2.string);
      if (!Number.isNaN(x2.valueOf)) {
        return x2;
      }
    }
  } else if (isDecimal(a2.int)) {
    return new Date(parseInt(a2.int, 10));
  }
  return null;
}
const maxViewNameLength = 31;
const noArgInstructionIDs = {
  ABS: true,
  ADD: true,
  ADDRESS: true,
  AMOUNT: true,
  AND: true,
  APPLY: true,
  BALANCE: true,
  BLAKE2B: true,
  CAR: true,
  CDR: true,
  CHAIN_ID: true,
  CHECK_SIGNATURE: true,
  COMPARE: true,
  CONCAT: true,
  CONS: true,
  EDIV: true,
  EQ: true,
  EXEC: true,
  FAILWITH: true,
  GE: true,
  GET_AND_UPDATE: true,
  GT: true,
  HASH_KEY: true,
  IMPLICIT_ACCOUNT: true,
  INT: true,
  ISNAT: true,
  JOIN_TICKETS: true,
  KECCAK: true,
  LE: true,
  LEVEL: true,
  LSL: true,
  LSR: true,
  LT: true,
  MEM: true,
  MUL: true,
  NEG: true,
  NEQ: true,
  NEVER: true,
  NOT: true,
  NOW: true,
  OR: true,
  PACK: true,
  PAIRING_CHECK: true,
  READ_TICKET: true,
  SAPLING_VERIFY_UPDATE: true,
  SELF: true,
  SELF_ADDRESS: true,
  SENDER: true,
  SET_DELEGATE: true,
  SHA256: true,
  SHA3: true,
  SHA512: true,
  SIZE: true,
  SLICE: true,
  SOME: true,
  SOURCE: true,
  SPLIT_TICKET: true,
  SUB: true,
  SWAP: true,
  TICKET: true,
  TICKET_DEPRECATED: true,
  TOTAL_VOTING_POWER: true,
  TRANSFER_TOKENS: true,
  UNIT: true,
  VOTING_POWER: true,
  XOR: true,
  RENAME: true,
  OPEN_CHEST: true,
  SUB_MUTEZ: true,
  MIN_BLOCK_TIME: true
};
const instructionIDs = Object.assign({}, noArgInstructionIDs, {
  CONTRACT: true,
  CREATE_CONTRACT: true,
  DIG: true,
  DIP: true,
  DROP: true,
  DUG: true,
  DUP: true,
  EMIT: true,
  EMPTY_BIG_MAP: true,
  EMPTY_MAP: true,
  EMPTY_SET: true,
  GET: true,
  IF: true,
  IF_CONS: true,
  IF_LEFT: true,
  IF_NONE: true,
  ITER: true,
  LAMBDA: true,
  LAMBDA_REC: true,
  LEFT: true,
  LOOP: true,
  LOOP_LEFT: true,
  MAP: true,
  NIL: true,
  NONE: true,
  PAIR: true,
  PUSH: true,
  RIGHT: true,
  SAPLING_EMPTY_STATE: true,
  UNPACK: true,
  UNPAIR: true,
  UPDATE: true,
  CAST: true,
  VIEW: true
});
const simpleComparableTypeIDs = {
  unit: true,
  never: true,
  bool: true,
  int: true,
  nat: true,
  string: true,
  chain_id: true,
  bytes: true,
  mutez: true,
  key_hash: true,
  key: true,
  signature: true,
  timestamp: true,
  address: true,
  tx_rollup_l2_address: true
};
const typeIDs = Object.assign({}, simpleComparableTypeIDs, {
  or: true,
  pair: true,
  set: true,
  big_map: true,
  contract: true,
  lambda: true,
  list: true,
  map: true,
  operation: true,
  option: true,
  bls12_381_g1: true,
  bls12_381_g2: true,
  bls12_381_fr: true,
  sapling_transaction: true,
  sapling_transaction_deprecated: true,
  sapling_state: true,
  ticket: true,
  chest_key: true,
  chest: true
});
class MichelsonValidationError extends MichelsonError {
  /**
   * @param val Value of a node caused the error
   * @param message An error message
   */
  constructor(val, message) {
    super(val, message);
    this.val = val;
    Object.setPrototypeOf(this, MichelsonValidationError.prototype);
  }
}
function isPrim$1(ex) {
  return "prim" in ex;
}
function isPrimOrSeq(ex) {
  return Array.isArray(ex) || "prim" in ex;
}
function assertPrim(ex) {
  if (isPrim$1(ex)) {
    return true;
  }
  throw new MichelsonValidationError(ex, "prim expression expected");
}
function assertSeq(ex) {
  if (Array.isArray(ex)) {
    return true;
  }
  throw new MichelsonValidationError(ex, "sequence expression expected");
}
function assertPrimOrSeq(ex) {
  if (isPrimOrSeq(ex)) {
    return true;
  }
  throw new MichelsonValidationError(ex, "prim or sequence expression expected");
}
function assertNatural(i2) {
  if (i2.int[0] === "-") {
    throw new MichelsonValidationError(i2, "natural number expected");
  }
}
function assertIntLiteral(ex) {
  if ("int" in ex) {
    return true;
  }
  throw new MichelsonValidationError(ex, "int literal expected");
}
function assertStringLiteral(ex) {
  if ("string" in ex) {
    return true;
  }
  throw new MichelsonValidationError(ex, "string literal expected");
}
function assertArgs(ex, n) {
  var _a2;
  if (n === 0 && ex.args === void 0 || ((_a2 = ex.args) === null || _a2 === void 0 ? void 0 : _a2.length) === n) {
    return true;
  }
  throw new MichelsonValidationError(ex, `${n} arguments expected`);
}
function assertMichelsonInstruction(ex) {
  var _a2, _b;
  if (Array.isArray(ex)) {
    for (const n of ex) {
      if (!Array.isArray(n) && !isPrim$1(n)) {
        throw new MichelsonValidationError(ex, "sequence or prim expected");
      }
      assertMichelsonInstruction(n);
    }
    return true;
  }
  if (assertPrim(ex)) {
    if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {
      assertArgs(ex, 0);
      return true;
    }
    switch (ex.prim) {
      case "DROP":
      case "PAIR":
      case "UNPAIR":
      case "DUP":
      case "UPDATE":
      case "GET":
        if (ex.args !== void 0 && assertArgs(ex, 1)) {
          if (assertIntLiteral(ex.args[0])) {
            assertNatural(ex.args[0]);
          }
        }
        break;
      case "DIG":
      case "DUG":
      case "SAPLING_EMPTY_STATE":
        if (assertArgs(ex, 1)) {
          if (assertIntLiteral(ex.args[0])) {
            assertNatural(ex.args[0]);
          }
        }
        break;
      case "NONE":
      case "LEFT":
      case "RIGHT":
      case "NIL":
      case "CAST":
        if (assertArgs(ex, 1)) {
          assertMichelsonType(ex.args[0]);
        }
        break;
      case "UNPACK":
        if (assertArgs(ex, 1)) {
          assertMichelsonPackableType(ex.args[0]);
        }
        break;
      case "CONTRACT":
        if (assertArgs(ex, 1)) {
          assertMichelsonPassableType(ex.args[0]);
        }
        break;
      case "IF_NONE":
      case "IF_LEFT":
      case "IF_CONS":
      case "IF":
        if (assertArgs(ex, 2)) {
          if (assertSeq(ex.args[0])) {
            assertMichelsonInstruction(ex.args[0]);
          }
          if (assertSeq(ex.args[1])) {
            assertMichelsonInstruction(ex.args[1]);
          }
        }
        break;
      case "MAP":
      case "ITER":
      case "LOOP":
      case "LOOP_LEFT":
        if (assertArgs(ex, 1)) {
          assertMichelsonInstruction(ex.args[0]);
        }
        break;
      case "CREATE_CONTRACT":
        if (assertArgs(ex, 1)) {
          assertMichelsonContract(ex.args[0]);
        }
        break;
      case "DIP":
        if (((_a2 = ex.args) === null || _a2 === void 0 ? void 0 : _a2.length) === 2) {
          if (assertIntLiteral(ex.args[0])) {
            assertNatural(ex.args[0]);
          }
          if (assertSeq(ex.args[1])) {
            assertMichelsonInstruction(ex.args[1]);
          }
        } else if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 1) {
          if (assertSeq(ex.args[0])) {
            assertMichelsonInstruction(ex.args[0]);
          }
        } else {
          throw new MichelsonValidationError(ex, "1 or 2 arguments expected");
        }
        break;
      case "PUSH":
        if (assertArgs(ex, 2)) {
          assertMichelsonPushableType(ex.args[0]);
          assertMichelsonData(ex.args[1]);
        }
        break;
      case "EMPTY_SET":
        if (assertArgs(ex, 1)) {
          assertMichelsonComparableType(ex.args[0]);
        }
        break;
      case "EMPTY_MAP":
        if (assertArgs(ex, 2)) {
          assertMichelsonComparableType(ex.args[0]);
          assertMichelsonType(ex.args[1]);
        }
        break;
      case "EMPTY_BIG_MAP":
        if (assertArgs(ex, 2)) {
          assertMichelsonComparableType(ex.args[0]);
          assertMichelsonBigMapStorableType(ex.args[1]);
        }
        break;
      case "LAMBDA_REC":
      case "LAMBDA":
        if (assertArgs(ex, 3)) {
          assertMichelsonType(ex.args[0]);
          assertMichelsonType(ex.args[1]);
          if (assertSeq(ex.args[2])) {
            assertMichelsonInstruction(ex.args[2]);
          }
        }
        break;
      case "VIEW":
        if (assertArgs(ex, 2)) {
          if (assertStringLiteral(ex.args[0])) {
            assertViewNameValid(ex.args[0]);
          }
          if (assertMichelsonType(ex.args[1])) {
            assertMichelsonPushableType(ex.args[1]);
          }
        }
        break;
      case "EMIT":
        if (ex.args && ex.args.length > 0) {
          assertArgs(ex, 1);
        } else {
          assertArgs(ex, 0);
        }
        break;
      default:
        throw new MichelsonValidationError(ex, "instruction expected");
    }
  }
  return true;
}
function assertMichelsonComparableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (Array.isArray(ex) || ex.prim === "pair" || ex.prim === "or" || ex.prim === "option") {
      traverseType(ex, (ex2) => assertMichelsonComparableType(ex2));
    } else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {
      throw new MichelsonValidationError(ex, `${ex.prim}: type is not comparable`);
    }
  }
  return true;
}
function assertMichelsonPackableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim$1(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "big_map" || ex.prim === "operation" || ex.prim === "sapling_state" || ex.prim === "ticket") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside PACK/UNPACK instructions`);
      }
      traverseType(ex, (ex2) => assertMichelsonPackableType(ex2));
    }
  }
  return true;
}
function assertMichelsonPushableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim$1(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "big_map" || ex.prim === "operation" || ex.prim === "sapling_state" || ex.prim === "ticket" || ex.prim === "contract") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be pushed`);
      }
      traverseType(ex, (ex2) => assertMichelsonPushableType(ex2));
    }
  }
  return true;
}
function assertMichelsonStorableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim$1(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "operation" || ex.prim === "contract") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a storage`);
      }
      traverseType(ex, (ex2) => assertMichelsonStorableType(ex2));
    }
  }
  return true;
}
function assertMichelsonPassableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim$1(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "operation") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a parameter`);
      }
      traverseType(ex, (ex2) => assertMichelsonPassableType(ex2));
    }
  }
  return true;
}
function assertMichelsonBigMapStorableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim$1(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "big_map" || ex.prim === "operation" || ex.prim === "sapling_state") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside a big_map`);
      }
      traverseType(ex, (ex2) => assertMichelsonBigMapStorableType(ex2));
    }
  }
  return true;
}
const viewRe = new RegExp("^[a-zA-Z0-9_.%@]*$");
function assertViewNameValid(name2) {
  if (name2.string.length > maxViewNameLength) {
    throw new MichelsonValidationError(name2, `view name too long: ${name2.string}`);
  }
  if (!viewRe.test(name2.string)) {
    throw new MichelsonValidationError(name2, `invalid character(s) in view name: ${name2.string}`);
  }
}
function assertMichelsonType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim$1(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {
        throw new MichelsonValidationError(ex, "type expected");
      }
      traverseType(ex, (ex2) => assertMichelsonType(ex2));
    }
  }
  return true;
}
function traverseType(ex, cb) {
  if (Array.isArray(ex) || ex.prim === "pair") {
    const args = Array.isArray(ex) ? ex : ex.args;
    if (args === void 0 || args.length < 2) {
      throw new MichelsonValidationError(ex, "at least 2 arguments expected");
    }
    args.forEach((a2) => {
      if (assertPrimOrSeq(a2)) {
        cb(a2);
      }
    });
    return true;
  }
  switch (ex.prim) {
    case "option":
    case "list":
      if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
        cb(ex.args[0]);
      }
      break;
    case "contract":
      if (assertArgs(ex, 1)) {
        assertMichelsonPassableType(ex.args[0]);
      }
      break;
    case "or":
      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
        cb(ex.args[0]);
        cb(ex.args[1]);
      }
      break;
    case "lambda":
      if (assertArgs(ex, 2)) {
        assertMichelsonType(ex.args[0]);
        assertMichelsonType(ex.args[1]);
      }
      break;
    case "set":
      if (assertArgs(ex, 1)) {
        assertMichelsonComparableType(ex.args[0]);
      }
      break;
    case "map":
      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
        assertMichelsonComparableType(ex.args[0]);
        cb(ex.args[1]);
      }
      break;
    case "big_map":
      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
        assertMichelsonComparableType(ex.args[0]);
        assertMichelsonBigMapStorableType(ex.args[1]);
        cb(ex.args[1]);
      }
      break;
    case "ticket":
      if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
        assertMichelsonComparableType(ex.args[0]);
      }
      break;
    case "sapling_state":
    case "sapling_transaction":
      if (assertArgs(ex, 1)) {
        assertIntLiteral(ex.args[0]);
      }
      break;
    default:
      assertArgs(ex, 0);
  }
  return true;
}
function assertMichelsonData(ex) {
  if ("int" in ex || "string" in ex || "bytes" in ex) {
    return true;
  }
  if (Array.isArray(ex)) {
    let mapElts = 0;
    for (const n of ex) {
      if (isPrim$1(n) && n.prim === "Elt") {
        if (assertArgs(n, 2)) {
          assertMichelsonData(n.args[0]);
          assertMichelsonData(n.args[1]);
        }
        mapElts++;
      } else {
        assertMichelsonData(n);
      }
    }
    if (mapElts !== 0 && mapElts !== ex.length) {
      throw new MichelsonValidationError(ex, "data entries and map elements can't be intermixed");
    }
    return true;
  }
  if (isPrim$1(ex)) {
    switch (ex.prim) {
      case "Unit":
      case "True":
      case "False":
      case "None":
        assertArgs(ex, 0);
        break;
      case "Pair":
        if (ex.args === void 0 || ex.args.length < 2) {
          throw new MichelsonValidationError(ex, "at least 2 arguments expected");
        }
        for (const a2 of ex.args) {
          assertMichelsonData(a2);
        }
        break;
      case "Left":
      case "Right":
      case "Some":
        if (assertArgs(ex, 1)) {
          assertMichelsonData(ex.args[0]);
        }
        break;
      case "Lambda_rec":
        if (ex.args) {
          assertMichelsonInstruction(ex.args);
        }
        break;
      default:
        if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {
          assertMichelsonInstruction(ex);
        } else {
          throw new MichelsonValidationError(ex, "data entry or instruction expected");
        }
    }
  } else {
    throw new MichelsonValidationError(ex, "data entry expected");
  }
  return true;
}
function assertMichelsonContract(ex) {
  if (assertSeq(ex)) {
    const toplevelSec = {};
    const views = {};
    for (const sec of ex) {
      if (assertPrim(sec)) {
        if (sec.prim !== "view") {
          if (sec.prim in toplevelSec) {
            throw new MichelsonValidationError(ex, `duplicate contract section: ${sec.prim}`);
          }
          toplevelSec[sec.prim] = true;
        }
        switch (sec.prim) {
          case "code":
            if (assertArgs(sec, 1)) {
              if (assertSeq(sec.args[0])) {
                assertMichelsonInstruction(sec.args[0]);
              }
            }
            break;
          case "parameter":
            if (assertArgs(sec, 1)) {
              assertMichelsonPassableType(sec.args[0]);
            }
            if (sec.annots) {
              throw new MichelsonValidationError(sec, "Annotation must be part of the parameter type");
            }
            break;
          case "storage":
            if (assertArgs(sec, 1)) {
              assertMichelsonStorableType(sec.args[0]);
            }
            break;
          case "view":
            if (assertArgs(sec, 4)) {
              if (assertStringLiteral(sec.args[0])) {
                const name2 = sec.args[0];
                if (name2.string in views) {
                  throw new MichelsonValidationError(ex, `duplicate view name: ${name2.string}`);
                }
                views[name2.string] = true;
                assertViewNameValid(name2);
              }
              assertMichelsonPushableType(sec.args[1]);
              assertMichelsonPushableType(sec.args[2]);
              if (assertSeq(sec.args[3])) {
                assertMichelsonInstruction(sec.args[3]);
              }
            }
            break;
          default:
            throw new MichelsonValidationError(ex, `unexpected contract section: ${sec.prim}`);
        }
      }
    }
  }
  return true;
}
function isInstruction(p2) {
  return Object.prototype.hasOwnProperty.call(instructionIDs, p2.prim);
}
function assertDataListIfAny(d2) {
  if (!Array.isArray(d2)) {
    return false;
  }
  for (const v2 of d2) {
    if ("prim" in v2) {
      if (isInstruction(v2)) {
        throw new MichelsonError(d2, `Instruction outside of a lambda: ${JSON.stringify(d2)}`);
      } else if (v2.prim === "Elt") {
        throw new MichelsonError(d2, `Elt item outside of a map literal: ${JSON.stringify(d2)}`);
      }
    }
  }
  return true;
}
function __rest$2(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
const primitives = [
  "parameter",
  "storage",
  "code",
  "False",
  "Elt",
  "Left",
  "None",
  "Pair",
  "Right",
  "Some",
  "True",
  "Unit",
  "PACK",
  "UNPACK",
  "BLAKE2B",
  "SHA256",
  "SHA512",
  "ABS",
  "ADD",
  "AMOUNT",
  "AND",
  "BALANCE",
  "CAR",
  "CDR",
  "CHECK_SIGNATURE",
  "COMPARE",
  "CONCAT",
  "CONS",
  "CREATE_ACCOUNT",
  "CREATE_CONTRACT",
  "IMPLICIT_ACCOUNT",
  "DIP",
  "DROP",
  "DUP",
  "EDIV",
  "EMPTY_MAP",
  "EMPTY_SET",
  "EQ",
  "EXEC",
  "FAILWITH",
  "GE",
  "GET",
  "GT",
  "HASH_KEY",
  "IF",
  "IF_CONS",
  "IF_LEFT",
  "IF_NONE",
  "INT",
  "LAMBDA",
  "LE",
  "LEFT",
  "LOOP",
  "LSL",
  "LSR",
  "LT",
  "MAP",
  "MEM",
  "MUL",
  "NEG",
  "NEQ",
  "NIL",
  "NONE",
  "NOT",
  "NOW",
  "OR",
  "PAIR",
  "PUSH",
  "RIGHT",
  "SIZE",
  "SOME",
  "SOURCE",
  "SENDER",
  "SELF",
  "STEPS_TO_QUOTA",
  "SUB",
  "SWAP",
  "TRANSFER_TOKENS",
  "SET_DELEGATE",
  "UNIT",
  "UPDATE",
  "XOR",
  "ITER",
  "LOOP_LEFT",
  "ADDRESS",
  "CONTRACT",
  "ISNAT",
  "CAST",
  "RENAME",
  "bool",
  "contract",
  "int",
  "key",
  "key_hash",
  "lambda",
  "list",
  "map",
  "big_map",
  "nat",
  "option",
  "or",
  "pair",
  "set",
  "signature",
  "string",
  "bytes",
  "mutez",
  "timestamp",
  "unit",
  "operation",
  "address",
  "SLICE",
  "DIG",
  "DUG",
  "EMPTY_BIG_MAP",
  "APPLY",
  "chain_id",
  "CHAIN_ID",
  "LEVEL",
  "SELF_ADDRESS",
  "never",
  "NEVER",
  "UNPAIR",
  "VOTING_POWER",
  "TOTAL_VOTING_POWER",
  "KECCAK",
  "SHA3",
  "PAIRING_CHECK",
  "bls12_381_g1",
  "bls12_381_g2",
  "bls12_381_fr",
  "sapling_state",
  "sapling_transaction_deprecated",
  "SAPLING_EMPTY_STATE",
  "SAPLING_VERIFY_UPDATE",
  "ticket",
  "TICKET_DEPRECATED",
  "READ_TICKET",
  "SPLIT_TICKET",
  "JOIN_TICKETS",
  "GET_AND_UPDATE",
  "chest",
  "chest_key",
  "OPEN_CHEST",
  "VIEW",
  "view",
  "constant",
  "SUB_MUTEZ",
  "tx_rollup_l2_address",
  "MIN_BLOCK_TIME",
  "sapling_transaction",
  "EMIT",
  "Lambda_rec",
  "LAMBDA_REC",
  "TICKET"
];
Object.assign({}, ...primitives.map((v2, i2) => ({ [v2]: i2 })));
var Tag;
(function(Tag2) {
  Tag2[Tag2["Int"] = 0] = "Int";
  Tag2[Tag2["String"] = 1] = "String";
  Tag2[Tag2["Sequence"] = 2] = "Sequence";
  Tag2[Tag2["Prim0"] = 3] = "Prim0";
  Tag2[Tag2["Prim0Annot"] = 4] = "Prim0Annot";
  Tag2[Tag2["Prim1"] = 5] = "Prim1";
  Tag2[Tag2["Prim1Annot"] = 6] = "Prim1Annot";
  Tag2[Tag2["Prim2"] = 7] = "Prim2";
  Tag2[Tag2["Prim2Annot"] = 8] = "Prim2Annot";
  Tag2[Tag2["Prim"] = 9] = "Prim";
  Tag2[Tag2["Bytes"] = 10] = "Bytes";
})(Tag || (Tag = {}));
const boundsErr = new Error("bounds out of range");
class Reader {
  constructor(buffer2, idx = 0, cap = buffer2.length) {
    this.buffer = buffer2;
    this.idx = idx;
    this.cap = cap;
  }
  /** Remaining length */
  get length() {
    return this.cap - this.idx;
  }
  readBytes(len2) {
    if (this.cap - this.idx < len2) {
      throw boundsErr;
    }
    const ret = this.buffer.slice(this.idx, this.idx + len2);
    this.idx += len2;
    return ret;
  }
  reader(len2) {
    if (this.cap - this.idx < len2) {
      throw boundsErr;
    }
    const ret = new Reader(this.buffer, this.idx, this.idx + len2);
    this.idx += len2;
    return ret;
  }
  copy() {
    return new Reader(this.buffer, this.idx, this.cap);
  }
  readUint8() {
    if (this.cap - this.idx < 1) {
      throw boundsErr;
    }
    return this.buffer[this.idx++] >>> 0;
  }
  readUint16() {
    if (this.cap - this.idx < 2) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    return (x0 << 8 | x1) >>> 0;
  }
  readUint32() {
    if (this.cap - this.idx < 4) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    const x2 = this.buffer[this.idx++];
    const x3 = this.buffer[this.idx++];
    return (x0 << 24 | x1 << 16 | x2 << 8 | x3) >>> 0;
  }
  readInt8() {
    if (this.cap - this.idx < 1) {
      throw boundsErr;
    }
    const x2 = this.buffer[this.idx++];
    return x2 << 24 >> 24;
  }
  readInt16() {
    if (this.cap - this.idx < 2) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    return (x0 << 8 | x1) << 16 >> 16;
  }
  readInt32() {
    if (this.cap - this.idx < 4) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    const x2 = this.buffer[this.idx++];
    const x3 = this.buffer[this.idx++];
    return x0 << 24 | x1 << 16 | x2 << 8 | x3;
  }
}
var ContractID;
(function(ContractID2) {
  ContractID2[ContractID2["Implicit"] = 0] = "Implicit";
  ContractID2[ContractID2["Originated"] = 1] = "Originated";
})(ContractID || (ContractID = {}));
var PublicKeyHashID;
(function(PublicKeyHashID2) {
  PublicKeyHashID2[PublicKeyHashID2["ED25519"] = 0] = "ED25519";
  PublicKeyHashID2[PublicKeyHashID2["SECP256K1"] = 1] = "SECP256K1";
  PublicKeyHashID2[PublicKeyHashID2["P256"] = 2] = "P256";
})(PublicKeyHashID || (PublicKeyHashID = {}));
function readPublicKeyHash(rd) {
  let type;
  const tag = rd.readUint8();
  switch (tag) {
    case PublicKeyHashID.ED25519:
      type = "ED25519PublicKeyHash";
      break;
    case PublicKeyHashID.SECP256K1:
      type = "SECP256K1PublicKeyHash";
      break;
    case PublicKeyHashID.P256:
      type = "P256PublicKeyHash";
      break;
    default:
      throw new Error(`unknown public key hash tag: ${tag}`);
  }
  return { type, hash: rd.readBytes(20) };
}
function readAddress(rd) {
  let address;
  const tag = rd.readUint8();
  switch (tag) {
    case ContractID.Implicit:
      address = readPublicKeyHash(rd);
      break;
    case ContractID.Originated:
      address = {
        type: "ContractHash",
        hash: rd.readBytes(20)
      };
      rd.readBytes(1);
      break;
    default:
      throw new Error(`unknown address tag: ${tag}`);
  }
  if (rd.length !== 0) {
    const dec = new TextDecoder();
    address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));
  }
  return address;
}
var PublicKeyID;
(function(PublicKeyID2) {
  PublicKeyID2[PublicKeyID2["ED25519"] = 0] = "ED25519";
  PublicKeyID2[PublicKeyID2["SECP256K1"] = 1] = "SECP256K1";
  PublicKeyID2[PublicKeyID2["P256"] = 2] = "P256";
})(PublicKeyID || (PublicKeyID = {}));
function readPublicKey(rd) {
  let ln;
  let type;
  const tag = rd.readUint8();
  switch (tag) {
    case PublicKeyID.ED25519:
      type = "ED25519PublicKey";
      ln = 32;
      break;
    case PublicKeyID.SECP256K1:
      type = "SECP256K1PublicKey";
      ln = 33;
      break;
    case PublicKeyID.P256:
      type = "P256PublicKey";
      ln = 33;
      break;
    default:
      throw new Error(`unknown public key tag: ${tag}`);
  }
  return { type, publicKey: rd.readBytes(ln) };
}
function decodeAddressBytes(b2) {
  const bytes = parseBytes(b2.bytes);
  if (bytes === null) {
    throw new Error(`can't parse bytes: "${b2.bytes}"`);
  }
  const rd = new Reader(new Uint8Array(bytes));
  return readAddress(rd);
}
function decodePublicKeyHashBytes(b2) {
  const bytes = parseBytes(b2.bytes);
  if (bytes === null) {
    throw new Error(`can't parse bytes: "${b2.bytes}"`);
  }
  const rd = new Reader(new Uint8Array(bytes));
  return readPublicKeyHash(rd);
}
function decodePublicKeyBytes(b2) {
  const bytes = parseBytes(b2.bytes);
  if (bytes === null) {
    throw new Error(`can't parse bytes: "${b2.bytes}"`);
  }
  const rd = new Reader(new Uint8Array(bytes));
  return readPublicKey(rd);
}
class MichelsonInstructionError extends MichelsonError {
  /**
   * @param val Value of a type node caused the error
   * @param stackState Current stack state
   * @param message An error message
   */
  constructor(val, stackState, message) {
    super(val, message);
    this.stackState = stackState;
    Object.setPrototypeOf(this, MichelsonInstructionError.prototype);
  }
}
function typeID(t) {
  return Array.isArray(t) ? "pair" : t.prim;
}
function typeArgs(t) {
  return "prim" in t ? t.args : t;
}
function assertScalarTypesEqual(a2, b2, field = false) {
  if (typeID(a2) !== typeID(b2)) {
    throw new MichelsonTypeError(a2, void 0, `types mismatch: ${typeID(a2)} != ${typeID(b2)}`);
  }
  const ann = [unpackAnnotations(a2), unpackAnnotations(b2)];
  if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {
    throw new MichelsonTypeError(a2, void 0, `${typeID(a2)}: type names mismatch: ${ann[0].t[0]} != ${ann[1].t[0]}`);
  }
  if (field && ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0]) {
    throw new MichelsonTypeError(a2, void 0, `${typeID(a2)}: field names mismatch: ${ann[0].f[0]} != ${ann[1].f}`);
  }
  if (isPairType(a2)) {
    const aArgs = unpackComb("pair", a2);
    const bArgs = unpackComb("pair", b2);
    assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);
    assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);
    return;
  }
  switch (a2.prim) {
    case "option":
    case "list":
    case "contract":
    case "set":
    case "ticket":
      assertScalarTypesEqual(a2.args[0], b2.args[0]);
      break;
    case "or":
      assertScalarTypesEqual(a2.args[0], b2.args[0], true);
      assertScalarTypesEqual(a2.args[1], b2.args[1], true);
      break;
    case "lambda":
    case "map":
    case "big_map":
      assertScalarTypesEqual(a2.args[0], b2.args[0]);
      assertScalarTypesEqual(a2.args[1], b2.args[1]);
      break;
    case "sapling_state":
    case "sapling_transaction":
      if (parseInt(a2.args[0].int, 10) !== parseInt(b2.args[0].int, 10)) {
        throw new MichelsonTypeError(a2, void 0, `${typeID(a2)}: type argument mismatch: ${a2.args[0].int} != ${b2.args[0].int}`);
      }
  }
}
function assertStacksEqual(a2, b2) {
  if (a2.length !== b2.length) {
    throw new MichelsonTypeError(a2, void 0, `stack length mismatch: ${a2.length} != ${b2.length}`);
  }
  for (let i2 = 0; i2 < a2.length; i2++) {
    assertScalarTypesEqual(a2[i2], b2[i2]);
  }
}
function assertTypeAnnotationsValid(t, field = false) {
  var _a2, _b, _c;
  if (!Array.isArray(t)) {
    const ann = unpackAnnotations(t);
    if ((((_a2 = ann.t) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) > 1) {
      throw new MichelsonTypeError(t, void 0, `${t.prim}: at most one type annotation allowed: ${t.annots}`);
    }
    if (field) {
      if ((((_b = ann.f) === null || _b === void 0 ? void 0 : _b.length) || 0) > 1) {
        throw new MichelsonTypeError(t, void 0, `${t.prim}: at most one field annotation allowed: ${t.annots}`);
      }
    } else {
      if ((((_c = ann.f) === null || _c === void 0 ? void 0 : _c.length) || 0) > 0) {
        throw new MichelsonTypeError(t, void 0, `${t.prim}: field annotations aren't allowed: ${t.annots}`);
      }
    }
  }
  if (isPairType(t)) {
    const args = typeArgs(t);
    for (const a2 of args) {
      assertTypeAnnotationsValid(a2, true);
    }
    return;
  }
  switch (t.prim) {
    case "option":
    case "list":
    case "contract":
    case "set":
      assertTypeAnnotationsValid(t.args[0]);
      break;
    case "or":
      for (const a2 of t.args) {
        assertTypeAnnotationsValid(a2, true);
      }
      break;
    case "lambda":
    case "map":
    case "big_map":
      assertTypeAnnotationsValid(t.args[0]);
      assertTypeAnnotationsValid(t.args[1]);
  }
}
function isFunction(d2) {
  if (!Array.isArray(d2)) {
    return false;
  }
  for (const v2 of d2) {
    if (!(Array.isArray(v2) && isFunction(v2) || "prim" in v2 && isInstruction(v2))) {
      return false;
    }
  }
  return true;
}
function assertDataValidInternal(d2, t, ctx) {
  if (isPairType(t)) {
    if (isPairData(d2)) {
      assertDataListIfAny(d2);
      const dc = unpackComb("Pair", d2);
      const tc = unpackComb("pair", t);
      assertDataValidInternal(dc.args[0], tc.args[0], ctx);
      assertDataValidInternal(dc.args[1], tc.args[1], ctx);
      return;
    }
    throw new MichelsonTypeError(t, d2, `pair expected: ${JSON.stringify(d2)}`);
  }
  switch (t.prim) {
    case "int":
      if ("int" in d2 && isDecimal(d2.int)) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `integer value expected: ${JSON.stringify(d2)}`);
    case "nat":
    case "mutez":
      if ("int" in d2 && isNatural(d2.int)) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `natural value expected: ${JSON.stringify(d2)}`);
    case "string":
      if ("string" in d2) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `string value expected: ${JSON.stringify(d2)}`);
    case "bytes":
    case "bls12_381_g1":
    case "bls12_381_g2":
      if ("bytes" in d2 && parseBytes(d2.bytes) !== null) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `bytes value expected: ${JSON.stringify(d2)}`);
    case "bool":
      if ("prim" in d2 && (d2.prim === "True" || d2.prim === "False")) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `boolean value expected: ${JSON.stringify(d2)}`);
    case "key_hash":
      if ("string" in d2 && checkDecodeTezosID(d2.string, "ED25519PublicKeyHash", "SECP256K1PublicKeyHash", "P256PublicKeyHash") !== null) {
        return;
      } else if ("bytes" in d2) {
        try {
          decodePublicKeyHashBytes(d2);
          return;
        } catch (err) {
        }
      }
      throw new MichelsonTypeError(t, d2, `key hash expected: ${JSON.stringify(d2)}`);
    case "timestamp":
      if (("string" in d2 || "int" in d2) && parseDate(d2) !== null) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `timestamp expected: ${JSON.stringify(d2)}`);
    case "address":
      if ("string" in d2) {
        let address = d2.string;
        const ep = d2.string.indexOf("%");
        if (ep >= 0) {
          address = d2.string.slice(0, ep);
        }
        if (checkDecodeTezosID(address, "ED25519PublicKeyHash", "SECP256K1PublicKeyHash", "P256PublicKeyHash", "ContractHash", "TxRollupL2Address", "RollupAddress") !== null) {
          return;
        }
      } else if ("bytes" in d2) {
        try {
          decodeAddressBytes(d2);
          return;
        } catch (err) {
        }
      }
      throw new MichelsonTypeError(t, d2, `address expected: ${JSON.stringify(d2)}`);
    case "key":
      if ("string" in d2 && checkDecodeTezosID(d2.string, "ED25519PublicKey", "SECP256K1PublicKey", "P256PublicKey") !== null) {
        return;
      } else if ("bytes" in d2) {
        try {
          decodePublicKeyBytes(d2);
          return;
        } catch (err) {
        }
      }
      throw new MichelsonTypeError(t, d2, `public key expected: ${JSON.stringify(d2)}`);
    case "unit":
      if ("prim" in d2 && d2.prim === "Unit") {
        return;
      }
      throw new MichelsonTypeError(t, d2, `unit value expected: ${JSON.stringify(d2)}`);
    case "signature":
      if ("bytes" in d2 || "string" in d2 && checkDecodeTezosID(d2.string, "ED25519Signature", "SECP256K1Signature", "P256Signature", "GenericSignature") !== null) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `signature expected: ${JSON.stringify(d2)}`);
    case "chain_id":
      if ("bytes" in d2 || "string" in d2) {
        const x2 = "string" in d2 ? decodeBase58Check(d2.string) : parseBytes(d2.bytes);
        if (x2 !== null) {
          return;
        }
      }
      throw new MichelsonTypeError(t, d2, `chain id expected: ${JSON.stringify(d2)}`);
    case "option":
      if ("prim" in d2) {
        if (d2.prim === "None") {
          return;
        } else if (d2.prim === "Some") {
          assertDataValidInternal(d2.args[0], t.args[0], ctx);
          return;
        }
      }
      throw new MichelsonTypeError(t, d2, `option expected: ${JSON.stringify(d2)}`);
    case "list":
    case "set":
      if (assertDataListIfAny(d2)) {
        for (const v2 of d2) {
          assertDataValidInternal(v2, t.args[0], ctx);
        }
        return;
      }
      throw new MichelsonTypeError(t, d2, `${t.prim} expected: ${JSON.stringify(d2)}`);
    case "or":
      if ("prim" in d2) {
        if (d2.prim === "Left") {
          assertDataValidInternal(d2.args[0], t.args[0], ctx);
          return;
        } else if (d2.prim === "Right") {
          assertDataValidInternal(d2.args[0], t.args[1], ctx);
          return;
        }
      }
      throw new MichelsonTypeError(t, d2, `union (or) expected: ${JSON.stringify(d2)}`);
    case "lambda":
      if (isFunction(d2)) {
        const ret = functionTypeInternal(d2, [t.args[0]], ctx);
        if ("failed" in ret) {
          throw new MichelsonTypeError(t, d2, `function is failed with error type: ${ret.failed}`);
        }
        if (ret.length !== 1) {
          throw new MichelsonTypeError(t, d2, "function must return a value");
        }
        assertScalarTypesEqual(t.args[1], ret[0]);
        return;
      }
      throw new MichelsonTypeError(t, d2, `function expected: ${JSON.stringify(d2)}`);
    case "map":
    case "big_map":
      if (Array.isArray(d2)) {
        for (const v2 of d2) {
          if (!("prim" in v2) || v2.prim !== "Elt") {
            throw new MichelsonTypeError(t, d2, `map elements expected: ${JSON.stringify(d2)}`);
          }
          assertDataValidInternal(v2.args[0], t.args[0], ctx);
          assertDataValidInternal(v2.args[1], t.args[1], ctx);
        }
        return;
      }
      throw new MichelsonTypeError(t, d2, `${t.prim} expected: ${JSON.stringify(d2)}`);
    case "bls12_381_fr":
      if ("int" in d2 && isDecimal(d2.int) || "bytes" in d2 && parseBytes(d2.bytes) !== null) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `BLS12-381 element expected: ${JSON.stringify(d2)}`);
    case "sapling_state":
      if (Array.isArray(d2)) {
        return;
      }
      throw new MichelsonTypeError(t, d2, `sapling state expected: ${JSON.stringify(d2)}`);
    case "ticket":
      assertDataValidInternal(d2, {
        prim: "pair",
        args: [{ prim: "address" }, t.args[0], { prim: "nat" }]
      }, ctx);
      return;
    default:
      throw new MichelsonTypeError(t, d2, `type ${typeID(t)} don't have Michelson literal representation`);
  }
}
function instructionListType(inst, stack, ctx) {
  let ret = stack;
  let s2 = stack;
  let i2 = 0;
  for (const op of inst) {
    const ft2 = functionTypeInternal(op, s2, ctx);
    ret = ft2;
    if ("failed" in ft2) {
      break;
    }
    s2 = ft2;
    i2++;
  }
  if ("failed" in ret && ret.level == 0 && (!("prim" in ret.failed) || ret.failed.prim !== "never") && i2 !== inst.length - 1) {
    throw new MichelsonInstructionError(inst, ret, "FAIL must appear in a tail position");
  }
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== void 0) {
    const trace = {
      op: inst,
      in: stack,
      out: ret
    };
    ctx.traceCallback(trace);
  }
  return "failed" in ret ? { failed: ret.failed, level: ret.level + 1 } : ret;
}
function functionTypeInternal(inst, stack, ctx) {
  const proto = (ctx === null || ctx === void 0 ? void 0 : ctx.protocol) || DefaultProtocol;
  if (Array.isArray(inst)) {
    return instructionListType(inst, stack, ctx);
  }
  const instruction = inst;
  function args(n, ...typeIds) {
    if (stack.length < typeIds.length + n) {
      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack must have at least ${typeIds.length} element(s)`);
    }
    let i2 = n;
    for (const ids of typeIds) {
      if (ids !== null && ids.length !== 0) {
        let ii = 0;
        while (ii < ids.length && ids[ii] !== typeID(stack[i2])) {
          ii++;
        }
        if (ii === ids.length) {
          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack type mismatch: [${i2}] expected to be ${ids}, got ${typeID(stack[i2])} instead`);
        }
      }
      i2++;
    }
    return stack.slice(n, typeIds.length + n);
  }
  function rethrow(fn) {
    return (...args2) => {
      try {
        return fn(...args2);
      } catch (err) {
        if (err instanceof MichelsonError) {
          throw new MichelsonInstructionError(instruction, stack, err.message);
        } else {
          throw err;
        }
      }
    };
  }
  function rethrowTypeGuard(fn) {
    return (arg) => {
      try {
        return fn(arg);
      } catch (err) {
        if (err instanceof MichelsonError) {
          throw new MichelsonInstructionError(instruction, stack, err.message);
        } else {
          throw err;
        }
      }
    };
  }
  const argAnn = rethrow(unpackAnnotations);
  const ensureStacksEqual = rethrow(assertStacksEqual);
  const ensureTypesEqual = rethrow(assertScalarTypesEqual);
  const ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);
  const ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);
  const ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);
  const ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);
  const ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType);
  function instructionAnn(num, opt) {
    const a2 = argAnn(instruction, Object.assign(Object.assign({}, opt), { emptyFields: num.f !== void 0 && num.f > 1, emptyVar: num.v !== void 0 && num.v > 1 }));
    const assertNum = (a3, n, type) => {
      if (a3 && a3.length > (n || 0)) {
        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at most ${n || 0} ${type} annotations allowed`);
      }
    };
    assertNum(a2.f, num.f, "field");
    assertNum(a2.t, num.t, "type");
    assertNum(a2.v, num.v, "variable");
    return a2;
  }
  function annotate(tt, a2) {
    const tx = tt;
    const t = Array.isArray(tx) ? { prim: "pair", args: tx } : tx;
    const src2 = argAnn(t);
    const ann = a2.v !== void 0 || a2.t !== void 0 || a2.f !== void 0 ? [
      ...(a2.v === null ? src2.v : a2.v) || [],
      ...(a2.t === null ? src2.t : a2.t) || [],
      ...(a2.f === null ? src2.f : a2.f) || []
    ] : void 0;
    const rest = __rest$2(t, ["annots"]);
    return Object.assign(Object.assign({}, rest), ann && ann.length !== 0 && { annots: ann });
  }
  function annotateVar(t, def) {
    const ia = instructionAnn({ v: 1 });
    return annotate(t, {
      v: ia.v !== void 0 ? ia.v : def !== void 0 ? [def] : null,
      t: null
    });
  }
  function annotateField(arg, field, insAnn, n, defField) {
    var _a2, _b, _c, _d;
    const fieldAnn = (_a2 = argAnn(field).f) === null || _a2 === void 0 ? void 0 : _a2[0];
    const insFieldAnn = (_b = insAnn.f) === null || _b === void 0 ? void 0 : _b[n];
    if (insFieldAnn !== void 0 && insFieldAnn !== "%" && fieldAnn !== void 0 && insFieldAnn !== fieldAnn) {
      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: field names doesn't match: ${insFieldAnn} !== ${fieldAnn}`);
    }
    const insVarAnn = (_c = insAnn.v) === null || _c === void 0 ? void 0 : _c[n];
    const varAnn = (_d = argAnn(arg).v) === null || _d === void 0 ? void 0 : _d[0];
    return annotate(field, {
      t: null,
      v: insVarAnn ? insVarAnn === "@%" ? fieldAnn ? ["@" + fieldAnn.slice(1)] : void 0 : insVarAnn === "@%%" ? varAnn ? ["@" + varAnn.slice(1) + "." + (fieldAnn ? fieldAnn.slice(1) : defField)] : fieldAnn ? ["@" + fieldAnn.slice(1)] : void 0 : [insVarAnn] : null
    });
  }
  function getN(src2, n, i2 = n) {
    const p2 = unpackComb("pair", src2);
    if (i2 === 1) {
      return [p2.args[0]];
    } else if (i2 === 2) {
      return p2.args;
    }
    const right = p2.args[1];
    if (isPairType(right)) {
      return [p2.args[0], ...getN(right, n, i2 - 1)];
    } else {
      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n} fields are expected`);
    }
  }
  function getNth(src2, n, i2 = n) {
    if (i2 === 0) {
      return src2;
    }
    const p2 = unpackComb("pair", src2);
    if (i2 === 1) {
      return p2.args[0];
    }
    const right = p2.args[1];
    if (isPairType(right)) {
      return getNth(right, n, i2 - 2);
    } else if (i2 === 2) {
      return right;
    }
    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);
  }
  function updateNth(src2, x2, n, i2 = n) {
    if (i2 === 0) {
      return x2;
    }
    const p2 = unpackComb("pair", src2);
    if (i2 === 1) {
      return Object.assign(Object.assign({}, p2), { args: [x2, p2.args[1]] });
    }
    const right = p2.args[1];
    if (isPairType(right)) {
      return Object.assign(Object.assign({}, p2), { args: [p2.args[0], updateNth(right, x2, n, i2 - 2)] });
    } else if (i2 === 2) {
      return Object.assign(Object.assign({}, p2), { args: [p2.args[0], x2] });
    }
    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);
  }
  const varSuffix = (a2, suffix) => [
    "@" + (a2.v ? a2.v[0].slice(1) + "." : "") + suffix
  ];
  function branchType(br0, br1) {
    if ("failed" in br0 || "failed" in br1) {
      return "failed" in br0 ? br1 : br0;
    } else {
      ensureStacksEqual(br0, br1);
      return br0;
    }
  }
  const retStack = ((instruction2) => {
    var _a2, _b, _c, _d, _e;
    switch (instruction2.prim) {
      case "DUP": {
        const n = instruction2.args ? parseInt(instruction2.args[0].int, 10) : 1;
        if (n === 0) {
          throw new MichelsonInstructionError(instruction2, stack, "DUP 0 is forbidden");
        }
        const s2 = args(n - 1, null)[0];
        if (typeID(s2) === "ticket") {
          throw new MichelsonInstructionError(instruction2, stack, "ticket can't be DUPed");
        }
        return [s2, ...stack];
      }
      case "SWAP": {
        const s2 = args(0, null, null);
        instructionAnn({});
        return [s2[1], s2[0], ...stack.slice(2)];
      }
      case "SOME":
        return [
          annotate({ prim: "option", args: [args(0, null)[0]] }, instructionAnn({ t: 1, v: 1 })),
          ...stack.slice(1)
        ];
      case "UNIT":
        return [annotate({ prim: "unit" }, instructionAnn({ v: 1, t: 1 })), ...stack];
      case "PAIR": {
        const n = instruction2.args ? parseInt(instruction2.args[0].int, 10) : 2;
        if (n < 2) {
          throw new MichelsonInstructionError(instruction2, stack, `PAIR ${n} is forbidden`);
        }
        const s2 = args(0, ...new Array(n).fill(null));
        const ia = instructionAnn({ f: n, t: 1, v: 1 }, { specialFields: true });
        const trim2 = (s3) => {
          const i2 = s3.lastIndexOf(".");
          return s3.slice(i2 > 0 ? i2 + 1 : 1);
        };
        const retArgs = s2.map((v2, i2) => {
          var _a3;
          const va = argAnn(v2);
          const f2 = ia.f && ia.f.length > i2 && ia.f[i2] !== "%" ? ia.f[i2] === "%@" ? va.v ? ["%" + trim2(((_a3 = va.v) === null || _a3 === void 0 ? void 0 : _a3[0]) || "")] : void 0 : [ia.f[i2]] : void 0;
          return annotate(v2, { v: null, t: null, f: f2 });
        });
        return [
          annotate({
            prim: "pair",
            args: retArgs
          }, { t: ia.t, v: ia.v }),
          ...stack.slice(n)
        ];
      }
      case "UNPAIR": {
        const n = instruction2.args ? parseInt(instruction2.args[0].int, 10) : 2;
        if (n < 2) {
          throw new MichelsonInstructionError(instruction2, stack, `UNPAIR ${n} is forbidden`);
        }
        const s2 = args(0, ["pair"])[0];
        const ia = instructionAnn({ f: 2, v: 2 }, { specialVar: true });
        const fields = getN(s2, n);
        return [
          ...fields.map((field, i2) => annotateField(s2, field, ia, i2, i2 === 0 ? "car" : "cdr")),
          ...stack.slice(1)
        ];
      }
      case "CAR":
      case "CDR": {
        const s2 = unpackComb("pair", args(0, ["pair"])[0]);
        const field = s2.args[instruction2.prim === "CAR" ? 0 : 1];
        const ia = instructionAnn({ f: 1, v: 1 }, { specialVar: true });
        return [
          annotateField(s2, field, ia, 0, instruction2.prim.toLocaleLowerCase()),
          ...stack.slice(1)
        ];
      }
      case "CONS": {
        const s2 = args(0, null, ["list"]);
        ensureTypesEqual(s2[0], s2[1].args[0]);
        return [annotateVar({ prim: "list", args: [s2[1].args[0]] }), ...stack.slice(2)];
      }
      case "SIZE":
        args(0, ["string", "list", "set", "map", "bytes"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "MEM": {
        const s2 = args(0, null, ["set", "map", "big_map"]);
        ensureComparableType(s2[0]);
        ensureTypesEqual(s2[0], s2[1].args[0]);
        return [annotateVar({ prim: "bool" }), ...stack.slice(2)];
      }
      case "GET":
        if (instruction2.args) {
          const n = parseInt(instruction2.args[0].int, 10);
          const s2 = args(0, ["pair"])[0];
          return [annotateVar(getNth(s2, n)), ...stack.slice(1)];
        } else {
          const s2 = args(0, null, ["map", "big_map"]);
          ensureComparableType(s2[0]);
          ensureTypesEqual(s2[0], s2[1].args[0]);
          return [annotateVar({ prim: "option", args: [s2[1].args[1]] }), ...stack.slice(2)];
        }
      case "UPDATE":
        if (instruction2.args) {
          const n = parseInt(instruction2.args[0].int, 10);
          const s2 = args(0, null, ["pair"]);
          return [annotateVar(updateNth(s2[1], s2[0], n)), ...stack.slice(2)];
        } else {
          const s0 = args(0, null, ["bool", "option"]);
          ensureComparableType(s0[0]);
          if (s0[1].prim === "bool") {
            const s12 = args(2, ["set"]);
            ensureTypesEqual(s0[0], s12[0].args[0]);
            return [
              annotateVar({
                prim: "set",
                args: [annotate(s0[0], { t: null })]
              }),
              ...stack.slice(3)
            ];
          }
          const s1 = args(2, ["map", "big_map"]);
          ensureTypesEqual(s0[0], s1[0].args[0]);
          if (s1[0].prim === "map") {
            return [
              annotateVar({
                prim: "map",
                args: [annotate(s0[0], { t: null }), annotate(s0[1].args[0], { t: null })]
              }),
              ...stack.slice(3)
            ];
          }
          ensureBigMapStorableType(s0[1].args[0]);
          return [
            annotateVar({
              prim: "big_map",
              args: [annotate(s0[0], { t: null }), annotate(s0[1].args[0], { t: null })]
            }),
            ...stack.slice(3)
          ];
        }
      case "GET_AND_UPDATE": {
        const ia = instructionAnn({ v: 2 });
        const s2 = args(0, null, ["option"], ["map", "big_map"]);
        ensureComparableType(s2[0]);
        ensureTypesEqual(s2[0], s2[2].args[0]);
        ensureTypesEqual(s2[1].args[0], s2[2].args[1]);
        const va = (_a2 = ia.v) === null || _a2 === void 0 ? void 0 : _a2.map((v2) => v2 !== "@" ? [v2] : void 0);
        if (s2[2].prim === "map") {
          return [
            annotate({ prim: "option", args: [s2[2].args[1]] }, { v: va === null || va === void 0 ? void 0 : va[0] }),
            annotate({
              prim: "map",
              args: [annotate(s2[0], { t: null }), annotate(s2[1].args[0], { t: null })]
            }, { v: va === null || va === void 0 ? void 0 : va[1] }),
            ...stack.slice(3)
          ];
        }
        ensureBigMapStorableType(s2[1].args[0]);
        return [
          annotate({ prim: "option", args: [s2[2].args[1]] }, { v: va === null || va === void 0 ? void 0 : va[0] }),
          annotate({
            prim: "big_map",
            args: [annotate(s2[0], { t: null }), annotate(s2[1].args[0], { t: null })]
          }, { v: va === null || va === void 0 ? void 0 : va[1] }),
          ...stack.slice(3)
        ];
      }
      case "EXEC": {
        const s2 = args(0, null, ["lambda"]);
        ensureTypesEqual(s2[0], s2[1].args[0]);
        return [annotateVar(s2[1].args[1]), ...stack.slice(2)];
      }
      case "APPLY": {
        const s2 = args(0, null, ["lambda"]);
        ensureStorableType(s2[0]);
        ensurePushableType(s2[0]);
        if (!isPairType(s2[1].args[0])) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: function's argument must be a pair: ${typeID(s2[1].args[0])}`);
        }
        const pt = s2[1].args[0];
        ensureTypesEqual(s2[0], typeArgs(pt)[0]);
        return [
          annotateVar({ prim: "lambda", args: [typeArgs(pt)[1], s2[1].args[1]] }),
          ...stack.slice(2)
        ];
      }
      case "FAILWITH": {
        const s2 = args(0, null)[0];
        if (!ProtoInferiorTo$1(proto, Protocol.PtEdo2Zk)) {
          ensurePackableType(s2);
        }
        return { failed: s2, level: 0 };
      }
      case "NEVER":
        args(0, ["never"]);
        return { failed: { prim: "never" }, level: 0 };
      case "RENAME":
        return [annotateVar(args(0, null)[0]), ...stack.slice(1)];
      case "CONCAT": {
        const s0 = args(0, ["string", "list", "bytes"]);
        if (s0[0].prim === "list") {
          if (typeID(s0[0].args[0]) !== "string" && typeID(s0[0].args[0]) !== "bytes") {
            throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't concatenate list of ${typeID(s0[0].args[0])}'s`);
          }
          return [annotateVar(s0[0].args[0]), ...stack.slice(1)];
        }
        const s1 = args(1, ["string", "bytes"]);
        if (s0[0].prim !== s1[0].prim) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't concatenate ${s0[0].prim} with ${s1[0].prim}`);
        }
        return [annotateVar(s1[0]), ...stack.slice(2)];
      }
      case "SLICE":
        return [
          annotateVar({ prim: "option", args: [args(0, ["nat"], ["nat"], ["string", "bytes"])[2]] }, "@slice"),
          ...stack.slice(3)
        ];
      case "PACK": {
        const s2 = args(0, null)[0];
        ensurePackableType(s2);
        return [annotateVar({ prim: "bytes" }, "@packed"), ...stack.slice(1)];
      }
      case "ADD": {
        const s2 = args(0, ["nat", "int", "timestamp", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"], ["nat", "int", "timestamp", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"]);
        if (s2[0].prim === "nat" && s2[1].prim === "int" || s2[0].prim === "int" && s2[1].prim === "nat") {
          return [annotateVar({ prim: "int" }), ...stack.slice(2)];
        } else if (s2[0].prim === "int" && s2[1].prim === "timestamp" || s2[0].prim === "timestamp" && s2[1].prim === "int") {
          return [annotateVar({ prim: "timestamp" }), ...stack.slice(2)];
        } else if ((s2[0].prim === "int" || s2[0].prim === "nat" || s2[0].prim === "mutez" || s2[0].prim === "bls12_381_g1" || s2[0].prim === "bls12_381_g2" || s2[0].prim === "bls12_381_fr") && s2[0].prim === s2[1].prim) {
          return [annotateVar(s2[0]), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't add ${s2[0].prim} to ${s2[1].prim}`);
      }
      case "SUB": {
        const s2 = ProtoInferiorTo$1(proto, Protocol.PsiThaCa) ? args(0, ["nat", "int", "timestamp", "mutez"], ["nat", "int", "timestamp", "mutez"]) : args(0, ["nat", "int", "timestamp"], ["nat", "int", "timestamp"]);
        if ((s2[0].prim === "nat" || s2[0].prim === "int") && (s2[1].prim === "nat" || s2[1].prim === "int") || s2[0].prim === "timestamp" && s2[1].prim === "timestamp") {
          return [annotateVar({ prim: "int" }), ...stack.slice(2)];
        } else if (s2[0].prim === "timestamp" && s2[1].prim === "int") {
          return [annotateVar({ prim: "timestamp" }), ...stack.slice(2)];
        } else if (s2[0].prim === "mutez" && s2[1].prim === "mutez") {
          return [annotateVar({ prim: "mutez" }), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't subtract ${s2[0].prim} from ${s2[1].prim}`);
      }
      case "SUB_MUTEZ": {
        args(0, ["mutez"], ["mutez"]);
        return [annotateVar({ prim: "option", args: [{ prim: "mutez" }] }), ...stack.slice(2)];
      }
      case "MUL": {
        const s2 = args(0, ["nat", "int", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"], ["nat", "int", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"]);
        if (s2[0].prim === "nat" && s2[1].prim === "int" || s2[0].prim === "int" && s2[1].prim === "nat") {
          return [annotateVar({ prim: "int" }), ...stack.slice(2)];
        } else if (s2[0].prim === "nat" && s2[1].prim === "mutez" || s2[0].prim === "mutez" && s2[1].prim === "nat") {
          return [annotateVar({ prim: "mutez" }), ...stack.slice(2)];
        } else if ((s2[0].prim === "bls12_381_g1" || s2[0].prim === "bls12_381_g2" || s2[0].prim === "bls12_381_fr") && s2[1].prim === "bls12_381_fr" || (s2[0].prim === "nat" || s2[0].prim === "int") && s2[0].prim === s2[1].prim) {
          return [annotateVar(s2[0]), ...stack.slice(2)];
        } else if ((s2[0].prim === "nat" || s2[0].prim === "int") && s2[1].prim === "bls12_381_fr" || (s2[1].prim === "nat" || s2[1].prim === "int") && s2[0].prim === "bls12_381_fr") {
          return [annotateVar({ prim: "bls12_381_fr" }), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't multiply ${s2[0].prim} by ${s2[1].prim}`);
      }
      case "EDIV": {
        const res = (a2, b2) => ({
          prim: "option",
          args: [{ prim: "pair", args: [{ prim: a2 }, { prim: b2 }] }]
        });
        const s2 = args(0, ["nat", "int", "mutez"], ["nat", "int", "mutez"]);
        if (s2[0].prim === "nat" && s2[1].prim === "nat") {
          return [annotateVar(res("nat", "nat")), ...stack.slice(2)];
        } else if ((s2[0].prim === "nat" || s2[0].prim === "int") && (s2[1].prim === "nat" || s2[1].prim === "int")) {
          return [annotateVar(res("int", "nat")), ...stack.slice(2)];
        } else if (s2[0].prim === "mutez" && s2[1].prim === "nat") {
          return [annotateVar(res("mutez", "mutez")), ...stack.slice(2)];
        } else if (s2[0].prim === "mutez" && s2[1].prim === "mutez") {
          return [annotateVar(res("nat", "mutez")), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't euclideally divide ${s2[0].prim} by ${s2[1].prim}`);
      }
      case "ABS":
        args(0, ["int"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "ISNAT":
        args(0, ["int"]);
        return [annotateVar({ prim: "option", args: [{ prim: "nat" }] }), ...stack.slice(1)];
      case "INT":
        args(0, ["nat", "bls12_381_fr"]);
        return [annotateVar({ prim: "int" }), ...stack.slice(1)];
      case "NEG": {
        const s2 = args(0, ["nat", "int", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"])[0];
        if (s2.prim === "nat" || s2.prim === "int") {
          return [annotateVar({ prim: "int" }), ...stack.slice(1)];
        }
        return [annotateVar(s2), ...stack.slice(1)];
      }
      case "LSL":
      case "LSR":
        args(0, ["nat"], ["nat"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(2)];
      case "OR":
      case "XOR": {
        const s2 = args(0, ["nat", "bool"], ["nat", "bool"]);
        if (s2[0].prim !== s2[1].prim) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: both arguments must be of the same type: ${s2[0].prim}, ${s2[1].prim}`);
        }
        return [annotateVar(s2[1]), ...stack.slice(2)];
      }
      case "AND": {
        const s2 = args(0, ["nat", "bool", "int"], ["nat", "bool"]);
        if ((s2[0].prim !== "int" || s2[1].prim !== "nat") && s2[0].prim !== s2[1].prim) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: both arguments must be of the same type: ${s2[0].prim}, ${s2[1].prim}`);
        }
        return [annotateVar(s2[1]), ...stack.slice(2)];
      }
      case "NOT": {
        const s2 = args(0, ["nat", "bool", "int"])[0];
        if (s2.prim === "bool") {
          return [annotateVar({ prim: "bool" }), ...stack.slice(1)];
        }
        return [annotateVar({ prim: "int" }), ...stack.slice(1)];
      }
      case "COMPARE": {
        const s2 = args(0, null, null);
        ensureComparableType(s2[0]);
        ensureComparableType(s2[1]);
        return [annotateVar({ prim: "int" }), ...stack.slice(2)];
      }
      case "EQ":
      case "NEQ":
      case "LT":
      case "GT":
      case "LE":
      case "GE":
        args(0, ["int"]);
        return [annotateVar({ prim: "bool" }), ...stack.slice(1)];
      case "SELF": {
        if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) === void 0) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: contract required`);
        }
        const ia = instructionAnn({ f: 1, v: 1 });
        const ep = contractEntryPoint(ctx.contract, (_b = ia.f) === null || _b === void 0 ? void 0 : _b[0]);
        if (ep === null) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: contract has no entrypoint ${ep}`);
        }
        return [
          annotate({ prim: "contract", args: [ep] }, { v: ia.v ? ia.v : ["@self"] }),
          ...stack
        ];
      }
      case "TRANSFER_TOKENS": {
        const s2 = args(0, null, ["mutez"], ["contract"]);
        ensureTypesEqual(s2[0], s2[2].args[0]);
        return [annotateVar({ prim: "operation" }), ...stack.slice(3)];
      }
      case "SET_DELEGATE": {
        const s2 = args(0, ["option"])[0];
        if (typeID(s2.args[0]) !== "key_hash") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: key hash expected: ${typeID(s2.args[0])}`);
        }
        return [annotateVar({ prim: "operation" }), ...stack.slice(1)];
      }
      case "IMPLICIT_ACCOUNT":
        args(0, ["key_hash"]);
        return [annotateVar({ prim: "contract", args: [{ prim: "unit" }] }), ...stack.slice(1)];
      case "NOW":
        return [annotateVar({ prim: "timestamp" }, "@now"), ...stack];
      case "AMOUNT":
        return [annotateVar({ prim: "mutez" }, "@amount"), ...stack];
      case "BALANCE":
        return [annotateVar({ prim: "mutez" }, "@balance"), ...stack];
      case "CHECK_SIGNATURE":
        args(0, ["key"], ["signature"], ["bytes"]);
        return [annotateVar({ prim: "bool" }), ...stack.slice(3)];
      case "BLAKE2B":
      case "SHA256":
      case "SHA512":
      case "KECCAK":
      case "SHA3":
        args(0, ["bytes"]);
        return [annotateVar({ prim: "bytes" }), ...stack.slice(1)];
      case "HASH_KEY":
        args(0, ["key"]);
        return [annotateVar({ prim: "key_hash" }), ...stack.slice(1)];
      case "SOURCE":
        return [annotateVar({ prim: "address" }, "@source"), ...stack];
      case "SENDER":
        return [annotateVar({ prim: "address" }, "@sender"), ...stack];
      case "ADDRESS": {
        const s2 = args(0, ["contract"])[0];
        const ia = instructionAnn({ v: 1 });
        return [
          annotate({ prim: "address", [refContract]: s2 }, { v: ia.v ? ia.v : varSuffix(argAnn(s2), "address") }),
          ...stack.slice(1)
        ];
      }
      case "SELF_ADDRESS": {
        const addr = { prim: "address" };
        if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== void 0) {
          addr[refContract] = {
            prim: "contract",
            args: [contractSection(ctx.contract, "parameter").args[0]]
          };
        }
        return [annotateVar(addr, "@address"), ...stack];
      }
      case "CHAIN_ID":
        return [annotateVar({ prim: "chain_id" }), ...stack];
      case "DROP": {
        instructionAnn({});
        const n = instruction2.args !== void 0 ? parseInt(instruction2.args[0].int, 10) : 1;
        args(n - 1, null);
        return stack.slice(n);
      }
      case "DIG": {
        instructionAnn({});
        const n = parseInt(instruction2.args[0].int, 10);
        return [args(n, null)[0], ...stack.slice(0, n), ...stack.slice(n + 1)];
      }
      case "DUG": {
        instructionAnn({});
        const n = parseInt(instruction2.args[0].int, 10);
        return [...stack.slice(1, n + 1), args(0, null)[0], ...stack.slice(n + 1)];
      }
      case "NONE":
        assertTypeAnnotationsValid(instruction2.args[0]);
        return [
          annotate({ prim: "option", args: [instruction2.args[0]] }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "LEFT":
      case "RIGHT": {
        const s2 = args(0, null)[0];
        const ia = instructionAnn({ f: 2, t: 1, v: 1 }, { specialFields: true });
        const va = argAnn(s2);
        const children2 = [
          annotate(s2, {
            t: null,
            v: null,
            f: ia.f && ia.f.length > 0 && ia.f[0] !== "%" ? ia.f[0] === "%@" ? va.v ? ["%" + va.v[0].slice(1)] : void 0 : ia.f : void 0
          }),
          annotate(instruction2.args[0], {
            t: null,
            f: ia.f && ia.f.length > 1 && ia.f[1] !== "%" ? ia.f : void 0
          })
        ];
        return [
          annotate({
            prim: "or",
            args: instruction2.prim === "LEFT" ? children2 : [children2[1], children2[0]]
          }, { t: ia.t, v: ia.v }),
          ...stack.slice(1)
        ];
      }
      case "NIL":
        assertTypeAnnotationsValid(instruction2.args[0]);
        return [
          annotate({ prim: "list", args: [instruction2.args[0]] }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "UNPACK":
        args(0, ["bytes"]);
        assertTypeAnnotationsValid(instruction2.args[0]);
        return [
          annotateVar({ prim: "option", args: [instruction2.args[0]] }, "@unpacked"),
          ...stack.slice(1)
        ];
      case "CONTRACT": {
        const s2 = args(0, ["address"])[0];
        assertTypeAnnotationsValid(instruction2.args[0]);
        const ia = instructionAnn({ v: 1, f: 1 });
        const contract = s2[refContract];
        if (contract !== void 0) {
          const ep = contractEntryPoint(contract, (_c = ia.f) === null || _c === void 0 ? void 0 : _c[0]);
          if (ep === null) {
            throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: contract has no entrypoint ${ep}`);
          }
          ensureTypesEqual(ep, instruction2.args[0]);
        }
        return [
          annotate({ prim: "option", args: [{ prim: "contract", args: [instruction2.args[0]] }] }, { v: ia.v ? ia.v : varSuffix(argAnn(s2), "contract") }),
          ...stack.slice(1)
        ];
      }
      case "CAST": {
        instructionAnn({});
        const s2 = args(0, null)[0];
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureTypesEqual(instruction2.args[0], s2);
        return [instruction2.args[0], ...stack.slice(1)];
      }
      case "IF_NONE": {
        instructionAnn({});
        const s2 = args(0, ["option"])[0];
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], tail, ctx);
        const br1 = functionTypeInternal(instruction2.args[1], [annotate(s2.args[0], { t: null, v: varSuffix(argAnn(s2), "some") }), ...tail], ctx);
        return branchType(br0, br1);
      }
      case "IF_LEFT": {
        instructionAnn({});
        const s2 = args(0, ["or"])[0];
        const va = argAnn(s2);
        const lefta = argAnn(s2.args[0]);
        const righta = argAnn(s2.args[1]);
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], [
          annotate(s2.args[0], {
            t: null,
            v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : "left")
          }),
          ...tail
        ], ctx);
        const br1 = functionTypeInternal(instruction2.args[1], [
          annotate(s2.args[1], {
            t: null,
            v: varSuffix(va, righta.f ? righta.f[0].slice(1) : "right")
          }),
          ...tail
        ], ctx);
        return branchType(br0, br1);
      }
      case "IF_CONS": {
        instructionAnn({});
        const s2 = args(0, ["list"])[0];
        const va = argAnn(s2);
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], [
          annotate(s2.args[0], { t: null, v: varSuffix(va, "hd") }),
          annotate(s2, { t: null, v: varSuffix(va, "tl") }),
          ...tail
        ], ctx);
        const br1 = functionTypeInternal(instruction2.args[1], tail, ctx);
        return branchType(br0, br1);
      }
      case "IF": {
        instructionAnn({});
        args(0, ["bool"]);
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], tail, ctx);
        const br1 = functionTypeInternal(instruction2.args[1], tail, ctx);
        return branchType(br0, br1);
      }
      case "MAP": {
        const s2 = args(0, ["list", "map", "option"])[0];
        const tail = stack.slice(1);
        const elt = s2.prim === "map" ? { prim: "pair", args: s2.args } : s2.args[0];
        const body = functionTypeInternal(instruction2.args[0], [annotate(elt, { t: null, v: varSuffix(argAnn(s2), "elt") }), ...tail], ctx);
        if ("failed" in body) {
          if (!("prim" in body.failed) || body.failed.prim !== "never") {
            throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: FAIL is not allowed in MAP`);
          }
          return { failed: body.failed, level: body.level + 1 };
        }
        if (body.length < 1) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: function must return a value`);
        }
        ensureStacksEqual(body.slice(1), tail);
        return s2.prim === "list" ? [annotateVar({ prim: "list", args: [body[0]] }), ...tail] : s2.prim === "map" ? [annotateVar({ prim: "map", args: [s2.args[0], body[0]] }), ...tail] : [annotateVar({ prim: "option", args: [body[0]] }), ...tail];
      }
      case "ITER": {
        instructionAnn({});
        const s2 = args(0, ["set", "list", "map"])[0];
        const tail = stack.slice(1);
        const elt = s2.prim === "map" ? { prim: "pair", args: s2.args } : s2.args[0];
        const body = functionTypeInternal(instruction2.args[0], [annotate(elt, { t: null, v: varSuffix(argAnn(s2), "elt") }), ...tail], ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        ensureStacksEqual(body, tail);
        return tail;
      }
      case "LOOP": {
        instructionAnn({});
        args(0, ["bool"]);
        const tail = stack.slice(1);
        const body = functionTypeInternal(instruction2.args[0], tail, ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        ensureStacksEqual(body, [{ prim: "bool" }, ...tail]);
        return tail;
      }
      case "LOOP_LEFT": {
        instructionAnn({});
        const s2 = args(0, ["or"])[0];
        const tail = stack.slice(1);
        const body = functionTypeInternal(instruction2.args[0], [annotate(s2.args[0], { t: null, v: varSuffix(argAnn(s2), "left") }), ...tail], ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        ensureStacksEqual(body, [s2, ...tail]);
        return [annotate(s2.args[1], { t: null, v: instructionAnn({ v: 1 }).v }), ...tail];
      }
      case "DIP": {
        instructionAnn({});
        const n = instruction2.args.length === 2 ? parseInt(instruction2.args[0].int, 10) : 1;
        args(n - 1, null);
        const head = stack.slice(0, n);
        const tail = stack.slice(n);
        const body = instruction2.args.length === 2 ? functionTypeInternal(instruction2.args[1], tail, ctx) : functionTypeInternal(instruction2.args[0], tail, ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        return [...head, ...body];
      }
      case "CREATE_CONTRACT": {
        const ia = instructionAnn({ v: 2 });
        const s2 = args(0, ["option"], ["mutez"], null);
        if (typeID(s2[0].args[0]) !== "key_hash") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: key hash expected: ${typeID(s2[0].args[0])}`);
        }
        if (ensureStorableType(s2[2])) {
          assertContractValid(instruction2.args[0]);
          assertScalarTypesEqual(contractSection(instruction2.args[0], "storage").args[0], s2[2]);
        }
        const va = (_d = ia.v) === null || _d === void 0 ? void 0 : _d.map((v2) => v2 !== "@" ? [v2] : void 0);
        return [
          annotate({ prim: "operation" }, { v: va === null || va === void 0 ? void 0 : va[0] }),
          annotate({
            prim: "address",
            [refContract]: {
              prim: "contract",
              args: [contractSection(instruction2.args[0], "parameter").args[0]]
            }
          }, { v: va === null || va === void 0 ? void 0 : va[1] }),
          ...stack.slice(3)
        ];
      }
      case "PUSH":
        assertTypeAnnotationsValid(instruction2.args[0]);
        assertDataValidInternal(instruction2.args[1], instruction2.args[0], Object.assign(Object.assign({}, ctx), { contract: void 0 }));
        return [annotateVar(instruction2.args[0]), ...stack];
      case "EMPTY_SET":
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureComparableType(instruction2.args[0]);
        return [
          annotate({ prim: "set", args: instruction2.args }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "EMPTY_MAP":
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureComparableType(instruction2.args[0]);
        assertTypeAnnotationsValid(instruction2.args[1]);
        return [
          annotate({ prim: "map", args: instruction2.args }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "EMPTY_BIG_MAP":
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureComparableType(instruction2.args[0]);
        assertTypeAnnotationsValid(instruction2.args[1]);
        ensureBigMapStorableType(instruction2.args[0]);
        return [
          annotate({ prim: "big_map", args: instruction2.args }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "LAMBDA_REC":
      case "LAMBDA": {
        assertTypeAnnotationsValid(instruction2.args[0]);
        assertTypeAnnotationsValid(instruction2.args[1]);
        const s2 = [instruction2.args[0]];
        if (instruction2.prim === "LAMBDA_REC") {
          s2.push({ prim: "lambda", args: [instruction2.args[0], instruction2.args[1]] });
        }
        const body = functionTypeInternal(instruction2.args[2], s2, Object.assign(Object.assign({}, ctx), { contract: void 0 }));
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        if (body.length !== 1) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: function must return a value`);
        }
        ensureTypesEqual(instruction2.args[1], body[0]);
        return [
          annotateVar({ prim: "lambda", args: [instruction2.args[0], instruction2.args[1]] }),
          ...stack
        ];
      }
      case "LEVEL":
        return [annotateVar({ prim: "nat" }, "@level"), ...stack];
      case "TOTAL_VOTING_POWER":
        return [annotateVar({ prim: "nat" }), ...stack];
      case "VOTING_POWER":
        args(0, ["key_hash"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "TICKET": {
        const s2 = args(0, null, ["nat"])[0];
        ensureComparableType(s2);
        if (ProtoInferiorTo$1(proto, Protocol.PtLimaPtL)) {
          return [
            annotate({ prim: "ticket", args: [s2] }, instructionAnn({ t: 1, v: 1 })),
            ...stack.slice(2)
          ];
        } else {
          return [
            annotateVar({
              prim: "option",
              args: [
                annotate({ prim: "ticket", args: [s2] }, instructionAnn({ t: 1, v: 1 }))
              ]
            }),
            ...stack.slice(2)
          ];
        }
      }
      case "JOIN_TICKETS": {
        const s2 = unpackComb("pair", args(0, ["pair"])[0]);
        if (typeID(s2.args[0]) !== "ticket") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: ticket expected: ${typeID(s2.args[0])}`);
        }
        ensureTypesEqual(s2.args[0], s2.args[1]);
        return [
          annotateVar({
            prim: "option",
            args: [annotate(s2.args[0], { t: null })]
          }),
          ...stack.slice(1)
        ];
      }
      case "SPLIT_TICKET": {
        const s2 = args(0, ["ticket"], ["pair"]);
        const p2 = unpackComb("pair", s2[1]);
        if (typeID(p2.args[0]) !== "nat") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: nat expected: ${typeID(p2.args[0])}`);
        }
        ensureTypesEqual(p2.args[0], p2.args[1]);
        return [
          annotateVar({
            prim: "option",
            args: [
              {
                prim: "pair",
                args: [annotate(s2[0], { t: null }), annotate(s2[0], { t: null })]
              }
            ]
          }),
          ...stack.slice(2)
        ];
      }
      case "READ_TICKET": {
        const ia = instructionAnn({ v: 2 });
        const s2 = args(0, ["ticket"])[0];
        const va = (_e = ia.v) === null || _e === void 0 ? void 0 : _e.map((v2) => v2 !== "@" ? [v2] : void 0);
        return [
          annotate({
            prim: "pair",
            args: [{ prim: "address" }, annotate(s2.args[0], { t: null }), { prim: "nat" }]
          }, { v: va === null || va === void 0 ? void 0 : va[0] }),
          annotate(s2, { v: va === null || va === void 0 ? void 0 : va[1], t: null }),
          ...stack.slice(1)
        ];
      }
      case "PAIRING_CHECK": {
        const p2 = args(0, ["list"])[0].args[0];
        if (!isPairType(p2)) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: pair expected: ${typeID(p2)}`);
        }
        const c2 = unpackComb("pair", p2);
        if (typeID(c2.args[0]) !== "bls12_381_g1") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: bls12_381_g1 expected: ${typeID(c2.args[0])}`);
        }
        if (typeID(c2.args[1]) !== "bls12_381_g2") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: bls12_381_g2 expected: ${typeID(c2.args[1])}`);
        }
        return [annotateVar({ prim: "bool" }), ...stack.slice(1)];
      }
      case "SAPLING_EMPTY_STATE":
        return [
          annotate({ prim: "sapling_state", args: [instruction2.args[0]] }, instructionAnn({ v: 1, t: 1 })),
          ...stack
        ];
      case "SAPLING_VERIFY_UPDATE": {
        const s2 = args(0, ["sapling_transaction"], ["sapling_state"]);
        if (parseInt(s2[0].args[0].int, 10) !== parseInt(s2[1].args[0].int, 10)) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: sapling memo size mismatch: ${s2[0].args[0].int} != ${s2[1].args[0].int}`);
        }
        return ProtoInferiorTo$1(proto, Protocol.PtJakarta) ? [
          annotateVar({
            prim: "option",
            args: [
              {
                prim: "pair",
                args: [{ prim: "int" }, annotate(s2[1], { t: null })]
              }
            ]
          }),
          ...stack.slice(2)
        ] : [
          annotateVar({
            prim: "option",
            args: [
              {
                prim: "pair",
                args: [
                  { prim: "bytes" },
                  {
                    prim: "pair",
                    args: [{ prim: "int" }, annotate(s2[1], { t: null })]
                  }
                ]
              }
            ]
          }),
          ...stack.slice(2)
        ];
      }
      case "OPEN_CHEST":
        args(0, ["chest_key"], ["chest"], ["nat"]);
        return [
          annotateVar({ prim: "or", args: [{ prim: "bytes" }, { prim: "bool" }] }),
          ...stack.slice(3)
        ];
      case "VIEW": {
        const s2 = args(0, null, ["address"]);
        ensurePushableType(s2[0]);
        return [annotateVar({ prim: "option", args: [instruction2.args[1]] }), ...stack.slice(2)];
      }
      case "MIN_BLOCK_TIME":
        return [annotateVar({ prim: "nat" }), ...stack];
      case "EMIT": {
        const ia = instructionAnn({ f: 1, t: 1 });
        if (instruction2.args) {
          const s2 = args(0, null);
          ensureTypesEqual(s2[0], instruction2.args[0]);
          return [annotate({ prim: "operation" }, ia), ...stack.slice(1)];
        }
        return [annotate({ prim: "operation" }, ia), ...stack.slice(1)];
      }
      default:
        throw new MichelsonError(instruction2, `unexpected instruction: ${instruction2.prim}`);
    }
  })(instruction);
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== void 0) {
    const trace = {
      op: instruction,
      in: stack,
      out: retStack
    };
    ctx.traceCallback(trace);
  }
  return retStack;
}
function contractSection(contract, section) {
  for (const s2 of contract) {
    if (s2.prim === section) {
      return s2;
    }
  }
  throw new MichelsonError(contract, `missing contract section: ${section}`);
}
function contractViews(contract) {
  const views = {};
  for (const s2 of contract) {
    if (s2.prim === "view") {
      views[s2.args[0].string] = s2;
    }
  }
  return views;
}
function isContract(v2) {
  if (Array.isArray(v2)) {
    for (const s2 of v2) {
      if ("prim" in s2 && (s2.prim === "parameter" || s2.prim === "storage" || s2.prim === "code")) {
        return true;
      }
    }
  }
  return false;
}
function contractEntryPoint(src2, ep) {
  ep = ep || "%default";
  const entryPoint = contractEntryPoints(src2).find((x2) => x2[0] === ep);
  if (entryPoint !== void 0) {
    return entryPoint[1];
  } else if (ep === "%default") {
    return isContract(src2) ? contractSection(src2, "parameter").args[0] : src2;
  }
  return null;
}
function isOrType(t) {
  return Array.isArray(t) || t.prim === "or";
}
function contractEntryPoints(src2) {
  if (isContract(src2)) {
    const param = contractSection(src2, "parameter");
    const ch2 = contractEntryPoints(param.args[0]);
    const a2 = unpackAnnotations(param);
    return a2.f ? [[a2.f[0], param.args[0]], ...ch2] : ch2;
  }
  if (isOrType(src2)) {
    const args = typeArgs(src2);
    const getArg = (n) => {
      const a2 = unpackAnnotations(args[n]);
      if (typeID(args[n]) === "or") {
        const ch2 = contractEntryPoints(args[n]);
        return a2.f ? [[a2.f[0], args[n]], ...ch2] : ch2;
      }
      return a2.f ? [[a2.f[0], args[n]]] : [];
    };
    return [...getArg(0), ...getArg(1)];
  }
  return [];
}
function assertContractValid(contract, ctx) {
  const assertSection = (parameter2, storage2, ret2, code3) => {
    assertTypeAnnotationsValid(parameter2, true);
    assertTypeAnnotationsValid(storage2);
    const arg = {
      prim: "pair",
      args: [
        Object.assign(Object.assign({}, parameter2), { annots: ["@parameter"] }),
        Object.assign(Object.assign({}, storage2), { annots: ["@storage"] })
      ]
    };
    const out = functionTypeInternal(code3, [arg], Object.assign(Object.assign({}, ctx), { contract }));
    if ("failed" in out) {
      return out;
    }
    try {
      assertStacksEqual(out, [ret2]);
    } catch (err) {
      if (err instanceof MichelsonError) {
        throw new MichelsonInstructionError(code3, out, err.message);
      } else {
        throw err;
      }
    }
    return out;
  };
  const parameter = contractSection(contract, "parameter").args[0];
  const storage = contractSection(contract, "storage").args[0];
  const code2 = contractSection(contract, "code").args[0];
  const expected = {
    prim: "pair",
    args: [{ prim: "list", args: [{ prim: "operation" }] }, storage]
  };
  const ret = assertSection(parameter, storage, expected, code2);
  for (const view of Object.values(contractViews(contract))) {
    assertSection(view.args[1], storage, view.args[2], view.args[3]);
  }
  return ret;
}
function assertDataValid(d2, t, ctx) {
  assertTypeAnnotationsValid(t);
  assertDataValidInternal(d2, t, ctx || null);
}
function functionType(inst, stack, ctx) {
  for (const t of stack) {
    assertTypeAnnotationsValid(t);
  }
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== void 0) {
    for (const typesec of ["parameter", "storage"]) {
      const sec = contractSection(ctx.contract, typesec).args[0];
      assertTypeAnnotationsValid(sec);
    }
  }
  return functionTypeInternal(inst, stack, ctx || null);
}
function isDataValid(d2, t, ctx) {
  try {
    assertDataValid(d2, t, ctx);
    return true;
  } catch (_a2) {
    return false;
  }
}
class Contract {
  constructor(contract, opt) {
    this.contract = contract;
    this.ctx = Object.assign({ contract }, opt);
    this.output = assertContractValid(contract, this.ctx);
  }
  static parse(src2, opt) {
    const p2 = new Parser(opt);
    const expr = typeof src2 === "string" ? p2.parseScript(src2) : p2.parseJSON(src2);
    if (expr === null) {
      throw new InvalidContractError("empty contract");
    }
    if (assertMichelsonContract(expr)) {
      return new Contract(expr, opt);
    }
  }
  static parseTypeExpression(src2, opt) {
    const p2 = new Parser(opt);
    const expr = typeof src2 === "string" ? p2.parseScript(src2) : p2.parseJSON(src2);
    if (expr === null) {
      throw new InvalidTypeExpressionError("empty type expression");
    }
    if (assertMichelsonType(expr)) {
      assertTypeAnnotationsValid(expr);
      return expr;
    }
  }
  static parseDataExpression(src2, opt) {
    const p2 = new Parser(opt);
    const expr = typeof src2 === "string" ? p2.parseScript(src2) : p2.parseJSON(src2);
    if (expr === null) {
      throw new InvalidDataExpressionError("empty data expression");
    }
    if (assertMichelsonData(expr)) {
      return expr;
    }
    throw void 0;
  }
  section(section) {
    return contractSection(this.contract, section);
  }
  entryPoints() {
    return contractEntryPoints(this.contract);
  }
  entryPoint(ep) {
    return contractEntryPoint(this.contract, ep);
  }
  assertDataValid(d2, t) {
    assertDataValid(d2, t, this.ctx);
  }
  isDataValid(d2, t) {
    return isDataValid(d2, t, this.ctx);
  }
  assertParameterValid(ep, d2) {
    const t = this.entryPoint(ep || void 0);
    if (t === null) {
      throw new InvalidEntrypointError(ep === null || ep === void 0 ? void 0 : ep.toString());
    }
    this.assertDataValid(d2, t);
  }
  isParameterValid(ep, d2) {
    try {
      this.assertParameterValid(ep, d2);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  functionType(inst, stack) {
    return functionType(inst, stack, this.ctx);
  }
}
new Contract([
  { prim: "parameter", args: [{ prim: "unit" }] },
  { prim: "storage", args: [{ prim: "unit" }] },
  {
    prim: "code",
    args: [[{ prim: "CAR" }, { prim: "NIL", args: [{ prim: "operation" }] }, { prim: "PAIR" }]]
  }
]);
const toHexString$1 = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
const pad = (num, paddingLen = 8) => {
  return num.toString(16).padStart(paddingLen, "0");
};
const ENTRYPOINT_MAX_LENGTH = 31;
var CODEC;
(function(CODEC2) {
  CODEC2["SECRET"] = "secret";
  CODEC2["RAW"] = "raw";
  CODEC2["TZ1"] = "tz1";
  CODEC2["BRANCH"] = "branch";
  CODEC2["ZARITH"] = "zarith";
  CODEC2["PUBLIC_KEY"] = "public_key";
  CODEC2["PKH"] = "pkh";
  CODEC2["DELEGATE"] = "delegate";
  CODEC2["SCRIPT"] = "script";
  CODEC2["BALLOT_STATEMENT"] = "ballotStmt";
  CODEC2["PROPOSAL"] = "proposal";
  CODEC2["PROPOSAL_ARR"] = "proposalArr";
  CODEC2["INT32"] = "int32";
  CODEC2["INT16"] = "int16";
  CODEC2["PARAMETERS"] = "parameters";
  CODEC2["ADDRESS"] = "address";
  CODEC2["SMART_CONTRACT_ADDRESS"] = "smart_contract_address";
  CODEC2["VALUE"] = "value";
  CODEC2["MANAGER"] = "manager";
  CODEC2["BLOCK_PAYLOAD_HASH"] = "blockPayloadHash";
  CODEC2["ENTRYPOINT"] = "entrypoint";
  CODEC2["OPERATION"] = "operation";
  CODEC2["OP_ACTIVATE_ACCOUNT"] = "activate_account";
  CODEC2["OP_DELEGATION"] = "delegation";
  CODEC2["OP_TRANSACTION"] = "transaction";
  CODEC2["OP_ORIGINATION"] = "origination";
  CODEC2["OP_BALLOT"] = "ballot";
  CODEC2["OP_ENDORSEMENT"] = "endorsement";
  CODEC2["OP_SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  CODEC2["OP_REVEAL"] = "reveal";
  CODEC2["OP_PROPOSALS"] = "proposals";
  CODEC2["OP_REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
  CODEC2["OP_TRANSFER_TICKET"] = "transfer_ticket";
  CODEC2["OP_TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
  CODEC2["OP_TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
  CODEC2["BURN_LIMIT"] = "burn_limit";
  CODEC2["TX_ROLLUP_ORIGINATION_PARAM"] = "tx_rollup_origination_param";
  CODEC2["TX_ROLLUP_ID"] = "tx_rollup_id";
  CODEC2["TX_ROLLUP_BATCH_CONTENT"] = "tx_rollup_batch_content";
  CODEC2["OP_INCREASE_PAID_STORAGE"] = "increase_paid_storage";
  CODEC2["OP_UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
  CODEC2["OP_DRAIN_DELEGATE"] = "drain_delegate";
})(CODEC || (CODEC = {}));
const opMapping = {
  "00": "parameter",
  "01": "storage",
  "02": "code",
  "03": "False",
  "04": "Elt",
  "05": "Left",
  "06": "None",
  "07": "Pair",
  "08": "Right",
  "09": "Some",
  "0a": "True",
  "0b": "Unit",
  "0c": "PACK",
  "0d": "UNPACK",
  "0e": "BLAKE2B",
  "0f": "SHA256",
  "10": "SHA512",
  "11": "ABS",
  "12": "ADD",
  "13": "AMOUNT",
  "14": "AND",
  "15": "BALANCE",
  "16": "CAR",
  "17": "CDR",
  "18": "CHECK_SIGNATURE",
  "19": "COMPARE",
  "1a": "CONCAT",
  "1b": "CONS",
  "1c": "CREATE_ACCOUNT",
  "1d": "CREATE_CONTRACT",
  "1e": "IMPLICIT_ACCOUNT",
  "1f": "DIP",
  "20": "DROP",
  "21": "DUP",
  "22": "EDIV",
  "23": "EMPTY_MAP",
  "24": "EMPTY_SET",
  "25": "EQ",
  "26": "EXEC",
  "27": "FAILWITH",
  "28": "GE",
  "29": "GET",
  "2a": "GT",
  "2b": "HASH_KEY",
  "2c": "IF",
  "2d": "IF_CONS",
  "2e": "IF_LEFT",
  "2f": "IF_NONE",
  "30": "INT",
  "31": "LAMBDA",
  "32": "LE",
  "33": "LEFT",
  "34": "LOOP",
  "35": "LSL",
  "36": "LSR",
  "37": "LT",
  "38": "MAP",
  "39": "MEM",
  "3a": "MUL",
  "3b": "NEG",
  "3c": "NEQ",
  "3d": "NIL",
  "3e": "NONE",
  "3f": "NOT",
  "40": "NOW",
  "41": "OR",
  "42": "PAIR",
  "43": "PUSH",
  "44": "RIGHT",
  "45": "SIZE",
  "46": "SOME",
  "47": "SOURCE",
  "48": "SENDER",
  "49": "SELF",
  "4a": "STEPS_TO_QUOTA",
  "4b": "SUB",
  "4c": "SWAP",
  "4d": "TRANSFER_TOKENS",
  "4e": "SET_DELEGATE",
  "4f": "UNIT",
  "50": "UPDATE",
  "51": "XOR",
  "52": "ITER",
  "53": "LOOP_LEFT",
  "54": "ADDRESS",
  "55": "CONTRACT",
  "56": "ISNAT",
  "57": "CAST",
  "58": "RENAME",
  "59": "bool",
  "5a": "contract",
  "5b": "int",
  "5c": "key",
  "5d": "key_hash",
  "5e": "lambda",
  "5f": "list",
  "60": "map",
  "61": "big_map",
  "62": "nat",
  "63": "option",
  "64": "or",
  "65": "pair",
  "66": "set",
  "67": "signature",
  "68": "string",
  "69": "bytes",
  "6a": "mutez",
  "6b": "timestamp",
  "6c": "unit",
  "6d": "operation",
  "6e": "address",
  "6f": "SLICE",
  "70": "DIG",
  "71": "DUG",
  "72": "EMPTY_BIG_MAP",
  "73": "APPLY",
  "74": "chain_id",
  "75": "CHAIN_ID",
  "76": "LEVEL",
  "77": "SELF_ADDRESS",
  "78": "never",
  "79": "NEVER",
  "7a": "UNPAIR",
  "7b": "VOTING_POWER",
  "7c": "TOTAL_VOTING_POWER",
  "7d": "KECCAK",
  "7e": "SHA3",
  "7f": "PAIRING_CHECK",
  "80": "bls12_381_g1",
  "81": "bls12_381_g2",
  "82": "bls12_381_fr",
  "83": "sapling_state",
  "84": "sapling_transaction_deprecated",
  "85": "SAPLING_EMPTY_STATE",
  "86": "SAPLING_VERIFY_UPDATE",
  "87": "ticket",
  "88": "TICKET_DEPRECATED",
  "89": "READ_TICKET",
  "8a": "SPLIT_TICKET",
  "8b": "JOIN_TICKETS",
  "8c": "GET_AND_UPDATE",
  "8d": "chest",
  "8e": "chest_key",
  "8f": "OPEN_CHEST",
  "90": "VIEW",
  "91": "view",
  "92": "constant",
  "93": "SUB_MUTEZ",
  "94": "tx_rollup_l2_address",
  "95": "MIN_BLOCK_TIME",
  "96": "sapling_transaction",
  "97": "EMIT",
  "98": "Lambda_rec",
  "99": "LAMBDA_REC",
  "9a": "TICKET"
};
const opMappingReverse = (() => {
  const result = {};
  Object.keys(opMapping).forEach((key2) => {
    result[opMapping[key2]] = key2;
  });
  return result;
})();
const kindMapping = {
  4: "activate_account",
  107: "reveal",
  110: "delegation",
  108: "transaction",
  109: "origination",
  6: "ballot",
  21: "endorsement",
  1: "seed_nonce_revelation",
  5: "proposals",
  111: "register_global_constant",
  150: "tx_rollup_origination",
  151: "tx_rollup_submit_batch",
  158: "transfer_ticket",
  113: "increase_paid_storage",
  114: "update_consensus_key",
  9: "drain_delegate"
};
const kindMappingReverse = (() => {
  const result = {};
  Object.keys(kindMapping).forEach((key2) => {
    const keyNum = typeof key2 === "string" ? parseInt(key2, 10) : key2;
    result[kindMapping[keyNum]] = pad(keyNum, 2);
  });
  return result;
})();
const entrypointMapping = {
  "00": "default",
  "01": "root",
  "02": "do",
  "03": "set_delegate",
  "04": "remove_delegate",
  "05": "deposit"
};
const entrypointMappingReverse = (() => {
  const result = {};
  Object.keys(entrypointMapping).forEach((key2) => {
    result[entrypointMapping[key2]] = key2;
  });
  return result;
})();
class InvalidBlockHashError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidBlockHashError";
  }
}
class InvalidOperationSchemaError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidOperationSchemaError";
  }
}
class OversizedEntryPointError extends Error {
  constructor(entrypoint) {
    super(`Oversized entrypoint: ${entrypoint}. The maximum length of entrypoint is ${ENTRYPOINT_MAX_LENGTH}`);
    this.entrypoint = entrypoint;
    this.name = "OversizedEntryPointError";
  }
}
class InvalidBallotValueError extends Error {
  constructor(ballotValue) {
    super(`The ballot value '${ballotValue}' is invalid`);
    this.ballotValue = ballotValue;
    this.name = "InvalidBallotValueError";
  }
}
class DecodeBallotValueError extends Error {
  constructor(ballotValue) {
    super(`Failed to decode ballot value ${ballotValue}`);
    this.ballotValue = ballotValue;
    this.name = "DecodeBallotValueError";
  }
}
class InvalidHexStringError extends Error {
  constructor(hexString) {
    super(`The hex string '${hexString}' is invalid`);
    this.hexString = hexString;
    this.name = "InvalidHexStringError";
  }
}
class UnexpectedMichelsonValueError extends Error {
  constructor(value) {
    super(`Failed to encode michelson value '${value}'`);
    this.value = value;
    this.name = "UnexpectedMichelsonValueError";
  }
}
class OperationDecodingError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "OperationDecodingError";
  }
}
class OperationEncodingError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "OperationEncodingError";
  }
}
class UnsupportedOperationError extends Error {
  constructor(op) {
    super(`The operation '${op}' is unsupported`);
    this.op = op;
    this.name = "UnsupportedOperationError";
  }
}
class Uint8ArrayConsumer {
  constructor(arr, offset = 0) {
    this.arr = arr;
    this.offset = offset;
  }
  static fromHexString(hex) {
    const lowHex = hex.toLowerCase();
    if (/^(([a-f]|\d){2})*$/.test(lowHex)) {
      const arr = new Uint8Array((lowHex.match(/([a-z]|\d){2}/g) || []).map((byte) => parseInt(byte, 16)));
      return new Uint8ArrayConsumer(arr);
    } else {
      throw new InvalidHexStringError(lowHex);
    }
  }
  consume(count) {
    const subArr = this.arr.subarray(this.offset, this.offset + count);
    this.offset += count;
    return subArr;
  }
  get(idx) {
    return this.arr[this.offset + idx];
  }
  length() {
    return this.arr.length - this.offset;
  }
}
const isPrim = (value) => {
  return "prim" in value;
};
const isBytes = (value) => {
  return "bytes" in value && typeof value.bytes === "string";
};
const isString = (value) => {
  return "string" in value && typeof value.string === "string";
};
const isInt = (value) => {
  return "int" in value && typeof value.int === "string";
};
const scriptEncoder = (script) => {
  const code2 = valueEncoder(script.code);
  const storage = valueEncoder(script.storage);
  return `${pad(code2.length / 2, 8)}${code2}${pad(storage.length / 2, 8)}${storage}`;
};
const scriptDecoder = (value) => {
  const code2 = extractRequiredLen(value);
  const storage = extractRequiredLen(value);
  return {
    code: valueDecoder(new Uint8ArrayConsumer(code2)),
    storage: valueDecoder(new Uint8ArrayConsumer(storage))
  };
};
const valueEncoder = (value) => {
  if (Array.isArray(value)) {
    const encoded = value.map((x2) => valueEncoder(x2)).join("");
    const len2 = encoded.length / 2;
    return `02${pad(len2)}${encoded}`;
  } else if (isPrim(value)) {
    return primEncoder(value);
  } else if (isBytes(value)) {
    return bytesEncoder(value);
  } else if (isString(value)) {
    return stringEncoder(value);
  } else if (isInt(value)) {
    return intEncoder(value);
  }
  throw new UnexpectedMichelsonValueError(JSON.stringify(value));
};
const valueDecoder = (value) => {
  const preamble = value.consume(1);
  switch (preamble[0]) {
    case 10:
      return bytesDecoder(value);
    case 1:
      return stringDecoder(value);
    case 0:
      return intDecoder(value);
    case 2: {
      const val = new Uint8ArrayConsumer(extractRequiredLen(value));
      const results = [];
      while (val.length() > 0) {
        results.push(valueDecoder(val));
      }
      return results;
    }
    default:
      return primDecoder(value, preamble);
  }
};
const extractRequiredLen = (value, bytesLength = 4) => {
  const len2 = value.consume(bytesLength);
  const valueLen = parseInt(Buffer.from(len2).toString("hex"), 16);
  return value.consume(valueLen);
};
const bytesEncoder = (value) => {
  if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
    throw new InvalidHexStringError(value.bytes);
  }
  const len2 = value.bytes.length / 2;
  return `0a${pad(len2)}${value.bytes}`;
};
const bytesDecoder = (value) => {
  const bytes = extractRequiredLen(value);
  return {
    bytes: Buffer.from(bytes).toString("hex")
  };
};
const stringEncoder = (value) => {
  const str = Buffer.from(value.string, "utf8").toString("hex");
  const hexLength = str.length / 2;
  return `01${pad(hexLength)}${str}`;
};
const stringDecoder = (value) => {
  const str = extractRequiredLen(value);
  return {
    string: Buffer.from(str).toString("utf8")
  };
};
const intEncoder = ({ int: int2 }) => {
  const num = new BigNumber$1(int2, 10);
  const positiveMark = num.toString(2)[0] === "-" ? "1" : "0";
  const binary2 = num.toString(2).replace(/-/g, "");
  const pad3 = binary2.length <= 6 ? 6 : (binary2.length - 6) % 7 ? binary2.length + 7 - (binary2.length - 6) % 7 : binary2.length;
  const splitted = binary2.padStart(pad3, "0").match(/\d{6,7}/g);
  const reversed = splitted.reverse();
  reversed[0] = positiveMark + reversed[0];
  const numHex = reversed.map((x2, i2) => // Add one to the last chunk
  parseInt((i2 === reversed.length - 1 ? "0" : "1") + x2, 2).toString(16).padStart(2, "0"));
  return `00${numHex.join("")}`;
};
const intDecoder = (value) => {
  let c2 = value.consume(1)[0];
  const hexNumber = [];
  const isNotLastChunkMask = 1 << 7;
  while (c2 & isNotLastChunkMask) {
    hexNumber.push(c2);
    c2 = value.consume(1)[0];
  }
  hexNumber.push(c2);
  const isNegative = !!(1 << 6 & hexNumber[0]);
  hexNumber[0] = hexNumber[0] & 127;
  const numBin = hexNumber.map((x2, i2) => x2.toString(2).slice(i2 === 0 ? -6 : -7).padStart(i2 === 0 ? 6 : 7, "0")).reverse();
  let num = new BigNumber$1(numBin.join(""), 2);
  if (isNegative) {
    num = num.times(-1);
  }
  return {
    int: num.toFixed()
  };
};
const primEncoder = (value) => {
  const hasAnnot = +Array.isArray(value.annots);
  const argsCount = Array.isArray(value.args) ? value.args.length : 0;
  const preamble = pad(Math.min(2 * argsCount + hasAnnot + 3, 9), 2);
  const op = opMappingReverse[value.prim];
  let encodedArgs = (value.args || []).map((arg) => valueEncoder(arg)).join("");
  const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : "";
  if ((value.prim === "LAMBDA" || value.prim === "LAMBDA_REC") && argsCount) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  if ((value.prim === "pair" || value.prim === "Pair") && argsCount > 2) {
    encodedArgs = encodedAnnots === "" ? pad(encodedArgs.length / 2) + encodedArgs + pad(0) : pad(encodedArgs.length / 2) + encodedArgs;
  }
  if (value.prim === "view" && value.args) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
const primDecoder = (value, preamble) => {
  const hasAnnot = (preamble[0] - 3) % 2 === 1;
  let argsCount = Math.floor((preamble[0] - 3) / 2);
  const op = value.consume(1)[0].toString(16).padStart(2, "0");
  const result = {
    prim: opMapping[op]
  };
  if (opMapping[op] === "LAMBDA" || opMapping[op] === "LAMBDA_REC") {
    value.consume(4);
  }
  if (opMapping[op] === "view") {
    if (argsCount != 0) {
      return primViewDecoder(value, result);
    } else {
      return result;
    }
  }
  let combPairArgs;
  let combPairAnnots;
  if ((opMapping[op] === "pair" || opMapping[op] === "Pair") && argsCount > 2) {
    combPairArgs = decodeCombPair$1(value);
    argsCount = 0;
    combPairAnnots = decodeAnnots(value);
  }
  const args = new Array(argsCount).fill(0).map(() => valueDecoder(value));
  if (opMapping[op] === "LAMBDA" || opMapping[op] === "LAMBDA_REC") {
    value.consume(4);
  }
  if (combPairArgs) {
    result["args"] = combPairArgs;
  } else if (args.length) {
    result["args"] = args;
  }
  if (combPairAnnots && combPairAnnots[0] !== "") {
    result["annots"] = combPairAnnots;
  } else if (hasAnnot) {
    result["annots"] = decodeAnnots(value);
  }
  return result;
};
const primViewDecoder = (value, result) => {
  value.consume(4);
  result["args"] = new Array(4).fill(0).map(() => valueDecoder(value));
  value.consume(4);
  return result;
};
const decodeCombPair$1 = (val) => {
  const array = new Uint8ArrayConsumer(extractRequiredLen(val));
  const args = [];
  while (array.length() > 0) {
    args.push(valueDecoder(array));
  }
  return args;
};
const encodeAnnots = (value) => {
  const mergedAnnot = value.map((x2) => {
    return Buffer.from(x2, "utf8").toString("hex");
  }).join("20");
  const len2 = mergedAnnot.length / 2;
  return `${pad(len2)}${mergedAnnot}`;
};
const decodeAnnots = (val) => {
  const len2 = val.consume(4);
  const annotLen = parseInt(Buffer.from(len2).toString("hex"), 16);
  const restOfAnnot = val.consume(annotLen);
  const restOfAnnotHex = Buffer.from(restOfAnnot).toString("hex");
  return restOfAnnotHex.split("20").map((x2) => Buffer.from(x2, "hex").toString("utf8"));
};
const prefixEncoder = (prefix$1) => (str) => {
  return buf2hex(Buffer.from(b58cdecode(str, prefix[prefix$1])));
};
const prefixDecoder = (pre) => (str) => {
  const val = str.consume(prefixLength[pre]);
  return b58cencode(val, prefix[pre]);
};
const tz1Decoder = prefixDecoder(Prefix.TZ1);
const branchDecoder = prefixDecoder(Prefix.B);
const pkhDecoder = (val) => {
  const prefix2 = val.consume(1);
  if (prefix2[0] === 0) {
    return prefixDecoder(Prefix.TZ1)(val);
  } else if (prefix2[0] === 1) {
    return prefixDecoder(Prefix.TZ2)(val);
  } else if (prefix2[0] === 2) {
    return prefixDecoder(Prefix.TZ3)(val);
  }
};
const branchEncoder = prefixEncoder(Prefix.B);
const tz1Encoder = prefixEncoder(Prefix.TZ1);
const boolEncoder = (bool) => bool ? "ff" : "00";
const proposalEncoder = (proposal) => {
  return prefixEncoder(Prefix.P)(proposal);
};
const proposalDecoder = (proposal) => {
  return prefixDecoder(Prefix.P)(proposal);
};
const proposalsDecoder = (proposal) => {
  const proposals = [];
  proposal.consume(4);
  while (proposal.length() > 0) {
    proposals.push(proposalDecoder(proposal));
  }
  return proposals;
};
const proposalsEncoder = (proposals) => {
  return pad(32 * proposals.length) + proposals.map((x2) => proposalEncoder(x2)).join("");
};
const ballotEncoder = (ballot) => {
  switch (ballot) {
    case "yay":
      return "00";
    case "nay":
      return "01";
    case "pass":
      return "02";
    default:
      throw new InvalidBallotValueError(ballot);
  }
};
const ballotDecoder = (ballot) => {
  const value = ballot.consume(1);
  switch (value[0]) {
    case 0:
      return "yay";
    case 1:
      return "nay";
    case 2:
      return "pass";
    default:
      throw new DecodeBallotValueError(value[0].toString());
  }
};
const delegateEncoder = (val) => {
  if (val) {
    return boolEncoder(true) + pkhEncoder(val);
  } else {
    return boolEncoder(false);
  }
};
const int32Encoder = (val) => {
  const num = parseInt(String(val), 10);
  const byte = [];
  for (let i2 = 0; i2 < 4; i2++) {
    const shiftBy = (4 - (i2 + 1)) * 8;
    byte.push((num & 255 << shiftBy) >> shiftBy);
  }
  return Buffer.from(byte).toString("hex");
};
const int32Decoder = (val) => {
  const num = val.consume(4);
  let finalNum = 0;
  for (let i2 = 0; i2 < num.length; i2++) {
    finalNum = finalNum | num[i2] << (num.length - (i2 + 1)) * 8;
  }
  return finalNum;
};
const int16Encoder = (val) => {
  const num = parseInt(String(val), 10);
  const byte = [];
  for (let i2 = 0; i2 < 2; i2++) {
    const shiftBy = (2 - (i2 + 1)) * 8;
    byte.push((num & 255 << shiftBy) >> shiftBy);
  }
  return Buffer.from(byte).toString("hex");
};
const int16Decoder = (val) => {
  const num = val.consume(2);
  let finalNum = 0;
  for (let i2 = 0; i2 < num.length; i2++) {
    finalNum = finalNum | num[i2] << (num.length - (i2 + 1)) * 8;
  }
  return finalNum;
};
const boolDecoder = (val) => {
  const bool = val.consume(1);
  return bool[0] === 255;
};
const delegateDecoder = (val) => {
  const hasDelegate = boolDecoder(val);
  if (hasDelegate) {
    return pkhDecoder(val);
  }
};
const pkhEncoder = (val) => {
  const pubkeyPrefix = val.substr(0, 3);
  switch (pubkeyPrefix) {
    case Prefix.TZ1:
      return "00" + prefixEncoder(Prefix.TZ1)(val);
    case Prefix.TZ2:
      return "01" + prefixEncoder(Prefix.TZ2)(val);
    case Prefix.TZ3:
      return "02" + prefixEncoder(Prefix.TZ3)(val);
    default:
      throw new InvalidKeyHashError(val);
  }
};
const publicKeyEncoder = (val) => {
  const pubkeyPrefix = val.substr(0, 4);
  switch (pubkeyPrefix) {
    case Prefix.EDPK:
      return "00" + prefixEncoder(Prefix.EDPK)(val);
    case Prefix.SPPK:
      return "01" + prefixEncoder(Prefix.SPPK)(val);
    case Prefix.P2PK:
      return "02" + prefixEncoder(Prefix.P2PK)(val);
    default:
      throw new InvalidPublicKeyError(val);
  }
};
const addressEncoder = (val) => {
  const pubkeyPrefix = val.substr(0, 3);
  switch (pubkeyPrefix) {
    case Prefix.TZ1:
    case Prefix.TZ2:
    case Prefix.TZ3:
      return "00" + pkhEncoder(val);
    case Prefix.KT1:
      return "01" + prefixEncoder(Prefix.KT1)(val) + "00";
    default:
      throw new InvalidAddressError(val);
  }
};
const smartContractAddressEncoder = (val) => {
  const prefix2 = val.substring(0, 3);
  if (prefix2 === Prefix.KT1) {
    return "01" + prefixEncoder(Prefix.KT1)(val) + "00";
  }
  throw new InvalidContractAddressError(val);
};
const publicKeyDecoder = (val) => {
  const preamble = val.consume(1);
  switch (preamble[0]) {
    case 0:
      return prefixDecoder(Prefix.EDPK)(val);
    case 1:
      return prefixDecoder(Prefix.SPPK)(val);
    case 2:
      return prefixDecoder(Prefix.P2PK)(val);
    default:
      throw new InvalidPublicKeyError(val.toString());
  }
};
const addressDecoder = (val) => {
  const preamble = val.consume(1);
  switch (preamble[0]) {
    case 0:
      return pkhDecoder(val);
    case 1: {
      const address = prefixDecoder(Prefix.KT1)(val);
      val.consume(1);
      return address;
    }
    default:
      throw new InvalidAddressError(val.toString());
  }
};
const smartContractAddressDecoder = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 1) {
    const scAddress = prefixDecoder(Prefix.KT1)(val);
    val.consume(1);
    return scAddress;
  }
  throw new InvalidContractAddressError(val.toString());
};
const zarithEncoder = (n) => {
  const fn = [];
  let nn = new BigNumber$1(n, 10);
  if (nn.isNaN()) {
    throw new TypeError(`Invalid zarith number ${n}`);
  }
  while (true) {
    if (nn.lt(128)) {
      if (nn.lt(16))
        fn.push("0");
      fn.push(nn.toString(16));
      break;
    } else {
      let b2 = nn.mod(128);
      nn = nn.minus(b2);
      nn = nn.dividedBy(128);
      b2 = b2.plus(128);
      fn.push(b2.toString(16));
    }
  }
  return fn.join("");
};
const zarithDecoder = (n) => {
  let mostSignificantByte = 0;
  while (mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0) {
    mostSignificantByte += 1;
  }
  let num = new BigNumber$1(0);
  for (let i2 = mostSignificantByte; i2 >= 0; i2 -= 1) {
    const tmp = n.get(i2) & 127;
    num = num.multipliedBy(128);
    num = num.plus(tmp);
  }
  n.consume(mostSignificantByte + 1);
  return new BigNumber$1(num).toString();
};
const entrypointDecoder = (value) => {
  const preamble = pad(value.consume(1)[0], 2);
  if (preamble in entrypointMapping) {
    return entrypointMapping[preamble];
  } else {
    const entry = extractRequiredLen(value, 1);
    const entrypoint = Buffer.from(entry).toString("utf8");
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    return entrypoint;
  }
};
const parametersDecoder = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 0) {
    return;
  } else {
    const encodedEntrypoint = entrypointDecoder(val);
    const params = extractRequiredLen(val);
    const parameters = valueDecoder(new Uint8ArrayConsumer(params));
    return {
      entrypoint: encodedEntrypoint,
      value: parameters
    };
  }
};
const entrypointEncoder = (entrypoint) => {
  if (entrypoint in entrypointMappingReverse) {
    return `${entrypointMappingReverse[entrypoint]}`;
  } else {
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    const value = { string: entrypoint };
    return `ff${valueEncoder(value).slice(8)}`;
  }
};
const parametersEncoder = (val) => {
  if (!val || val.entrypoint === "default" && "prim" in val.value && val.value.prim === "Unit") {
    return "00";
  }
  const encodedEntrypoint = entrypointEncoder(val.entrypoint);
  const parameters = valueEncoder(val.value);
  const length = (parameters.length / 2).toString(16).padStart(8, "0");
  return `ff${encodedEntrypoint}${length}${parameters}`;
};
const valueParameterEncoder = (value) => {
  const valueEncoded = valueEncoder(value);
  return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
const valueParameterDecoder = (val) => {
  const value = extractRequiredLen(val);
  return valueDecoder(new Uint8ArrayConsumer(value));
};
const blockPayloadHashEncoder = prefixEncoder(Prefix.VH);
const blockPayloadHashDecoder = prefixDecoder(Prefix.VH);
const entrypointNameEncoder = (entrypoint) => {
  const value = { string: entrypoint };
  return `${valueEncoder(value).slice(2)}`;
};
const entrypointNameDecoder = (val) => {
  const entry = extractRequiredLen(val);
  return Buffer.from(entry).toString("utf8");
};
const txRollupOriginationParamEncoder = (_value) => {
  return "";
};
const txRollupOriginationParamDecoder = (_val) => {
  return {};
};
const txRollupIdEncoder = prefixEncoder(Prefix.TXR1);
const txRollupIdDecoder = prefixDecoder(Prefix.TXR1);
const txRollupBatchContentEncoder = (value) => {
  return `${pad(value.length / 2)}${value}`;
};
const txRollupBatchContentDecoder = (val) => {
  const value = extractRequiredLen(val);
  return Buffer.from(value).toString("hex");
};
const burnLimitEncoder = (val) => {
  return !val ? "00" : `ff${zarithEncoder(val)}`;
};
const burnLimitDecoder = (value) => {
  const prefix2 = value.consume(1);
  if (Buffer.from(prefix2).toString("hex") !== "00") {
    return zarithDecoder(value);
  }
};
const ManagerOperationSchema = {
  branch: CODEC.BRANCH,
  contents: [CODEC.OPERATION]
};
const ActivationSchema = {
  pkh: CODEC.TZ1,
  secret: CODEC.SECRET
};
const RevealSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  public_key: CODEC.PUBLIC_KEY
};
const DelegationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  delegate: CODEC.DELEGATE
};
const TransactionSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  amount: CODEC.ZARITH,
  destination: CODEC.ADDRESS,
  parameters: CODEC.PARAMETERS
};
const OriginationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  balance: CODEC.ZARITH,
  delegate: CODEC.DELEGATE,
  script: CODEC.SCRIPT
};
const BallotSchema = {
  source: CODEC.PKH,
  period: CODEC.INT32,
  proposal: CODEC.PROPOSAL,
  ballot: CODEC.BALLOT_STATEMENT
};
const EndorsementSchema = {
  slot: CODEC.INT16,
  level: CODEC.INT32,
  round: CODEC.INT32,
  block_payload_hash: CODEC.BLOCK_PAYLOAD_HASH
};
const SeedNonceRevelationSchema = {
  level: CODEC.INT32,
  nonce: CODEC.RAW
};
const ProposalsSchema = {
  source: CODEC.PKH,
  period: CODEC.INT32,
  proposals: CODEC.PROPOSAL_ARR
};
const RegisterGlobalConstantSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  value: CODEC.VALUE
};
const TransferTicketSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  ticket_contents: CODEC.VALUE,
  ticket_ty: CODEC.VALUE,
  ticket_ticketer: CODEC.ADDRESS,
  ticket_amount: CODEC.ZARITH,
  destination: CODEC.ADDRESS,
  entrypoint: CODEC.ENTRYPOINT
};
const TxRollupOriginationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  tx_rollup_origination: CODEC.TX_ROLLUP_ORIGINATION_PARAM
};
const TxRollupSubmitBatchSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  rollup: CODEC.TX_ROLLUP_ID,
  content: CODEC.TX_ROLLUP_BATCH_CONTENT,
  burn_limit: CODEC.BURN_LIMIT
};
const IncreasePaidStorageSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  amount: CODEC.ZARITH,
  destination: CODEC.SMART_CONTRACT_ADDRESS
};
const UpdateConsensusKeySchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  pk: CODEC.PUBLIC_KEY
};
const DrainDelegateSchema = {
  consensus_key: CODEC.PKH,
  delegate: CODEC.PKH,
  destination: CODEC.PKH
};
const operationEncoder = (encoders2) => (operation) => {
  if (!(operation.kind in encoders2) || !(operation.kind in kindMappingReverse)) {
    throw new InvalidOperationKindError(operation.kind);
  }
  return kindMappingReverse[operation.kind] + encoders2[operation.kind](operation);
};
const operationDecoder = (decoders2) => (value) => {
  const op = value.consume(1);
  const operationName = kindMapping[op[0]];
  if (operationName === void 0) {
    throw new UnsupportedOperationError(op[0].toString());
  }
  const decodedObj = decoders2[operationName](value);
  if (typeof decodedObj !== "object") {
    throw new OperationDecodingError("Decoded invalid operation");
  }
  return Object.assign({ kind: operationName }, decodedObj);
};
const schemaEncoder = (encoders2) => (schema) => (value) => {
  const keys = Object.keys(schema);
  return keys.reduce((prev, key2) => {
    const valueToEncode = schema[key2];
    if (value && Array.isArray(valueToEncode)) {
      const encoder = encoders2[valueToEncode[0]];
      const values = value[key2];
      if (!Array.isArray(values)) {
        throw new OperationEncodingError(`Expected value to be Array ${JSON.stringify(values)}`);
      }
      return prev + values.reduce((prevBytes, current) => prevBytes + encoder(current), "");
    } else {
      const encoder = encoders2[valueToEncode];
      return prev + encoder(value[key2]);
    }
  }, "");
};
const schemaDecoder = (decoders2) => (schema) => (value) => {
  const keys = Object.keys(schema);
  return keys.reduce((prev, key2) => {
    const valueToEncode = schema[key2];
    if (Array.isArray(valueToEncode)) {
      const decoder = decoders2[valueToEncode[0]];
      const decoded = [];
      const lastLength = value.length();
      while (value.length() > 0) {
        decoded.push(decoder(value));
        if (lastLength === value.length()) {
          throw new OperationDecodingError("Unable to decode value");
        }
      }
      return Object.assign(Object.assign({}, prev), { [key2]: decoded });
    } else {
      const decoder = decoders2[valueToEncode];
      const result = decoder(value);
      if (typeof result !== "undefined") {
        return Object.assign(Object.assign({}, prev), { [key2]: result });
      } else {
        return Object.assign({}, prev);
      }
    }
  }, {});
};
const decoders = {
  [CODEC.SECRET]: (val) => toHexString$1(val.consume(20)),
  [CODEC.RAW]: (val) => toHexString$1(val.consume(32)),
  [CODEC.TZ1]: tz1Decoder,
  [CODEC.BRANCH]: branchDecoder,
  [CODEC.ZARITH]: zarithDecoder,
  [CODEC.PUBLIC_KEY]: publicKeyDecoder,
  [CODEC.PKH]: pkhDecoder,
  [CODEC.DELEGATE]: delegateDecoder,
  [CODEC.INT32]: int32Decoder,
  [CODEC.SCRIPT]: scriptDecoder,
  [CODEC.BALLOT_STATEMENT]: ballotDecoder,
  [CODEC.PROPOSAL]: proposalDecoder,
  [CODEC.PROPOSAL_ARR]: proposalsDecoder,
  [CODEC.PARAMETERS]: parametersDecoder,
  [CODEC.ADDRESS]: addressDecoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,
  [CODEC.VALUE]: valueParameterDecoder,
  [CODEC.INT16]: int16Decoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
  [CODEC.ENTRYPOINT]: entrypointNameDecoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdDecoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoder,
  [CODEC.BURN_LIMIT]: burnLimitDecoder
};
decoders[CODEC.OPERATION] = operationDecoder(decoders);
decoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decoders)(ActivationSchema)(val);
decoders[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decoders)(DelegationSchema)(val);
decoders[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decoders)(TransactionSchema)(val);
decoders[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decoders)(OriginationSchema)(val);
decoders[CODEC.OP_BALLOT] = (val) => schemaDecoder(decoders)(BallotSchema)(val);
decoders[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decoders)(EndorsementSchema)(val);
decoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);
decoders[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decoders)(ProposalsSchema)(val);
decoders[CODEC.OP_REVEAL] = (val) => schemaDecoder(decoders)(RevealSchema)(val);
decoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);
decoders[CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decoders)(TransferTicketSchema)(val);
decoders[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decoders)(TxRollupOriginationSchema)(val);
decoders[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decoders)(TxRollupSubmitBatchSchema)(val);
decoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaDecoder(decoders)(IncreasePaidStorageSchema)(val);
decoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaDecoder(decoders)(UpdateConsensusKeySchema)(val);
decoders[CODEC.OP_DRAIN_DELEGATE] = (val) => schemaDecoder(decoders)(DrainDelegateSchema)(val);
decoders[CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);
const encoders = {
  [CODEC.SECRET]: (val) => val,
  [CODEC.RAW]: (val) => val,
  [CODEC.TZ1]: tz1Encoder,
  [CODEC.BRANCH]: branchEncoder,
  [CODEC.ZARITH]: zarithEncoder,
  [CODEC.PUBLIC_KEY]: publicKeyEncoder,
  [CODEC.PKH]: pkhEncoder,
  [CODEC.DELEGATE]: delegateEncoder,
  [CODEC.SCRIPT]: scriptEncoder,
  [CODEC.BALLOT_STATEMENT]: ballotEncoder,
  [CODEC.PROPOSAL]: proposalEncoder,
  [CODEC.PROPOSAL_ARR]: proposalsEncoder,
  [CODEC.INT32]: int32Encoder,
  [CODEC.PARAMETERS]: parametersEncoder,
  [CODEC.ADDRESS]: addressEncoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,
  [CODEC.VALUE]: valueParameterEncoder,
  [CODEC.INT16]: int16Encoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
  [CODEC.ENTRYPOINT]: entrypointNameEncoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdEncoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoder,
  [CODEC.BURN_LIMIT]: burnLimitEncoder
};
encoders[CODEC.OPERATION] = operationEncoder(encoders);
encoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encoders)(ActivationSchema)(val);
encoders[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encoders)(DelegationSchema)(val);
encoders[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encoders)(TransactionSchema)(val);
encoders[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encoders)(OriginationSchema)(val);
encoders[CODEC.OP_BALLOT] = (val) => schemaEncoder(encoders)(BallotSchema)(val);
encoders[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encoders)(EndorsementSchema)(val);
encoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);
encoders[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encoders)(ProposalsSchema)(val);
encoders[CODEC.OP_REVEAL] = (val) => schemaEncoder(encoders)(RevealSchema)(val);
encoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);
encoders[CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encoders)(TransferTicketSchema)(val);
encoders[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encoders)(TxRollupOriginationSchema)(val);
encoders[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encoders)(TxRollupSubmitBatchSchema)(val);
encoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaEncoder(encoders)(IncreasePaidStorageSchema)(val);
encoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaEncoder(encoders)(UpdateConsensusKeySchema)(val);
encoders[CODEC.OP_DRAIN_DELEGATE] = (val) => schemaEncoder(encoders)(DrainDelegateSchema)(val);
encoders[CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);
const OperationKindMapping = {
  activate_account: ActivationSchema,
  reveal: RevealSchema,
  delegation: DelegationSchema,
  transaction: TransactionSchema,
  origination: OriginationSchema,
  ballot: BallotSchema,
  endorsement: EndorsementSchema,
  seed_nonce_revelation: SeedNonceRevelationSchema,
  proposals: ProposalsSchema,
  register_global_constant: RegisterGlobalConstantSchema,
  transfer_ticket: TransferTicketSchema,
  tx_rollup_origination: TxRollupOriginationSchema,
  tx_rollup_submit_batch: TxRollupSubmitBatchSchema,
  increase_paid_storage: IncreasePaidStorageSchema,
  update_consensus_key: UpdateConsensusKeySchema,
  drain_delegate: DrainDelegateSchema
};
const getArrayDifference = (arr1, arr2) => {
  return arr2.filter((x2) => !arr1.includes(x2));
};
const deleteArrayElementByValue = (array, item) => {
  return array.filter((e) => e !== item);
};
const validateOperationKind = (opKind) => {
  const opKindList = Object.keys(OperationKindMapping);
  return opKindList.includes(opKind);
};
const validateMissingProperty = (operationContent) => {
  const kind = operationContent.kind;
  const keys = Object.keys(operationContent);
  const cleanKeys = deleteArrayElementByValue(keys, "kind");
  const schemaKeys = Object.keys(OperationKindMapping[kind]);
  return getArrayDifference(cleanKeys, schemaKeys);
};
var ProtocolsHash;
(function(ProtocolsHash2) {
  ProtocolsHash2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  ProtocolsHash2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  ProtocolsHash2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  ProtocolsHash2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  ProtocolsHash2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  ProtocolsHash2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  ProtocolsHash2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  ProtocolsHash2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  ProtocolsHash2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  ProtocolsHash2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  ProtocolsHash2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  ProtocolsHash2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  ProtocolsHash2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  ProtocolsHash2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(ProtocolsHash || (ProtocolsHash = {}));
const protoLevel = {
  Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
  PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
  PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
  PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
  PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
  PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
  PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
  PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
  PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
  Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
  PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,
  PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg: 14,
  PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW: 15,
  ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 16
};
function ProtoInferiorTo(a2, b2) {
  return protoLevel[a2] < protoLevel[b2];
}
const opMappingProto14 = {
  "00": "parameter",
  "01": "storage",
  "02": "code",
  "03": "False",
  "04": "Elt",
  "05": "Left",
  "06": "None",
  "07": "Pair",
  "08": "Right",
  "09": "Some",
  "0a": "True",
  "0b": "Unit",
  "0c": "PACK",
  "0d": "UNPACK",
  "0e": "BLAKE2B",
  "0f": "SHA256",
  "10": "SHA512",
  "11": "ABS",
  "12": "ADD",
  "13": "AMOUNT",
  "14": "AND",
  "15": "BALANCE",
  "16": "CAR",
  "17": "CDR",
  "18": "CHECK_SIGNATURE",
  "19": "COMPARE",
  "1a": "CONCAT",
  "1b": "CONS",
  "1c": "CREATE_ACCOUNT",
  "1d": "CREATE_CONTRACT",
  "1e": "IMPLICIT_ACCOUNT",
  "1f": "DIP",
  "20": "DROP",
  "21": "DUP",
  "22": "EDIV",
  "23": "EMPTY_MAP",
  "24": "EMPTY_SET",
  "25": "EQ",
  "26": "EXEC",
  "27": "FAILWITH",
  "28": "GE",
  "29": "GET",
  "2a": "GT",
  "2b": "HASH_KEY",
  "2c": "IF",
  "2d": "IF_CONS",
  "2e": "IF_LEFT",
  "2f": "IF_NONE",
  "30": "INT",
  "31": "LAMBDA",
  "32": "LE",
  "33": "LEFT",
  "34": "LOOP",
  "35": "LSL",
  "36": "LSR",
  "37": "LT",
  "38": "MAP",
  "39": "MEM",
  "3a": "MUL",
  "3b": "NEG",
  "3c": "NEQ",
  "3d": "NIL",
  "3e": "NONE",
  "3f": "NOT",
  "40": "NOW",
  "41": "OR",
  "42": "PAIR",
  "43": "PUSH",
  "44": "RIGHT",
  "45": "SIZE",
  "46": "SOME",
  "47": "SOURCE",
  "48": "SENDER",
  "49": "SELF",
  "4a": "STEPS_TO_QUOTA",
  "4b": "SUB",
  "4c": "SWAP",
  "4d": "TRANSFER_TOKENS",
  "4e": "SET_DELEGATE",
  "4f": "UNIT",
  "50": "UPDATE",
  "51": "XOR",
  "52": "ITER",
  "53": "LOOP_LEFT",
  "54": "ADDRESS",
  "55": "CONTRACT",
  "56": "ISNAT",
  "57": "CAST",
  "58": "RENAME",
  "59": "bool",
  "5a": "contract",
  "5b": "int",
  "5c": "key",
  "5d": "key_hash",
  "5e": "lambda",
  "5f": "list",
  "60": "map",
  "61": "big_map",
  "62": "nat",
  "63": "option",
  "64": "or",
  "65": "pair",
  "66": "set",
  "67": "signature",
  "68": "string",
  "69": "bytes",
  "6a": "mutez",
  "6b": "timestamp",
  "6c": "unit",
  "6d": "operation",
  "6e": "address",
  "6f": "SLICE",
  "70": "DIG",
  "71": "DUG",
  "72": "EMPTY_BIG_MAP",
  "73": "APPLY",
  "74": "chain_id",
  "75": "CHAIN_ID",
  "76": "LEVEL",
  "77": "SELF_ADDRESS",
  "78": "never",
  "79": "NEVER",
  "7a": "UNPAIR",
  "7b": "VOTING_POWER",
  "7c": "TOTAL_VOTING_POWER",
  "7d": "KECCAK",
  "7e": "SHA3",
  "7f": "PAIRING_CHECK",
  "80": "bls12_381_g1",
  "81": "bls12_381_g2",
  "82": "bls12_381_fr",
  "83": "sapling_state",
  "84": "sapling_transaction_deprecated",
  "85": "SAPLING_EMPTY_STATE",
  "86": "SAPLING_VERIFY_UPDATE",
  "87": "ticket",
  "88": "TICKET",
  "89": "READ_TICKET",
  "8a": "SPLIT_TICKET",
  "8b": "JOIN_TICKETS",
  "8c": "GET_AND_UPDATE",
  "8d": "chest",
  "8e": "chest_key",
  "8f": "OPEN_CHEST",
  "90": "VIEW",
  "91": "view",
  "92": "constant",
  "93": "SUB_MUTEZ",
  "94": "tx_rollup_l2_address",
  "95": "MIN_BLOCK_TIME",
  "96": "sapling_transaction",
  "97": "EMIT"
};
const opMappingReverseProto14 = (() => {
  const result = {};
  Object.keys(opMappingProto14).forEach((key2) => {
    result[opMappingProto14[key2]] = key2;
  });
  return result;
})();
const entrypointMappingProto14 = {
  "00": "default",
  "01": "root",
  "02": "do",
  "03": "set_delegate",
  "04": "remove_delegate"
};
const entrypointMappingReverseProto14 = (() => {
  const result = {};
  Object.keys(entrypointMappingProto14).forEach((key2) => {
    result[entrypointMappingProto14[key2]] = key2;
  });
  return result;
})();
const scriptEncoderProto14 = (script) => {
  const code2 = valueEncoderProto14(script.code);
  const storage = valueEncoderProto14(script.storage);
  return `${pad(code2.length / 2, 8)}${code2}${pad(storage.length / 2, 8)}${storage}`;
};
const scriptDecoderProto14 = (value) => {
  const code2 = extractRequiredLen(value);
  const storage = extractRequiredLen(value);
  return {
    code: valueDecoderProto14(new Uint8ArrayConsumer(code2)),
    storage: valueDecoderProto14(new Uint8ArrayConsumer(storage))
  };
};
const valueEncoderProto14 = (value) => {
  if (Array.isArray(value)) {
    const encoded = value.map((x2) => valueEncoderProto14(x2)).join("");
    const len2 = encoded.length / 2;
    return `02${pad(len2)}${encoded}`;
  } else if (isPrim(value)) {
    return primEncoderProto14(value);
  } else if (isBytes(value)) {
    return bytesEncoder(value);
  } else if (isString(value)) {
    return stringEncoder(value);
  } else if (isInt(value)) {
    return intEncoder(value);
  }
  throw new UnexpectedMichelsonValueError(JSON.stringify(value));
};
const valueDecoderProto14 = (value) => {
  const preamble = value.consume(1);
  switch (preamble[0]) {
    case 10:
      return bytesDecoder(value);
    case 1:
      return stringDecoder(value);
    case 0:
      return intDecoder(value);
    case 2: {
      const val = new Uint8ArrayConsumer(extractRequiredLen(value));
      const results = [];
      while (val.length() > 0) {
        results.push(valueDecoderProto14(val));
      }
      return results;
    }
    default:
      return primDecoderProto14(value, preamble);
  }
};
const primEncoderProto14 = (value) => {
  const hasAnnot = +Array.isArray(value.annots);
  const argsCount = Array.isArray(value.args) ? value.args.length : 0;
  const preamble = pad(Math.min(2 * argsCount + hasAnnot + 3, 9), 2);
  const op = opMappingReverseProto14[value.prim];
  let encodedArgs = (value.args || []).map((arg) => valueEncoderProto14(arg)).join("");
  const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : "";
  if (value.prim === "LAMBDA" && argsCount) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  if ((value.prim === "pair" || value.prim === "Pair") && argsCount > 2) {
    encodedArgs = encodedAnnots === "" ? pad(encodedArgs.length / 2) + encodedArgs + pad(0) : pad(encodedArgs.length / 2) + encodedArgs;
  }
  if (value.prim === "view" && value.args) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
const primDecoderProto14 = (value, preamble) => {
  const hasAnnot = (preamble[0] - 3) % 2 === 1;
  let argsCount = Math.floor((preamble[0] - 3) / 2);
  const op = value.consume(1)[0].toString(16).padStart(2, "0");
  const result = {
    prim: opMappingProto14[op]
  };
  if (opMappingProto14[op] === "LAMBDA") {
    value.consume(4);
  }
  if (opMappingProto14[op] === "view") {
    if (argsCount != 0) {
      return primViewDecoderProto14(value, result);
    } else {
      return result;
    }
  }
  let combPairArgs;
  let combPairAnnots;
  if ((opMappingProto14[op] === "pair" || opMappingProto14[op] === "Pair") && argsCount > 2) {
    combPairArgs = decodeCombPair(value);
    argsCount = 0;
    combPairAnnots = decodeAnnots(value);
  }
  const args = new Array(argsCount).fill(0).map(() => valueDecoderProto14(value));
  if (opMappingProto14[op] === "LAMBDA") {
    value.consume(4);
  }
  if (combPairArgs) {
    result["args"] = combPairArgs;
  } else if (args.length) {
    result["args"] = args;
  }
  if (combPairAnnots && combPairAnnots[0] !== "") {
    result["annots"] = combPairAnnots;
  } else if (hasAnnot) {
    result["annots"] = decodeAnnots(value);
  }
  return result;
};
const primViewDecoderProto14 = (value, result) => {
  value.consume(4);
  result["args"] = new Array(4).fill(0).map(() => valueDecoderProto14(value));
  value.consume(4);
  return result;
};
const decodeCombPair = (val) => {
  const array = new Uint8ArrayConsumer(extractRequiredLen(val));
  const args = [];
  while (array.length() > 0) {
    args.push(valueDecoderProto14(array));
  }
  return args;
};
const parametersDecoderProto14 = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 0) {
    return;
  } else {
    const encodedEntrypoint = entrypointDecoderProto14(val);
    const params = extractRequiredLen(val);
    const parameters = valueDecoderProto14(new Uint8ArrayConsumer(params));
    return {
      entrypoint: encodedEntrypoint,
      value: parameters
    };
  }
};
const entrypointEncoderProto14 = (entrypoint) => {
  if (entrypoint in entrypointMappingReverseProto14) {
    return `${entrypointMappingReverseProto14[entrypoint]}`;
  } else {
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    const value = { string: entrypoint };
    return `ff${valueEncoderProto14(value).slice(8)}`;
  }
};
const entrypointDecoderProto14 = (value) => {
  const preamble = pad(value.consume(1)[0], 2);
  if (preamble in entrypointMappingProto14) {
    return entrypointMappingProto14[preamble];
  } else {
    const entry = extractRequiredLen(value, 1);
    const entrypoint = Buffer.from(entry).toString("utf8");
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    return entrypoint;
  }
};
const parametersEncoderProto14 = (val) => {
  if (!val || val.entrypoint === "default" && "prim" in val.value && val.value.prim === "Unit") {
    return "00";
  }
  const encodedEntrypoint = entrypointEncoderProto14(val.entrypoint);
  const parameters = valueEncoderProto14(val.value);
  const length = (parameters.length / 2).toString(16).padStart(8, "0");
  return `ff${encodedEntrypoint}${length}${parameters}`;
};
const valueParameterEncoderProto14 = (value) => {
  const valueEncoded = valueEncoderProto14(value);
  return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
const valueParameterDecoderProto14 = (val) => {
  const value = extractRequiredLen(val);
  return valueDecoderProto14(new Uint8ArrayConsumer(value));
};
const entrypointNameEncoderProto14 = (entrypoint) => {
  const value = { string: entrypoint };
  return `${valueEncoderProto14(value).slice(2)}`;
};
const decodersProto14 = {
  [CODEC.SECRET]: (val) => toHexString$1(val.consume(20)),
  [CODEC.RAW]: (val) => toHexString$1(val.consume(32)),
  [CODEC.TZ1]: tz1Decoder,
  [CODEC.BRANCH]: branchDecoder,
  [CODEC.ZARITH]: zarithDecoder,
  [CODEC.PUBLIC_KEY]: publicKeyDecoder,
  [CODEC.PKH]: pkhDecoder,
  [CODEC.DELEGATE]: delegateDecoder,
  [CODEC.INT32]: int32Decoder,
  [CODEC.SCRIPT]: scriptDecoderProto14,
  [CODEC.BALLOT_STATEMENT]: ballotDecoder,
  [CODEC.PROPOSAL]: proposalDecoder,
  [CODEC.PROPOSAL_ARR]: proposalsDecoder,
  [CODEC.PARAMETERS]: parametersDecoderProto14,
  [CODEC.ADDRESS]: addressDecoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,
  [CODEC.VALUE]: valueParameterDecoderProto14,
  [CODEC.INT16]: int16Decoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
  [CODEC.ENTRYPOINT]: entrypointNameDecoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdDecoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoder,
  [CODEC.BURN_LIMIT]: burnLimitDecoder
};
decodersProto14[CODEC.OPERATION] = operationDecoder(decodersProto14);
decodersProto14[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decodersProto14)(ActivationSchema)(val);
decodersProto14[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decodersProto14)(DelegationSchema)(val);
decodersProto14[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decodersProto14)(TransactionSchema)(val);
decodersProto14[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decodersProto14)(OriginationSchema)(val);
decodersProto14[CODEC.OP_BALLOT] = (val) => schemaDecoder(decodersProto14)(BallotSchema)(val);
decodersProto14[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decodersProto14)(EndorsementSchema)(val);
decodersProto14[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decodersProto14)(SeedNonceRevelationSchema)(val);
decodersProto14[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decodersProto14)(ProposalsSchema)(val);
decodersProto14[CODEC.OP_REVEAL] = (val) => schemaDecoder(decodersProto14)(RevealSchema)(val);
decodersProto14[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decodersProto14)(RegisterGlobalConstantSchema)(val);
decodersProto14[CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decodersProto14)(TransferTicketSchema)(val);
decodersProto14[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decodersProto14)(TxRollupOriginationSchema)(val);
decodersProto14[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decodersProto14)(TxRollupSubmitBatchSchema)(val);
decodersProto14[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaDecoder(decodersProto14)(IncreasePaidStorageSchema)(val);
decodersProto14[CODEC.MANAGER] = schemaDecoder(decodersProto14)(ManagerOperationSchema);
const encodersProto14 = {
  [CODEC.SECRET]: (val) => val,
  [CODEC.RAW]: (val) => val,
  [CODEC.TZ1]: tz1Encoder,
  [CODEC.BRANCH]: branchEncoder,
  [CODEC.ZARITH]: zarithEncoder,
  [CODEC.PUBLIC_KEY]: publicKeyEncoder,
  [CODEC.PKH]: pkhEncoder,
  [CODEC.DELEGATE]: delegateEncoder,
  [CODEC.SCRIPT]: scriptEncoderProto14,
  [CODEC.BALLOT_STATEMENT]: ballotEncoder,
  [CODEC.PROPOSAL]: proposalEncoder,
  [CODEC.PROPOSAL_ARR]: proposalsEncoder,
  [CODEC.INT32]: int32Encoder,
  [CODEC.PARAMETERS]: parametersEncoderProto14,
  [CODEC.ADDRESS]: addressEncoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,
  [CODEC.VALUE]: valueParameterEncoderProto14,
  [CODEC.INT16]: int16Encoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
  [CODEC.ENTRYPOINT]: entrypointNameEncoderProto14,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdEncoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoder,
  [CODEC.BURN_LIMIT]: burnLimitEncoder
};
encodersProto14[CODEC.OPERATION] = operationEncoder(encodersProto14);
encodersProto14[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encodersProto14)(ActivationSchema)(val);
encodersProto14[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encodersProto14)(DelegationSchema)(val);
encodersProto14[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encodersProto14)(TransactionSchema)(val);
encodersProto14[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encodersProto14)(OriginationSchema)(val);
encodersProto14[CODEC.OP_BALLOT] = (val) => schemaEncoder(encodersProto14)(BallotSchema)(val);
encodersProto14[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encodersProto14)(EndorsementSchema)(val);
encodersProto14[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encodersProto14)(SeedNonceRevelationSchema)(val);
encodersProto14[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encodersProto14)(ProposalsSchema)(val);
encodersProto14[CODEC.OP_REVEAL] = (val) => schemaEncoder(encodersProto14)(RevealSchema)(val);
encodersProto14[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encodersProto14)(RegisterGlobalConstantSchema)(val);
encodersProto14[CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encodersProto14)(TransferTicketSchema)(val);
encodersProto14[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encodersProto14)(TxRollupOriginationSchema)(val);
encodersProto14[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encodersProto14)(TxRollupSubmitBatchSchema)(val);
encodersProto14[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaEncoder(encodersProto14)(IncreasePaidStorageSchema)(val);
encodersProto14[CODEC.MANAGER] = schemaEncoder(encodersProto14)(ManagerOperationSchema);
const PROTOCOL_CURRENT = ProtocolsHash.PtLimaPtL;
function getCodec(codec, _proto) {
  if (_proto === ProtocolsHash.PtKathman || ProtoInferiorTo(_proto, PROTOCOL_CURRENT)) {
    return {
      encoder: encodersProto14[codec],
      decoder: (hex) => {
        const consumer = Uint8ArrayConsumer.fromHexString(hex);
        return decodersProto14[codec](consumer);
      }
    };
  } else {
    return {
      encoder: encoders[codec],
      decoder: (hex) => {
        const consumer = Uint8ArrayConsumer.fromHexString(hex);
        return decoders[codec](consumer);
      }
    };
  }
}
class LocalForger {
  constructor(protocolHash = PROTOCOL_CURRENT) {
    this.protocolHash = protocolHash;
    this.codec = getCodec(CODEC.MANAGER, this.protocolHash);
  }
  forge(params) {
    if (validateBlock(params.branch) !== ValidationResult.VALID) {
      throw new InvalidBlockHashError(`The block hash ${params.branch} is invalid`);
    }
    for (const content of params.contents) {
      if (!validateOperationKind(content.kind)) {
        throw new InvalidOperationKindError(content.kind);
      }
      const diff = validateMissingProperty(content);
      if (diff.length === 1) {
        if (content.kind === "delegation" && diff[0] === "delegate") {
          continue;
        } else if (content.kind === "origination" && diff[0] === "delegate") {
          continue;
        } else if (content.kind === "transaction" && diff[0] === "parameters") {
          continue;
        } else if (content.kind === "tx_rollup_submit_batch" && diff[0] === "burn_limit") {
          continue;
        } else {
          throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(", ").toString()}`);
        }
      } else if (diff.length > 1) {
        throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(", ").toString()}`);
      }
    }
    const forged = this.codec.encoder(params).toLowerCase();
    return Promise.resolve(forged);
  }
  parse(hex) {
    return Promise.resolve(this.codec.decoder(hex));
  }
}
new LocalForger();
function __rest$1(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __awaiter$8(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function formatErrorMessage(error, stringToReplace) {
  const body = JSON.parse(error.body);
  if (body[0] && body[0].kind && body[0].msg) {
    const newBody = JSON.stringify({
      kind: body[0].kind,
      id: body[0].id,
      msg: body[0].msg.replace(stringToReplace, "")
    });
    return new HttpResponseError(`Http error response: (${error.status}) ${newBody}`, error.status, error.statusText, newBody, error.url);
  } else {
    return error;
  }
}
class RpcInjector {
  constructor(context) {
    this.context = context;
  }
  inject(signedOperationBytes) {
    return __awaiter$8(this, void 0, void 0, function* () {
      let hash3;
      try {
        hash3 = yield this.context.rpc.injectOperation(signedOperationBytes);
      } catch (error) {
        const stringToStrip = ". You may want to use --replace to provide adequate fee and replace it";
        if (error instanceof HttpResponseError && error.message.includes(stringToStrip)) {
          throw formatErrorMessage(error, stringToStrip);
        } else {
          throw error;
        }
      }
      return hash3;
    });
  }
}
class UnconfiguredSignerError extends Error {
  constructor() {
    super("No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.");
    this.name = "UnconfiguredSignerError";
  }
}
class NoopSigner {
  publicKey() {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
  publicKeyHash() {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
  secretKey() {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
  sign(_bytes, _watermark) {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
}
function createObservableFromSubscription(sub) {
  return new Observable((subscriber) => {
    sub.on("data", (data2) => {
      subscriber.next(data2);
    });
    sub.on("error", (error) => {
      subscriber.error(error);
    });
    sub.on("close", () => {
      subscriber.complete();
    });
    return () => {
      sub.close();
    };
  });
}
var DEFAULT_GAS_LIMIT;
(function(DEFAULT_GAS_LIMIT2) {
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["DELEGATION"] = 10600] = "DELEGATION";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["ORIGINATION"] = 10600] = "ORIGINATION";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["TRANSFER"] = 10600] = "TRANSFER";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL"] = 1100] = "REVEAL";
})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));
var DEFAULT_FEE;
(function(DEFAULT_FEE2) {
  DEFAULT_FEE2[DEFAULT_FEE2["DELEGATION"] = 1257] = "DELEGATION";
  DEFAULT_FEE2[DEFAULT_FEE2["ORIGINATION"] = 1e4] = "ORIGINATION";
  DEFAULT_FEE2[DEFAULT_FEE2["TRANSFER"] = 1e4] = "TRANSFER";
  DEFAULT_FEE2[DEFAULT_FEE2["REVEAL"] = 374] = "REVEAL";
})(DEFAULT_FEE || (DEFAULT_FEE = {}));
var DEFAULT_STORAGE_LIMIT;
(function(DEFAULT_STORAGE_LIMIT2) {
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["DELEGATION"] = 0] = "DELEGATION";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["ORIGINATION"] = 257] = "ORIGINATION";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["TRANSFER"] = 257] = "TRANSFER";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["REVEAL"] = 0] = "REVEAL";
})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));
const COST_PER_BYTE = 250;
var Protocols;
(function(Protocols2) {
  Protocols2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  Protocols2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  Protocols2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  Protocols2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  Protocols2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  Protocols2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  Protocols2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocols2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocols2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  Protocols2["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
  Protocols2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  Protocols2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  Protocols2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  Protocols2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  Protocols2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(Protocols || (Protocols = {}));
({
  "004": [Protocols.Pt24m4xi],
  "005": [Protocols.PsBABY5H, Protocols.PsBabyM1],
  "006": [Protocols.PsCARTHA],
  "007": [Protocols.PsDELPH1],
  "008": [Protocols.PtEdo2Zk],
  "009": [Protocols.PsFLorena],
  "010": [Protocols.PtGRANADs],
  "011": [Protocols.PtHangz2],
  "012": [Protocols.PsiThaCa, Protocols.Psithaca2],
  "013": [Protocols.PtJakart2],
  "014": [Protocols.PtKathman],
  "015": [Protocols.PtLimaPtL],
  "016": [Protocols.ProtoALpha]
});
var ChainIds;
(function(ChainIds2) {
  ChainIds2["MAINNET"] = "NetXdQprcVkpaWU";
  ChainIds2["CARTHAGENET"] = "NetXjD3HPJJjmcd";
  ChainIds2["DELPHINET"] = "NetXm8tYqnMWky1";
  ChainIds2["EDONET"] = "NetXSgo1ZT2DRUG";
  ChainIds2["FLORENCENET"] = "NetXxkAx4woPLyu";
  ChainIds2["GRANADANET"] = "NetXz969SFaFn8k";
  ChainIds2["HANGZHOUNET"] = "NetXZSsxBpMQeAT";
  ChainIds2["ITHACANET"] = "NetXbhmtAbMukLc";
  ChainIds2["ITHACANET2"] = "NetXnHfVqm9iesp";
  ChainIds2["JAKARTANET2"] = "NetXLH1uAxK7CCh";
  ChainIds2["KATHMANDUNET"] = "NetXazhm4yetmff";
  ChainIds2["LIMANET"] = "NetXizpkH94bocH";
})(ChainIds || (ChainIds = {}));
class InvalidParameterError extends Error {
  constructor(smartContractMethodName, sigs, args) {
    super(`${smartContractMethodName} Received ${args.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`);
    this.smartContractMethodName = smartContractMethodName;
    this.sigs = sigs;
    this.args = args;
    this.name = "Invalid parameters error";
  }
}
class InvalidDelegationSource extends Error {
  constructor(source) {
    super(`Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`);
    this.source = source;
    this.name = "Invalid delegation source error";
  }
}
class InvalidCodeParameter extends Error {
  constructor(message, data2) {
    super(message);
    this.message = message;
    this.data = data2;
    this.name = "InvalidCodeParameter";
  }
}
class InvalidInitParameter extends Error {
  constructor(message, data2) {
    super(message);
    this.message = message;
    this.data = data2;
    this.name = "InvalidInitParameter";
  }
}
class InvalidViewParameterError extends Error {
  constructor(smartContractViewName, sigs, args, originalError) {
    super(`Unable to encode the parameter of the view: ${smartContractViewName}. Received ${args} as parameter while expecting one of the following signatures (${JSON.stringify(sigs)})`);
    this.smartContractViewName = smartContractViewName;
    this.sigs = sigs;
    this.args = args;
    this.originalError = originalError;
    this.name = "Invalid view parameters error";
    this.cause = originalError;
  }
}
class ViewSimulationError extends Error {
  constructor(message, viewName, failWith, originalError) {
    super(message);
    this.message = message;
    this.viewName = viewName;
    this.failWith = failWith;
    this.originalError = originalError;
    this.name = "ViewSimulationError";
  }
}
const validateAndExtractFailwith = (error) => {
  if (isJsonString(error.body)) {
    const parsedError = JSON.parse(error.body);
    if (Array.isArray(parsedError) && "with" in parsedError[parsedError.length - 1]) {
      return parsedError[parsedError.length - 1].with;
    }
  }
};
const isJsonString = (str) => {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }
  return true;
};
class InvalidViewSimulationContext extends Error {
  constructor(info) {
    super(`${info} Please configure the context of the view execution in the executeView method.`);
    this.info = info;
    this.name = "InvalidViewSimulationContext";
  }
}
class RevealOperationError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "RevealOperationError";
  }
}
class OriginationParameterError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "OriginationParameterError";
  }
}
class IntegerError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "IntegerError";
  }
}
const createOriginationOperation = ({ code: code2, init: init5, balance = "0", delegate, storage, fee = DEFAULT_FEE.ORIGINATION, gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION, storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION, mutez = false }) => __awaiter$8(void 0, void 0, void 0, function* () {
  if (storage !== void 0 && init5 !== void 0) {
    throw new OriginationParameterError("Storage and Init cannot be set a the same time. Please either use storage or init but not both.");
  }
  if (!Array.isArray(code2)) {
    throw new InvalidCodeParameter("Wrong code parameter type, expected an array", code2);
  }
  let contractStorage;
  if (storage !== void 0) {
    const storageType = code2.find((p2) => "prim" in p2 && p2.prim === "storage");
    if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === void 0) {
      throw new InvalidCodeParameter("The storage section is missing from the script", code2);
    }
    const schema = new Schema(storageType.args[0]);
    contractStorage = schema.Encode(storage);
  } else if (init5 !== void 0 && typeof init5 === "object") {
    contractStorage = init5;
  } else {
    throw new InvalidInitParameter("Wrong init parameter type, expected JSON Michelson", init5);
  }
  const script = {
    code: code2,
    storage: contractStorage
  };
  if (isNaN(Number(balance))) {
    throw new IntegerError(`Unexpected Invalid Integer ${balance}`);
  }
  const operation = {
    kind: OpKind.ORIGINATION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    balance: mutez ? balance.toString() : format("tz", "mutez", balance).toString(),
    script
  };
  if (delegate) {
    operation.delegate = delegate;
  }
  return operation;
});
const createTransferOperation = ({ to, amount, parameter, fee = DEFAULT_FEE.TRANSFER, gasLimit = DEFAULT_GAS_LIMIT.TRANSFER, storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER, mutez = false }) => __awaiter$8(void 0, void 0, void 0, function* () {
  const operation = {
    kind: OpKind.TRANSACTION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    amount: mutez ? amount.toString() : format("tz", "mutez", amount).toString(),
    destination: to,
    parameters: parameter
  };
  return operation;
});
const createSetDelegateOperation = ({ delegate, source, fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION }) => __awaiter$8(void 0, void 0, void 0, function* () {
  const operation = {
    kind: OpKind.DELEGATION,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    delegate
  };
  return operation;
});
const createRegisterDelegateOperation = ({ fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION }, source) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.DELEGATION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    delegate: source
  };
});
const createRevealOperation = ({ fee = DEFAULT_FEE.REVEAL, gasLimit = DEFAULT_GAS_LIMIT.REVEAL, storageLimit = DEFAULT_STORAGE_LIMIT.REVEAL }, source, publicKey) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.REVEAL,
    fee,
    public_key: publicKey,
    source,
    gas_limit: gasLimit,
    storage_limit: storageLimit
  };
});
const createRegisterGlobalConstantOperation = ({ value, source, fee, gasLimit, storageLimit }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.REGISTER_GLOBAL_CONSTANT,
    value,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    source
  };
});
const createTxRollupOriginationOperation = ({ source, fee, gasLimit, storageLimit }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.TX_ROLLUP_ORIGINATION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    source,
    tx_rollup_origination: {}
  };
});
const createTxRollupBatchOperation = ({ content, rollup, source, fee, gasLimit, storageLimit }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.TX_ROLLUP_SUBMIT_BATCH,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    source,
    content,
    rollup
  };
});
const createTransferTicketOperation = ({ ticketContents, ticketTy, ticketTicketer, ticketAmount, destination, entrypoint, source, fee, gasLimit, storageLimit }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.TRANSFER_TICKET,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    source,
    ticket_contents: ticketContents,
    ticket_ty: ticketTy,
    ticket_ticketer: ticketTicketer,
    ticket_amount: ticketAmount,
    destination,
    entrypoint
  };
});
const createIncreasePaidStorageOperation = ({ source, fee, gasLimit, storageLimit, amount, destination }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.INCREASE_PAID_STORAGE,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    amount,
    destination
  };
});
const createDrainDelegateOperation = ({ consensus_key, delegate, destination }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.DRAIN_DELEGATE,
    consensus_key,
    delegate,
    destination
  };
});
const createBallotOperation = ({ source, proposal, ballot }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.BALLOT,
    source,
    proposal,
    ballot
  };
});
const createProposalsOperation = ({ source, proposals }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.PROPOSALS,
    source,
    proposals
  };
});
const createUpdateConsensusKeyOperation = ({ source, fee, gasLimit, storageLimit, pk }) => __awaiter$8(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.UPDATE_CONSENSUS_KEY,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    pk
  };
});
const attachKind = (op, kind) => {
  return Object.assign(Object.assign({}, op), { kind });
};
const findWithKind = (arr, kind) => {
  if (Array.isArray(arr)) {
    const found = arr.find((op) => op.kind === kind);
    if (found && isKind(found, kind)) {
      return found;
    }
  }
};
const isKind = (op, kind) => {
  return op.kind === kind;
};
const isOpWithFee = (op) => {
  return [
    "transaction",
    "delegation",
    "origination",
    "reveal",
    "register_global_constant",
    "increase_paid_storage",
    "tx_rollup_origination",
    "tx_rollup_submit_batch",
    "transfer_ticket",
    "update_consensus_key"
  ].indexOf(op.kind) !== -1;
};
const isOpRequireReveal = (op) => {
  return [
    "transaction",
    "delegation",
    "origination",
    "register_global_constant",
    "increase_paid_storage",
    "tx_rollup_origination",
    "tx_rollup_submit_batch",
    "transfer_ticket",
    "update_consensus_key"
  ].indexOf(op.kind) !== -1;
};
const hasMetadata = (op) => {
  return "metadata" in op;
};
const hasMetadataWithResult = (op) => {
  return hasMetadata(op) && "operation_result" in op.metadata;
};
const hasMetadataWithInternalOperationResult = (op) => {
  return hasMetadata(op) && "internal_operation_results" in op.metadata;
};
const isErrorWithMessage = (error) => {
  return "with" in error;
};
class TezosOperationError extends Error {
  constructor(errors, errorDetails) {
    super();
    this.errors = errors;
    this.errorDetails = errorDetails;
    this.name = "TezosOperationError";
    const lastError = errors[errors.length - 1];
    this.id = lastError.id;
    this.kind = lastError.kind;
    this.message = `(${this.kind}) ${this.id}`;
    if (isErrorWithMessage(lastError)) {
      if (lastError.with.string) {
        this.message = lastError.with.string;
      } else if (lastError.with.int) {
        this.message = lastError.with.int;
      } else {
        this.message = JSON.stringify(lastError.with);
      }
    }
  }
}
class TezosPreapplyFailureError extends Error {
  constructor(result) {
    super("Preapply returned an unexpected result");
    this.result = result;
    this.name = "TezosPreapplyFailureError";
  }
}
const flattenOperationResult = (response) => {
  const results = Array.isArray(response) ? response : [response];
  const returnedResults = [];
  for (let i2 = 0; i2 < results.length; i2++) {
    for (let j2 = 0; j2 < results[i2].contents.length; j2++) {
      const content = results[i2].contents[j2];
      if (hasMetadataWithResult(content)) {
        returnedResults.push(Object.assign({ fee: content.fee }, content.metadata.operation_result));
        if (Array.isArray(content.metadata.internal_operation_results)) {
          content.metadata.internal_operation_results.forEach((x2) => returnedResults.push(x2.result));
        }
      }
    }
  }
  return returnedResults;
};
const flattenErrors = (response, status = "failed") => {
  const results = Array.isArray(response) ? response : [response];
  let errors = [];
  for (let i2 = 0; i2 < results.length; i2++) {
    for (let j2 = 0; j2 < results[i2].contents.length; j2++) {
      const content = results[i2].contents[j2];
      if (hasMetadata(content)) {
        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {
          errors = errors.concat(content.metadata.operation_result.errors || []);
        }
        if (hasMetadataWithInternalOperationResult(content) && Array.isArray(content.metadata.internal_operation_results)) {
          for (const internalResult of content.metadata.internal_operation_results) {
            if ("result" in internalResult && internalResult.result.status === status) {
              errors = errors.concat(internalResult.result.errors || []);
            }
          }
        }
      }
    }
  }
  return errors;
};
class OriginationOperationError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "OriginationOperationError";
  }
}
class InvalidConfirmationCountError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidConfirmationCountError";
  }
}
class ConfirmationUndefinedError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "ConfirmationUndefinedError";
  }
}
class InvalidFilterExpressionError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidFilterExpressionError";
  }
}
class RPCResponseError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "RPCResponseError";
  }
}
class Operation {
  /**
   *
   * @param hash Operation hash
   * @param raw Raw operation that was injected
   * @param context Taquito context allowing access to rpc and signer
   */
  constructor(hash3, raw, results, context) {
    this.hash = hash3;
    this.raw = raw;
    this.results = results;
    this.context = context;
    this._pollingConfig$ = new ReplaySubject(1);
    this.currentHead$ = this._pollingConfig$.pipe(switchMap((config2) => {
      return new BehaviorSubject(config2).pipe(timeoutWith(config2.timeout * 1e3, throwError(new Error("Confirmation polling timed out"))));
    }), switchMap(() => {
      return defer(() => createObservableFromSubscription(this.context.stream.subscribeBlock("head"))).pipe(switchMap((newHead) => {
        var _a2, _b;
        const prevHead = (_b = (_a2 = this.lastHead) === null || _a2 === void 0 ? void 0 : _a2.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;
        return range(prevHead + 1, newHead.header.level - prevHead - 1).pipe(concatMap((level) => this.context.readProvider.getBlock(level)), endWith(newHead));
      }), tap((newHead) => this.lastHead = newHead));
    }), shareReplay({ refCount: true }));
    this.confirmed$ = this.currentHead$.pipe(map((head) => {
      for (let i2 = 3; i2 >= 0; i2--) {
        head.operations[i2].forEach((op) => {
          if (op.hash === this.hash) {
            this._foundAt = head.header.level;
          }
        });
      }
      if (head.header.level - this._foundAt >= 0) {
        return this._foundAt;
      }
    }), filter((x2) => x2 !== void 0), first(), shareReplay());
    this._foundAt = Number.POSITIVE_INFINITY;
    if (validateOperation(this.hash) !== ValidationResult.VALID) {
      throw new InvalidOperationHashError(this.hash);
    }
    this.confirmed$.pipe(first(), catchError(() => {
      return of(EMPTY);
    })).subscribe();
  }
  get includedInBlock() {
    return this._foundAt;
  }
  get revealOperation() {
    return Array.isArray(this.results) && this.results.find((op) => op.kind === "reveal");
  }
  get revealStatus() {
    if (this.revealOperation) {
      return this.revealOperation.metadata.operation_result.status;
    } else {
      return "unknown";
    }
  }
  get status() {
    return this.results.map((result) => {
      if (hasMetadataWithResult(result)) {
        return result.metadata.operation_result.status;
      } else {
        return "unknown";
      }
    })[0] || "unknown";
  }
  /**
   *
   * @param confirmations [0] Number of confirmation to wait for
   * @param timeout [180] Timeout
   */
  confirmation(confirmations, timeout) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (typeof confirmations !== "undefined" && confirmations < 1) {
        throw new InvalidConfirmationCountError("Confirmation count must be at least 1");
      }
      const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;
      this._pollingConfig$.next({
        timeout: timeout || confirmationPollingTimeoutSecond
      });
      const conf = confirmations !== void 0 ? confirmations : defaultConfirmationCount;
      return new Promise((resolve, reject) => {
        this.confirmed$.pipe(switchMap(() => this.currentHead$), filter((head) => head.header.level - this._foundAt >= conf - 1), first()).subscribe((_2) => {
          resolve(this._foundAt + (conf - 1));
        }, reject);
      });
    });
  }
}
class BatchOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  sumProp(arr, prop) {
    return arr.reduce((prev, current) => {
      return prop in current ? Number(current[prop]) + prev : prev;
    }, 0);
  }
  getOriginatedContractAddresses() {
    const originationOpResults = this.results.filter((x2) => x2.kind === "origination");
    let addresses = [];
    for (const res of originationOpResults) {
      if (res.metadata.operation_result.originated_contracts) {
        addresses = [...addresses, ...res.metadata.operation_result.originated_contracts];
      }
    }
    return addresses;
  }
  get status() {
    return this.results.filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1).map((result) => {
      if (hasMetadataWithResult(result)) {
        return result.metadata.operation_result.status;
      } else {
        return "unknown";
      }
    })[0] || "unknown";
  }
  get fee() {
    return this.sumProp(this.params, "fee");
  }
  get gasLimit() {
    return this.sumProp(this.params, "gas_limit");
  }
  get storageLimit() {
    return this.sumProp(this.params, "storage_limit");
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString();
  }
  get consumedMilliGas() {
    return String(this.sumProp(flattenOperationResult({ contents: this.results }), "consumed_milligas"));
  }
  get storageDiff() {
    return String(this.sumProp(flattenOperationResult({ contents: this.results }), "paid_storage_size_diff"));
  }
  get errors() {
    return flattenErrors({ contents: this.results });
  }
}
class OperationEmitter {
  constructor(context) {
    this.context = context;
  }
  get rpc() {
    return this.context.rpc;
  }
  get signer() {
    return this.context.signer;
  }
  isRevealOpNeeded(op, pkh) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return !(yield this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op) ? false : true;
    });
  }
  isAccountRevealRequired(publicKeyHash) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return !(yield this.context.readProvider.isAccountRevealed(publicKeyHash, "head"));
    });
  }
  isRevealRequiredForOpType(op) {
    let opRequireReveal = false;
    for (const operation of op) {
      if (isOpRequireReveal(operation)) {
        opRequireReveal = true;
      }
    }
    return opRequireReveal;
  }
  // Originally from sotez (Copyright (c) 2018 Andrew Kishino)
  prepareOperation({ operation, source }, pkh) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const counters = {};
      let ops = [];
      const blockHashPromise = this.context.readProvider.getBlockHash("head~2");
      const blockProtoPromise = this.context.readProvider.getNextProtocol("head");
      if (Array.isArray(operation)) {
        ops = [...operation];
      } else {
        ops = [operation];
      }
      const publicKeyHash = pkh ? pkh : yield this.signer.publicKeyHash();
      let counterPromise = Promise.resolve(void 0);
      let currentVotingPeriodPromise = Promise.resolve(void 0);
      ops.find((op) => __awaiter$8(this, void 0, void 0, function* () {
        if (op.kind === "ballot" || op.kind === "proposals") {
          try {
            currentVotingPeriodPromise = this.rpc.getCurrentPeriod();
          } catch (e) {
            throw new RPCResponseError(`Failed to get the current voting period index: ${JSON.stringify(e)}`);
          }
        }
      }));
      for (let i2 = 0; i2 < ops.length; i2++) {
        if (isOpRequireReveal(ops[i2]) || ops[i2].kind === "reveal") {
          counterPromise = this.context.readProvider.getCounter(publicKeyHash, "head");
          break;
        }
      }
      const [hash3, protocol, headCounter, currentVotingPeriod] = yield Promise.all([
        blockHashPromise,
        blockProtoPromise,
        counterPromise,
        currentVotingPeriodPromise
      ]);
      const counter = parseInt(headCounter || "0", 10);
      if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {
        counters[publicKeyHash] = counter;
      }
      const getFee = (op) => {
        const opCounter = ++counters[publicKeyHash];
        return {
          counter: `${opCounter}`,
          fee: typeof op.fee === "undefined" ? "0" : `${op.fee}`,
          gas_limit: typeof op.gas_limit === "undefined" ? "0" : `${op.gas_limit}`,
          storage_limit: typeof op.storage_limit === "undefined" ? "0" : `${op.storage_limit}`
        };
      };
      const getSource = (op) => {
        return {
          source: typeof op.source === "undefined" ? source || publicKeyHash : op.source
        };
      };
      const constructOps = (cOps) => cOps.map((op) => {
        switch (op.kind) {
          case OpKind.ACTIVATION:
          case OpKind.DRAIN_DELEGATE:
            return Object.assign({}, op);
          case OpKind.ORIGINATION:
            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { balance: typeof op.balance !== "undefined" ? `${op.balance}` : "0" }), getSource(op)), getFee(op));
          case OpKind.TRANSACTION: {
            const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: typeof op.amount !== "undefined" ? `${op.amount}` : "0" }), getSource(op)), getFee(op));
            if (cops.source.toLowerCase().startsWith("kt1")) {
              throw new DeprecationError(`KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`);
            }
            return cops;
          }
          case OpKind.REVEAL:
          case OpKind.DELEGATION:
          case OpKind.REGISTER_GLOBAL_CONSTANT:
          case OpKind.TX_ROLLUP_ORIGINATION:
          case OpKind.TX_ROLLUP_SUBMIT_BATCH:
          case OpKind.UPDATE_CONSENSUS_KEY:
            return Object.assign(Object.assign(Object.assign({}, op), getSource(op)), getFee(op));
          case OpKind.TRANSFER_TICKET:
            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { ticket_amount: `${op.ticket_amount}` }), getSource(op)), getFee(op));
          case OpKind.INCREASE_PAID_STORAGE:
            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: `${op.amount}` }), getSource(op)), getFee(op));
          case OpKind.BALLOT:
            if (currentVotingPeriod === void 0) {
              throw new RPCResponseError(`Failed to get the current voting period index`);
            }
            return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
          case OpKind.PROPOSALS:
            if (currentVotingPeriod === void 0) {
              throw new RPCResponseError(`Failed to get the current voting period index`);
            }
            return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
          default:
            throw new InvalidOperationKindError(op.kind);
        }
      });
      const contents = constructOps(ops);
      return {
        opOb: {
          branch: hash3,
          contents,
          protocol
        },
        counter
      };
    });
  }
  forge({ opOb: { branch, contents, protocol }, counter }) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const forgedBytes = yield this.context.forger.forge({ branch, contents });
      return {
        opbytes: forgedBytes,
        opOb: {
          branch,
          contents,
          protocol
        },
        counter
      };
    });
  }
  simulate(op) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return {
        opResponse: yield this.rpc.runOperation(op),
        op,
        context: this.context.clone()
      };
    });
  }
  estimate(_a2, estimator) {
    var { fee, gasLimit, storageLimit } = _a2, rest = __rest$1(_a2, ["fee", "gasLimit", "storageLimit"]);
    return __awaiter$8(this, void 0, void 0, function* () {
      let calculatedFee = fee;
      let calculatedGas = gasLimit;
      let calculatedStorage = storageLimit;
      if (fee === void 0 || gasLimit === void 0 || storageLimit === void 0) {
        const estimation = yield estimator(Object.assign({ fee, gasLimit, storageLimit }, rest));
        if (calculatedFee === void 0) {
          calculatedFee = estimation.suggestedFeeMutez;
        }
        if (calculatedGas === void 0) {
          calculatedGas = estimation.gasLimit;
        }
        if (calculatedStorage === void 0) {
          calculatedStorage = estimation.storageLimit;
        }
      }
      return {
        fee: calculatedFee,
        gasLimit: calculatedGas,
        storageLimit: calculatedStorage
      };
    });
  }
  signAndInject(forgedBytes) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const signed2 = yield this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));
      forgedBytes.opbytes = signed2.sbytes;
      forgedBytes.opOb.signature = signed2.prefixSig;
      const opResponse = [];
      const results = yield this.rpc.preapplyOperations([forgedBytes.opOb]);
      if (!Array.isArray(results)) {
        throw new TezosPreapplyFailureError(results);
      }
      for (let i2 = 0; i2 < results.length; i2++) {
        for (let j2 = 0; j2 < results[i2].contents.length; j2++) {
          opResponse.push(results[i2].contents[j2]);
        }
      }
      const errors = flattenErrors(results);
      if (errors.length) {
        throw new TezosOperationError(errors, "Error occurred during validation simulation of operation");
      }
      return {
        hash: yield this.context.injector.inject(forgedBytes.opbytes),
        forgedBytes,
        opResponse,
        context: this.context.clone()
      };
    });
  }
}
const BATCH_KINDS = [
  OpKind.ACTIVATION,
  OpKind.ORIGINATION,
  OpKind.TRANSACTION,
  OpKind.DELEGATION
];
class OperationBatch extends OperationEmitter {
  constructor(context, estimator) {
    super(context);
    this.estimator = estimator;
    this.operations = [];
  }
  /**
   *
   * @description Add a transaction operation to the batch
   *
   * @param params Transfer operation parameter
   */
  withTransfer(params) {
    if (validateAddress(params.to) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.to);
    }
    this.operations.push(Object.assign({ kind: OpKind.TRANSACTION }, params));
    return this;
  }
  /**
   *
   * @description Transfer tickets from a Tezos address (tz1,tz2 or tz3) to a smart contract address( KT1)
   *
   * @param params Transfer operation parameter
   */
  withTransferTicket(params) {
    if (validateContractAddress(params.destination) !== ValidationResult.VALID) {
      throw new InvalidContractAddressError(params.destination);
    }
    this.operations.push(Object.assign({ kind: OpKind.TRANSFER_TICKET }, params));
    return this;
  }
  /**
   *
   * @description Add a contract call to the batch
   *
   * @param params Call a contract method
   * @param options Generic operation parameters
   */
  withContractCall(params, options = {}) {
    return this.withTransfer(params.toTransferParams(options));
  }
  /**
   *
   * @description Add a delegation operation to the batch
   *
   * @param params Delegation operation parameter
   */
  withDelegation(params) {
    if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.source);
    }
    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.delegate);
    }
    this.operations.push(Object.assign({ kind: OpKind.DELEGATION }, params));
    return this;
  }
  /**
   *
   * @description Add an activation operation to the batch
   *
   * @param params Activation operation parameter
   */
  withActivation({ pkh, secret: secret2 }) {
    if (validateKeyHash(pkh) !== ValidationResult.VALID) {
      throw new InvalidKeyHashError(pkh);
    }
    this.operations.push({ kind: OpKind.ACTIVATION, pkh, secret: secret2 });
    return this;
  }
  /**
   *
   * @description Add an origination operation to the batch
   *
   * @param params Origination operation parameter
   */
  withOrigination(params) {
    this.operations.push(Object.assign({ kind: OpKind.ORIGINATION }, params));
    return this;
  }
  /**
   *
   * @description Add an operation to register a global constant to the batch
   *
   * @param params RegisterGlobalConstant operation parameter
   */
  withRegisterGlobalConstant(params) {
    this.operations.push(Object.assign({ kind: OpKind.REGISTER_GLOBAL_CONSTANT }, params));
    return this;
  }
  /**
   *
   * @description Add an operation to increase paid storage to the batch
   *
   * @param params IncreasePaidStorage operation parameter
   */
  withIncreasePaidStorage(params) {
    this.operations.push(Object.assign({ kind: OpKind.INCREASE_PAID_STORAGE }, params));
    return this;
  }
  /**
   *
   * @description Add an operation to originate a rollup to the batch
   *
   * @param params Rollup origination operation parameter
   */
  withTxRollupOrigination(params) {
    this.operations.push(Object.assign({ kind: OpKind.TX_ROLLUP_ORIGINATION }, params));
    return this;
  }
  /**
   *
   * @description Add an operation to submit a tx rollup batch to the batch
   *
   * @param params Tx rollup batch operation parameter
   */
  withTxRollupSubmitBatch(params) {
    this.operations.push(Object.assign({ kind: OpKind.TX_ROLLUP_SUBMIT_BATCH }, params));
    return this;
  }
  getRPCOp(param) {
    return __awaiter$8(this, void 0, void 0, function* () {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          return createTransferOperation(Object.assign({}, param));
        case OpKind.ORIGINATION:
          return createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));
        case OpKind.DELEGATION:
          return createSetDelegateOperation(Object.assign({}, param));
        case OpKind.ACTIVATION:
          return Object.assign({}, param);
        case OpKind.REGISTER_GLOBAL_CONSTANT:
          return createRegisterGlobalConstantOperation(Object.assign({}, param));
        case OpKind.INCREASE_PAID_STORAGE:
          return createIncreasePaidStorageOperation(Object.assign({}, param));
        case OpKind.TX_ROLLUP_ORIGINATION:
          return createTxRollupOriginationOperation(Object.assign({}, param));
        case OpKind.TX_ROLLUP_SUBMIT_BATCH:
          return createTxRollupBatchOperation(Object.assign({}, param));
        case OpKind.TRANSFER_TICKET:
          return createTransferTicketOperation(Object.assign({}, param));
        default:
          throw new InvalidOperationKindError(param.kind);
      }
    });
  }
  /**
   *
   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
   *
   * @param params Operations parameter
   */
  with(params) {
    for (const param of params) {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          this.withTransfer(param);
          break;
        case OpKind.ORIGINATION:
          this.withOrigination(param);
          break;
        case OpKind.DELEGATION:
          this.withDelegation(param);
          break;
        case OpKind.ACTIVATION:
          this.withActivation(param);
          break;
        case OpKind.REGISTER_GLOBAL_CONSTANT:
          this.withRegisterGlobalConstant(param);
          break;
        case OpKind.INCREASE_PAID_STORAGE:
          this.withIncreasePaidStorage(param);
          break;
        case OpKind.TX_ROLLUP_ORIGINATION:
          this.withTxRollupOrigination(param);
          break;
        case OpKind.TX_ROLLUP_SUBMIT_BATCH:
          this.withTxRollupSubmitBatch(param);
          break;
        case OpKind.TRANSFER_TICKET:
          this.withTransferTicket(param);
          break;
        default:
          throw new InvalidOperationKindError(param.kind);
      }
    }
    return this;
  }
  /**
   *
   * @description Forge and Inject the operation batch
   *
   * @param params Optionally specify the source of the operation
   */
  send(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const publicKey = yield this.signer.publicKey();
      const estimates = yield this.estimator.batch(this.operations);
      const revealNeeded = yield this.isRevealOpNeeded(this.operations, publicKeyHash);
      let i2 = revealNeeded ? 1 : 0;
      const ops = [];
      for (const op of this.operations) {
        if (isOpWithFee(op)) {
          const estimated = yield this.estimate(op, () => __awaiter$8(this, void 0, void 0, function* () {
            return estimates[i2];
          }));
          ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), estimated)));
        } else {
          ops.push(Object.assign({}, op));
        }
        i2++;
      }
      if (revealNeeded) {
        const reveal = { kind: OpKind.REVEAL };
        const estimatedReveal = yield this.estimate(reveal, () => __awaiter$8(this, void 0, void 0, function* () {
          return estimates[0];
        }));
        ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
      }
      const source = params && params.source || publicKeyHash;
      const prepared = yield this.prepareOperation({
        operation: ops,
        source
      });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new BatchOperation(hash3, ops, source, forgedBytes, opResponse, context);
    });
  }
}
class RPCBatchProvider {
  constructor(context, estimator) {
    this.context = context;
    this.estimator = estimator;
  }
  /***
   *
   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
   *
   * @param params List of operation to batch together
   */
  batch(params) {
    const batch = new OperationBatch(this.context, this.estimator);
    if (Array.isArray(params)) {
      batch.with(params);
    }
    return batch;
  }
}
const receiptFromOperation = (op, { ALLOCATION_BURN, ORIGINATION_BURN } = {
  ALLOCATION_BURN: 257,
  ORIGINATION_BURN: 257
}) => {
  BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
  const operationResults = flattenOperationResult({ contents: op });
  let totalMilliGas = new BigNumber$1(0);
  let totalStorage = new BigNumber$1(0);
  let totalFee = new BigNumber$1(0);
  let totalOriginationBurn = new BigNumber$1(0);
  let totalAllocationBurn = new BigNumber$1(0);
  let totalPaidStorageDiff = new BigNumber$1(0);
  operationResults.forEach((result) => {
    totalFee = totalFee.plus(result.fee || 0);
    totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts) ? result.originated_contracts.length * ORIGINATION_BURN : 0);
    totalAllocationBurn = totalAllocationBurn.plus("allocated_destination_contract" in result ? ALLOCATION_BURN : 0);
    totalMilliGas = totalMilliGas.plus(result.consumed_milligas || 0);
    totalPaidStorageDiff = totalPaidStorageDiff.plus("paid_storage_size_diff" in result ? Number(result.paid_storage_size_diff) || 0 : 0);
  });
  totalStorage = totalStorage.plus(totalAllocationBurn).plus(totalOriginationBurn).plus(totalPaidStorageDiff);
  return {
    totalFee,
    totalMilliGas,
    totalGas: totalMilliGas.dividedBy(1e3),
    totalStorage,
    totalAllocationBurn,
    totalOriginationBurn,
    totalPaidStorageDiff,
    totalStorageBurn: new BigNumber$1(totalStorage.multipliedBy(COST_PER_BYTE))
  };
};
const MAX_BRANCH_ANCESTORS = 60;
class WalletOperation {
  /**
   *
   * @param opHash Operation hash
   * @param raw Raw operation that was injected
   * @param context Taquito context allowing access to rpc and signer
   */
  constructor(opHash, context, _newHead$) {
    this.opHash = opHash;
    this.context = context;
    this._newHead$ = _newHead$;
    this._operationResult = new ReplaySubject(1);
    this._includedInBlock = new ReplaySubject(1);
    this._included = false;
    this.newHead$ = this._newHead$.pipe(switchMap((newHead) => {
      var _a2, _b;
      const prevHead = (_b = (_a2 = this.lastHead) === null || _a2 === void 0 ? void 0 : _a2.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;
      return range(prevHead + 1, newHead.header.level - prevHead - 1).pipe(concatMap((level) => this.context.readProvider.getBlock(level)), endWith(newHead));
    }), tap((newHead) => this.lastHead = newHead), publishReplay(1), refCount());
    this.confirmed$ = this.newHead$.pipe(map((head) => {
      for (const opGroup of head.operations) {
        for (const op of opGroup) {
          if (op.hash === this.opHash) {
            this._included = true;
            this._includedInBlock.next(head);
            this._operationResult.next(op.contents);
            return head;
          }
        }
      }
    }), filter((x2) => {
      return typeof x2 !== "undefined";
    }), first(), publishReplay(1), refCount());
    if (validateOperation(this.opHash) !== ValidationResult.VALID) {
      throw new InvalidOperationHashError(this.opHash);
    }
    this.confirmed$.pipe(first(), catchError(() => of(void 0))).subscribe();
  }
  operationResults() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this._operationResult.pipe(first()).toPromise();
    });
  }
  /**
   * @description Receipt expose the total amount of tezos token burn and spent on fees
   * The promise returned by receipt will resolve only once the transaction is included
   */
  receipt() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return receiptFromOperation(yield this.operationResults());
    });
  }
  getCurrentConfirmation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._included) {
        return 0;
      }
      return combineLatest([this._includedInBlock, from(this.context.readProvider.getBlock("head"))]).pipe(map(([foundAtBlock, head]) => {
        return head.header.level - foundAtBlock.header.level + 1;
      }), first()).toPromise();
    });
  }
  isInCurrentBranch(tipBlockIdentifier = "head") {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._included) {
        return true;
      }
      const tipBlockHeaderLevel = yield this.context.readProvider.getBlockLevel(tipBlockIdentifier);
      const inclusionBlock = yield this._includedInBlock.pipe(first()).toPromise();
      const levelDiff = tipBlockHeaderLevel - inclusionBlock.header.level;
      if (levelDiff <= 0) {
        return true;
      }
      const tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);
      const blocks = new Set(yield this.context.readProvider.getLiveBlocks(tipBlockLevel));
      return blocks.has(inclusionBlock.hash);
    });
  }
  confirmationObservable(confirmations) {
    if (typeof confirmations !== "undefined" && confirmations < 1) {
      throw new InvalidConfirmationCountError("Confirmation count must be at least 1");
    }
    const { defaultConfirmationCount } = this.context.config;
    const conf = confirmations !== void 0 ? confirmations : defaultConfirmationCount;
    if (conf === void 0) {
      throw new ConfirmationUndefinedError("Default confirmation count can not be undefined!");
    }
    return combineLatest([this._includedInBlock, this.newHead$]).pipe(distinctUntilChanged(([, previousHead], [, newHead]) => {
      return previousHead.hash === newHead.hash;
    }), map(([foundAtBlock, head]) => {
      return {
        block: head,
        expectedConfirmation: conf,
        currentConfirmation: head.header.level - foundAtBlock.header.level + 1,
        completed: head.header.level - foundAtBlock.header.level >= conf - 1,
        isInCurrentBranch: () => this.isInCurrentBranch(head.hash)
      };
    }), takeWhile(({ completed }) => !completed, true));
  }
  /**
   *
   * @param confirmations [0] Number of confirmation to wait for
   */
  confirmation(confirmations) {
    return this.confirmationObservable(confirmations).toPromise();
  }
}
class BatchWalletOperation extends WalletOperation {
  constructor(opHash, context, newHead$) {
    super(opHash, context, newHead$);
    this.opHash = opHash;
    this.context = context;
    this.getOriginatedContractAddresses = () => __awaiter$8(this, void 0, void 0, function* () {
      const opResult = yield this.operationResults();
      const originationOpResults = opResult.filter((x2) => x2.kind === "origination");
      let addresses = [];
      for (const res of originationOpResults) {
        if (res.metadata.operation_result.originated_contracts) {
          addresses = [...addresses, ...res.metadata.operation_result.originated_contracts];
        }
      }
      return addresses;
    });
  }
  revealOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return operationResult.find((x2) => x2.kind === OpKind.REVEAL);
    });
  }
  status() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.operationResults();
      return op.filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1).map((result) => {
        if (hasMetadataWithResult(result)) {
          return result.metadata.operation_result.status;
        } else {
          return "unknown";
        }
      })[0] || "unknown";
    });
  }
}
class DelegationWalletOperation extends WalletOperation {
  constructor(opHash, context, newHead$) {
    super(opHash, context, newHead$);
    this.opHash = opHash;
    this.context = context;
  }
  revealOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return operationResult.find((x2) => x2.kind === OpKind.REVEAL);
    });
  }
  delegationOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return operationResult.find((x2) => x2.kind === OpKind.DELEGATION);
    });
  }
  status() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.delegationOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
}
class OriginationWalletOperation extends WalletOperation {
  constructor(opHash, context, newHead$) {
    super(opHash, context, newHead$);
    this.opHash = opHash;
    this.context = context;
  }
  originationOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return findWithKind(operationResult, OpKind.ORIGINATION);
    });
  }
  revealOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return findWithKind(operationResult, OpKind.REVEAL);
    });
  }
  status() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.originationOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
  contract() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const op = yield this.originationOperation();
      const address = ((op === null || op === void 0 ? void 0 : op.metadata.operation_result.originated_contracts) || [])[0];
      return this.context.wallet.at(address);
    });
  }
}
class TransactionWalletOperation extends WalletOperation {
  constructor(opHash, context, newHead$) {
    super(opHash, context, newHead$);
    this.opHash = opHash;
    this.context = context;
  }
  revealOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return operationResult.find((x2) => x2.kind === OpKind.REVEAL);
    });
  }
  transactionOperation() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      return operationResult.find((x2) => x2.kind === OpKind.TRANSACTION);
    });
  }
  status() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.transactionOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
}
function timeoutAfter(timeoutMillisec) {
  return function inner(source) {
    return new BehaviorSubject(null).pipe(timeoutWith(timeoutMillisec, throwError(new Error("Confirmation polling timed out"))), mergeMap(() => source));
  };
}
const createNewPollingBasedHeadObservable = (sharedHeadOb, context, _scheduler) => {
  return sharedHeadOb.pipe(timeoutAfter(context.config.confirmationPollingTimeoutSecond * 1e3), publishReplay(1), refCount());
};
class OperationFactory {
  constructor(context) {
    this.context = context;
    this.sharedHeadObs = defer(() => {
      return createObservableFromSubscription(this.context.stream.subscribeBlock("head"));
    });
  }
  createNewHeadObservable() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return createNewPollingBasedHeadObservable(this.sharedHeadObs, this.context);
    });
  }
  createPastBlockWalker(startBlock, count = 1) {
    return from(this.context.readProvider.getBlock(startBlock)).pipe(switchMap((block) => {
      if (count === 1) {
        return of(block);
      }
      return range(block.header.level, count - 1).pipe(startWith(block), concatMap((level) => __awaiter$8(this, void 0, void 0, function* () {
        return this.context.readProvider.getBlock(typeof level === "number" ? level : level.header.level);
      })));
    }));
  }
  createHeadObservableFromConfig({ blockIdentifier }) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const observableSequence = [];
      if (blockIdentifier) {
        observableSequence.push(this.createPastBlockWalker(blockIdentifier));
      }
      observableSequence.push(yield this.createNewHeadObservable());
      return concat(...observableSequence);
    });
  }
  createOperation(hash3, config2 = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return new WalletOperation(hash3, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createBatchOperation(hash3, config2 = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return new BatchWalletOperation(hash3, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createTransactionOperation(hash3, config2 = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return new TransactionWalletOperation(hash3, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createDelegationOperation(hash3, config2 = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return new DelegationWalletOperation(hash3, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createOriginationOperation(hash3, config2 = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return new OriginationWalletOperation(hash3, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
}
class RpcTzProvider extends OperationEmitter {
  constructor(context) {
    super(context);
  }
  getBalance(address) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateAddress(address) !== ValidationResult.VALID) {
        throw new InvalidAddressError(address);
      }
      return this.context.readProvider.getBalance(address, "head");
    });
  }
  getDelegate(address) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateAddress(address) !== ValidationResult.VALID) {
        throw new InvalidAddressError(address);
      }
      return this.context.readProvider.getDelegate(address, "head");
    });
  }
  activate(pkh, secret2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateKeyHash(pkh) !== ValidationResult.VALID) {
        throw new InvalidKeyHashError(pkh);
      }
      const operation = {
        kind: OpKind.ACTIVATION,
        pkh,
        secret: secret2
      };
      const prepared = yield this.prepareOperation({ operation: [operation], source: pkh });
      const forgedBytes = yield this.forge(prepared);
      const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;
      return new Operation(yield this.rpc.injectOperation(bytes), Object.assign(Object.assign({}, forgedBytes), { opbytes: bytes }), [], this.context.clone());
    });
  }
}
const MINIMAL_FEE_MUTEZ = 100;
const MINIMAL_FEE_PER_BYTE_MUTEZ = 1;
const MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;
const GAS_BUFFER = 100;
class Estimate {
  constructor(_milligasLimit, _storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez = MINIMAL_FEE_MUTEZ) {
    this._milligasLimit = _milligasLimit;
    this._storageLimit = _storageLimit;
    this.opSize = opSize;
    this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;
    this.baseFeeMutez = baseFeeMutez;
  }
  /**
   * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)
   */
  get burnFeeMutez() {
    return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));
  }
  /**
   * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.
   */
  get storageLimit() {
    const limit = Math.max(Number(this._storageLimit), 0);
    return limit > 0 ? limit : 0;
  }
  /**
   * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.
   */
  get gasLimit() {
    return this.roundUp(Number(this._milligasLimit) / 1e3 + GAS_BUFFER);
  }
  get operationFeeMutez() {
    return (Number(this._milligasLimit) / 1e3 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;
  }
  roundUp(nanotez) {
    return Math.ceil(Number(nanotez));
  }
  /**
   * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.
   */
  get minimalFeeMutez() {
    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);
  }
  /**
   * @description The suggested fee for the operation which includes minimal fees and a small buffer.
   */
  get suggestedFeeMutez() {
    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);
  }
  /**
   * @description Fees according to your specified base fee will ensure that at least minimum fees are used.
   */
  get usingBaseFeeMutez() {
    return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);
  }
  /**
   * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.
   */
  get totalCost() {
    return this.minimalFeeMutez + this.burnFeeMutez;
  }
  /**
   * @description Since Delphinet, consumed gas is provided in milligas for more precision.
   * This function returns an estimation of the gas that operation will consume in milligas.
   */
  get consumedMilligas() {
    return Number(this._milligasLimit);
  }
  static createEstimateInstanceFromProperties(estimateProperties) {
    let milligasLimit = 0;
    let storageLimit = 0;
    let opSize = 0;
    let minimalFeePerStorageByteMutez = 0;
    let baseFeeMutez;
    estimateProperties.forEach((estimate) => {
      milligasLimit += estimate.milligasLimit;
      storageLimit += estimate.storageLimit;
      opSize += estimate.opSize;
      minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);
      if (estimate.baseFeeMutez) {
        baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;
      }
    });
    return new Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);
  }
  static createArrayEstimateInstancesFromProperties(estimateProperties) {
    return estimateProperties.map((x2) => new Estimate(x2.milligasLimit, x2.storageLimit, x2.opSize, x2.minimalFeePerStorageByteMutez, x2.baseFeeMutez));
  }
}
class RevealEstimateError extends Error {
  constructor() {
    super("Unable to estimate the reveal operation, the public key is unknown");
    this.name = "Reveal Estimate Error";
  }
}
const mergeLimits = (userDefinedLimit, defaultLimits) => {
  return {
    fee: typeof userDefinedLimit.fee === "undefined" ? defaultLimits.fee : userDefinedLimit.fee,
    gasLimit: typeof userDefinedLimit.gasLimit === "undefined" ? defaultLimits.gasLimit : userDefinedLimit.gasLimit,
    storageLimit: typeof userDefinedLimit.storageLimit === "undefined" ? defaultLimits.storageLimit : userDefinedLimit.storageLimit
  };
};
const SIGNATURE_STUB = "edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg";
class RPCEstimateProvider extends OperationEmitter {
  constructor() {
    super(...arguments);
    this.ALLOCATION_STORAGE = 257;
    this.ORIGINATION_STORAGE = 257;
    this.OP_SIZE_REVEAL = 128;
  }
  getKeys() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const isSignerConfigured = this.context.isAnySignerConfigured();
      return {
        publicKeyHash: isSignerConfigured ? yield this.signer.publicKeyHash() : yield this.context.walletProvider.getPKH(),
        publicKey: isSignerConfigured ? yield this.signer.publicKey() : void 0
      };
    });
  }
  // Maximum values defined by the protocol
  getAccountLimits(pkh, constants, numberOfOps) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const balance = yield this.context.readProvider.getBalance(pkh, "head");
      const { hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte } = constants;
      return {
        fee: 0,
        gasLimit: numberOfOps ? Math.floor(this.ajustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber()) : hard_gas_limit_per_operation.toNumber(),
        storageLimit: Math.floor(BigNumber$1.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())
      };
    });
  }
  // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.
  // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,
  // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).
  // numberOfOps is incremented by 1 for safety in case a reveal operation is needed
  ajustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {
    return BigNumber$1.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));
  }
  getEstimationPropertiesFromOperationContent(content, size, costPerByte, tx_rollup_origination_size) {
    const operationResults = flattenOperationResult({ contents: [content] });
    let totalMilligas = 0;
    let totalStorage = 0;
    operationResults.forEach((result) => {
      totalStorage += "originated_contracts" in result && typeof result.originated_contracts !== "undefined" ? result.originated_contracts.length * this.ORIGINATION_STORAGE : 0;
      totalStorage += "allocated_destination_contract" in result ? this.ALLOCATION_STORAGE : 0;
      totalMilligas += Number(result.consumed_milligas) || 0;
      totalStorage += "paid_storage_size_diff" in result ? Number(result.paid_storage_size_diff) || 0 : 0;
      totalStorage += "storage_size" in result && "global_address" in result ? Number(result.storage_size) || 0 : 0;
      totalStorage += "originated_rollup" in result ? tx_rollup_origination_size : 0;
    });
    if (isOpWithFee(content)) {
      return {
        milligasLimit: totalMilligas || 0,
        storageLimit: Number(totalStorage || 0),
        opSize: size,
        minimalFeePerStorageByteMutez: costPerByte.toNumber()
      };
    } else {
      return {
        milligasLimit: 0,
        storageLimit: 0,
        opSize: size,
        minimalFeePerStorageByteMutez: costPerByte.toNumber(),
        baseFeeMutez: 0
      };
    }
  }
  prepareEstimate(params, constants, pkh) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const prepared = yield this.prepareOperation(params, pkh);
      const { opbytes, opOb: { branch, contents } } = yield this.forge(prepared);
      const operation = {
        operation: { branch, contents, signature: SIGNATURE_STUB },
        chain_id: yield this.context.readProvider.getChainId()
      };
      const { opResponse } = yield this.simulate(operation);
      const { cost_per_byte, tx_rollup_origination_size } = constants;
      const errors = [...flattenErrors(opResponse, "backtracked"), ...flattenErrors(opResponse)];
      if (errors.length) {
        throw new TezosOperationError(errors, "Error occurred during estimation");
      }
      let numberOfOps = 1;
      if (Array.isArray(params.operation) && params.operation.length > 1) {
        numberOfOps = opResponse.contents[0].kind === "reveal" ? params.operation.length - 1 : params.operation.length;
      }
      return opResponse.contents.map((x2) => {
        return this.getEstimationPropertiesFromOperationContent(
          x2,
          // TODO: Calculate a specific opSize for each operation.
          x2.kind === "reveal" ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps,
          cost_per_byte,
          tx_rollup_origination_size !== null && tx_rollup_origination_size !== void 0 ? tx_rollup_origination_size : 0
        );
      });
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an origination operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param OriginationOperation Originate operation parameter
   */
  originate(_a2) {
    var { fee, storageLimit, gasLimit } = _a2, rest = __rest$1(_a2, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter$8(this, void 0, void 0, function* () {
      const { publicKeyHash } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);
      const op = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS))));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], publicKeyHash);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], publicKeyHash) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: publicKeyHash }, protocolConstants, publicKeyHash);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an transfer operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param TransferOperation Originate operation parameter
   */
  transfer(_a2) {
    var { fee, storageLimit, gasLimit } = _a2, rest = __rest$1(_a2, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateAddress(rest.to) !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.to);
      }
      if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.source);
      }
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a transferTicket operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param TransferTicketParams operation parameter
   */
  transferTicket(_a2) {
    var _b;
    var { fee, storageLimit, gasLimit } = _a2, rest = __rest$1(_a2, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(rest.destination) !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(rest.destination);
      }
      if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError((_b = rest.source) !== null && _b !== void 0 ? _b : "");
      }
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createTransferTicketOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a delegate operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  setDelegate(_a2) {
    var { fee, gasLimit, storageLimit } = _a2, rest = __rest$1(_a2, ["fee", "gasLimit", "storageLimit"]);
    return __awaiter$8(this, void 0, void 0, function* () {
      if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.source);
      }
      if (rest.delegate && validateAddress(rest.delegate) !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.delegate);
      }
      const pkh = (yield this.getKeys()).publicKeyHash;
      const sourceOrDefault = rest.source || pkh;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(sourceOrDefault, protocolConstants);
      const op = yield createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch
   *
   * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.
   */
  batch(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { publicKeyHash } = yield this.getKeys();
      let operations = [];
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants, params.length);
      for (const param of params) {
        switch (param.kind) {
          case OpKind.TRANSACTION:
            operations.push(yield createTransferOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          case OpKind.ORIGINATION:
            operations.push(yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))));
            break;
          case OpKind.DELEGATION:
            operations.push(yield createSetDelegateOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          case OpKind.ACTIVATION:
            operations.push(Object.assign(Object.assign({}, param), DEFAULT_PARAMS));
            break;
          case OpKind.REGISTER_GLOBAL_CONSTANT:
            operations.push(yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          case OpKind.TX_ROLLUP_ORIGINATION:
            operations.push(yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          case OpKind.TX_ROLLUP_SUBMIT_BATCH:
            operations.push(yield createTxRollupBatchOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          case OpKind.TRANSFER_TICKET:
            operations.push(yield createTransferTicketOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          case OpKind.INCREASE_PAID_STORAGE:
            operations.push(yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
            break;
          default:
            throw new InvalidOperationKindError(params.kind);
        }
      }
      const isRevealNeeded = yield this.isRevealOpNeeded(operations, publicKeyHash);
      operations = isRevealNeeded ? yield this.addRevealOp(operations, publicKeyHash) : operations;
      const estimateProperties = yield this.prepareEstimate({ operation: operations, source: publicKeyHash }, protocolConstants, publicKeyHash);
      return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a delegate operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  registerDelegate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createRegisterDelegateOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), pkh);
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees to reveal the current account
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed
   *
   * @param Estimate
   */
  reveal(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { publicKeyHash, publicKey } = yield this.getKeys();
      if (!publicKey) {
        throw new RevealEstimateError();
      }
      if (yield this.isAccountRevealRequired(publicKeyHash)) {
        const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
        const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);
        const op = yield createRevealOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), publicKeyHash, publicKey);
        const estimateProperties = yield this.prepareEstimate({ operation: op, source: publicKeyHash }, protocolConstants, publicKeyHash);
        return Estimate.createEstimateInstanceFromProperties(estimateProperties);
      }
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param params registerGlobalConstant operation parameter
   */
  registerGlobalConstant(_a2) {
    var { fee, storageLimit, gasLimit } = _a2, rest = __rest$1(_a2, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter$8(this, void 0, void 0, function* () {
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit, and fees for an increasePaidStorage operation
   *
   * @returns An estimation of gasLimit, storageLimit, and fees for the operation
   *
   * @param params increasePaidStorage operation parameters
   */
  increasePaidStorage(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { fee, storageLimit, gasLimit } = params, rest = __rest$1(params, ["fee", "storageLimit", "gasLimit"]);
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a rollup origination operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param TxRollupOriginateParams Originate tx rollup operation parameter
   */
  txRollupOriginate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      params = params ? params : {};
      const { fee, storageLimit, gasLimit } = params, rest = __rest$1(params, ["fee", "storageLimit", "gasLimit"]);
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a tx rollup batch operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  txRollupSubmitBatch(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { fee, storageLimit, gasLimit } = params, rest = __rest$1(params, ["fee", "storageLimit", "gasLimit"]);
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createTxRollupBatchOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  updateConsensusKey(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { fee, storageLimit, gasLimit } = params, rest = __rest$1(params, ["fee", "storageLimit", "gasLimit"]);
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
      const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
      if (isRevealNeeded) {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  addRevealOp(op, pkh) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { publicKey } = yield this.getKeys();
      if (!publicKey) {
        throw new RevealEstimateError();
      }
      op.unshift(yield createRevealOperation(Object.assign({
        fee: DEFAULT_FEE.REVEAL,
        gasLimit: DEFAULT_GAS_LIMIT.REVEAL,
        storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL
      }), pkh, yield this.signer.publicKey()));
      return op;
    });
  }
}
class DelegateOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const delegationOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "delegation");
    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get delegate() {
    return this.params.delegate;
  }
  get isRegisterOperation() {
    return this.delegate === this.source;
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
}
class OriginationOperation extends Operation {
  constructor(hash3, params, raw, results, context, contractProvider) {
    super(hash3, raw, results, context);
    this.params = params;
    this.contractProvider = contractProvider;
    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;
    if (Array.isArray(originatedContracts)) {
      this.contractAddress = originatedContracts[0];
    }
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get operationResults() {
    const originationOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "origination");
    const result = originationOp && hasMetadataWithResult(originationOp) && originationOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
  get storageDiff() {
    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;
    return storageDiff ? storageDiff : void 0;
  }
  get storageSize() {
    const storageSize = this.operationResults && this.operationResults.storage_size;
    return storageSize ? storageSize : void 0;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
  /**
   * @description Provide the contract abstract of the newly originated contract
   */
  contract(confirmations, timeout) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.contractAddress) {
        throw new OriginationOperationError("No contract was originated in this operation");
      }
      yield this.confirmation(confirmations, timeout);
      return this.contractProvider.at(this.contractAddress);
    });
  }
}
class RegisterGlobalConstantOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
    this.globalConstantHash = this.operationResults && this.operationResults.global_address;
  }
  get operationResults() {
    const registerGlobalConstantOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "register_global_constant");
    const result = registerGlobalConstantOp && registerGlobalConstantOp.metadata && registerGlobalConstantOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get registeredExpression() {
    return this.params.value;
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
}
class RevealOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const revealOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "reveal");
    return revealOp ? [revealOp] : [];
  }
  get status() {
    const operationResults = this.operationResults;
    const txResult = operationResults[0];
    if (txResult) {
      return txResult.metadata.operation_result.status;
    } else {
      return "unknown";
    }
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get publicKey() {
    return this.params.public_key;
  }
  sumProp(arr, prop) {
    return arr.reduce((prev, current) => {
      return prop in current ? Number(current[prop]) + prev : prev;
    }, 0);
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString();
  }
  get consumedMilliGas() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "consumed_milligas"));
  }
  get storageDiff() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "paid_storage_size_diff"));
  }
  get storageSize() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "storage_size"));
  }
  get errors() {
    return flattenErrors({ contents: this.operationResults });
  }
}
class TransactionOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const transactionOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "transaction");
    return transactionOp ? [transactionOp] : [];
  }
  get status() {
    const operationResults = this.operationResults;
    const txResult = operationResults[0];
    if (txResult) {
      return txResult.metadata.operation_result.status;
    } else {
      return "unknown";
    }
  }
  get amount() {
    return new BigNumber$1(this.params.amount);
  }
  get destination() {
    return this.params.destination;
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  sumProp(arr, prop) {
    return arr.reduce((prev, current) => {
      return prop in current ? Number(current[prop]) + prev : prev;
    }, 0);
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString();
  }
  get consumedMilliGas() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "consumed_milligas"));
  }
  get storageDiff() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "paid_storage_size_diff"));
  }
  get storageSize() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "storage_size"));
  }
  get errors() {
    return flattenErrors({ contents: this.operationResults });
  }
}
class ContractMethod {
  constructor(provider, address, parameterSchema, name2, args, isMultipleEntrypoint = true, isAnonymous = false) {
    this.provider = provider;
    this.address = address;
    this.parameterSchema = parameterSchema;
    this.name = name2;
    this.args = args;
    this.isMultipleEntrypoint = isMultipleEntrypoint;
    this.isAnonymous = isAnonymous;
  }
  validateArgs(args, schema, name2) {
    const sigs = schema.ExtractSignatures();
    if (!sigs.find((x2) => x2.length === args.length)) {
      throw new InvalidParameterError(name2, sigs, args);
    }
  }
  /**
   * @description Get the schema of the smart contract method
   */
  get schema() {
    return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();
  }
  /**
   * @description Get the signature of the smart contract method
   */
  getSignature() {
    if (this.isAnonymous) {
      const sig = this.parameterSchema.ExtractSignatures().find((x2) => x2[0] === this.name);
      if (sig) {
        sig.shift();
        return sig;
      }
    } else {
      const sig = this.parameterSchema.ExtractSignatures();
      return sig.length == 1 ? sig[0] : sig;
    }
  }
  /**
   *
   * @description Send the smart contract operation
   *
   * @param Options generic operation parameter
   */
  send(params = {}) {
    if (this.provider instanceof Wallet) {
      return this.provider.transfer(this.toTransferParams(params)).send();
    } else {
      return this.provider.transfer(this.toTransferParams(params));
    }
  }
  /**
   *
   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
   *
   * @param Options generic transfer operation parameters
   */
  toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false } = {}) {
    const fullTransferParams = {
      to: this.address,
      amount,
      fee,
      mutez,
      source,
      gasLimit,
      storageLimit,
      parameter: {
        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,
        value: this.isAnonymous ? this.parameterSchema.Encode(this.name, ...this.args) : this.parameterSchema.Encode(...this.args)
      }
    };
    return fullTransferParams;
  }
}
class SaplingStateAbstraction {
  constructor(id2, provider) {
    this.id = id2;
    this.provider = provider;
  }
  /**
   *
   * @description Fetch the sapling state
   *
   * @param block optional block level to fetch the values from (head will be use by default)
   * @returns Return a json object of the sapling_state
   *
   */
  getSaplingDiff(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.provider.getSaplingDiffByID(this.id.toString(), block);
    });
  }
  getId() {
    return this.id.toString();
  }
}
class WalletOperationBatch {
  constructor(walletProvider, context) {
    this.walletProvider = walletProvider;
    this.context = context;
    this.operations = [];
  }
  /**
   *
   * @description Add a transaction operation to the batch
   *
   * @param params Transfer operation parameter
   */
  withTransfer(params) {
    if (validateAddress(params.to) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.to);
    }
    this.operations.push(Object.assign({ kind: OpKind.TRANSACTION }, params));
    return this;
  }
  /**
   *
   * @description Add a contract call to the batch
   *
   * @param params Call a contract method
   * @param options Generic operation parameters
   */
  withContractCall(params, options = {}) {
    return this.withTransfer(params.toTransferParams(options));
  }
  /**
   *
   * @description Add a delegation operation to the batch
   *
   * @param params Delegation operation parameter
   */
  withDelegation(params) {
    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.delegate);
    }
    this.operations.push(Object.assign({ kind: OpKind.DELEGATION }, params));
    return this;
  }
  /**
   *
   * @description Add an origination operation to the batch
   *
   * @param params Origination operation parameter
   */
  withOrigination(params) {
    this.operations.push(Object.assign({ kind: OpKind.ORIGINATION }, params));
    return this;
  }
  mapOperation(param) {
    return __awaiter$8(this, void 0, void 0, function* () {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          return this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter$8(this, void 0, void 0, function* () {
            return param;
          }));
        case OpKind.ORIGINATION:
          return this.walletProvider.mapOriginateParamsToWalletParams(() => __awaiter$8(this, void 0, void 0, function* () {
            return this.context.parser.prepareCodeOrigination(Object.assign({}, param));
          }));
        case OpKind.DELEGATION:
          return this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter$8(this, void 0, void 0, function* () {
            return param;
          }));
        default:
          throw new InvalidOperationKindError(param.kind);
      }
    });
  }
  /**
   *
   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
   *
   * @param params Operations parameter
   */
  with(params) {
    for (const param of params) {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          this.withTransfer(param);
          break;
        case OpKind.ORIGINATION:
          this.withOrigination(param);
          break;
        case OpKind.DELEGATION:
          this.withDelegation(param);
          break;
        default:
          throw new InvalidOperationKindError(param.kind);
      }
    }
    return this;
  }
  /**
   *
   * @description Submit batch operation to wallet
   *
   */
  send() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const ops = [];
      for (const op of this.operations) {
        ops.push(yield this.mapOperation(op));
      }
      const opHash = yield this.walletProvider.sendOperations(ops);
      return this.context.operationFactory.createBatchOperation(opHash);
    });
  }
}
class Wallet {
  constructor(context) {
    this.context = context;
    this.walletCommand = (send) => {
      return {
        send
      };
    };
  }
  get walletProvider() {
    return this.context.walletProvider;
  }
  /**
   * @description Retrieve the PKH of the account that is currently in use by the wallet
   *
   * @param option Option to use while fetching the PKH.
   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet
   */
  pkh({ forceRefetch } = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this._pkh || forceRefetch) {
        this._pkh = yield this.walletProvider.getPKH();
      }
      return this._pkh;
    });
  }
  /**
   *
   * @description Originate a new contract according to the script in parameters.
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param originateParams Originate operation parameter
   */
  originate(params) {
    return this.walletCommand(() => __awaiter$8(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(() => this.context.parser.prepareCodeOrigination(Object.assign({}, params)));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createOriginationOperation(opHash);
    }));
  }
  /**
   *
   * @description Set the delegate for a contract.
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param delegateParams operation parameter
   */
  setDelegate(params) {
    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.delegate);
    }
    return this.walletCommand(() => __awaiter$8(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter$8(this, void 0, void 0, function* () {
        return params;
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createDelegationOperation(opHash);
    }));
  }
  /**
   *
   * @description Register the current address as delegate.
   *
   * @returns An operation handle with the result from the rpc node
   *
   */
  registerDelegate() {
    return this.walletCommand(() => __awaiter$8(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter$8(this, void 0, void 0, function* () {
        const delegate = yield this.pkh();
        return { delegate };
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createDelegationOperation(opHash);
    }));
  }
  /**
   *
   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.
   *
   * @returns A wallet command from which we can send the operation to the wallet
   *
   * @param params operation parameter
   */
  transfer(params) {
    if (validateAddress(params.to) !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.to);
    }
    return this.walletCommand(() => __awaiter$8(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter$8(this, void 0, void 0, function* () {
        return params;
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createTransactionOperation(opHash);
    }));
  }
  /**
   *
   * @description Create a batch of operation
   *
   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch
   *
   * @param params List of operation to initialize the batch with
   */
  batch(params) {
    const batch = new WalletOperationBatch(this.walletProvider, this.context);
    if (Array.isArray(params)) {
      batch.with(params);
    }
    return batch;
  }
  /**
   *
   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned
   * smart contract abstraction will leverage the wallet provider to make smart contract calls
   *
   * @param address Smart contract address
   */
  at(address, contractAbstractionComposer = (x2) => x2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(address) !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(address);
      }
      const rpc = this.context.withExtensions().rpc;
      const readProvider = this.context.withExtensions().readProvider;
      const script = yield readProvider.getScript(address, "head");
      const entrypoints = yield readProvider.getEntrypoints(address);
      const abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);
      return contractAbstractionComposer(abs, this.context);
    });
  }
}
class LegacyWalletProvider {
  constructor(context) {
    this.context = context;
  }
  getPKH() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.context.signer.publicKeyHash();
    });
  }
  mapTransferParamsToWalletParams(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.TRANSACTION);
    });
  }
  mapOriginateParamsToWalletParams(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.ORIGINATION);
    });
  }
  mapDelegateParamsToWalletParams(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.DELEGATION);
    });
  }
  sendOperations(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const op = yield this.context.batch.batch(params).send();
      return op.hash;
    });
  }
}
class ContractMethodObject {
  constructor(provider, address, parameterSchema, name2, args = "unit", isMultipleEntrypoint = true, isAnonymous = false) {
    this.provider = provider;
    this.address = address;
    this.parameterSchema = parameterSchema;
    this.name = name2;
    this.args = args;
    this.isMultipleEntrypoint = isMultipleEntrypoint;
    this.isAnonymous = isAnonymous;
  }
  /**
   * @description Get the signature of the smart contract method
   */
  getSignature() {
    return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();
  }
  /**
   *
   * @description Send the smart contract operation
   *
   * @param Options generic operation parameter
   */
  send(params = {}) {
    if (this.provider instanceof Wallet) {
      return this.provider.transfer(this.toTransferParams(params)).send();
    } else {
      return this.provider.transfer(this.toTransferParams(params));
    }
  }
  /**
   *
   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
   *
   * @param Options generic transfer operation parameters
   */
  toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false } = {}) {
    const fullTransferParams = {
      to: this.address,
      amount,
      fee,
      mutez,
      source,
      gasLimit,
      storageLimit,
      parameter: {
        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,
        value: this.isAnonymous ? this.parameterSchema.EncodeObject({ [this.name]: this.args }) : this.parameterSchema.EncodeObject(this.args)
      }
    };
    return fullTransferParams;
  }
}
class OnChainView {
  constructor(_rpc, _readProvider, _contractAddress, _smartContractViewSchema, _contractStorageType, _args = "Unit") {
    this._rpc = _rpc;
    this._readProvider = _readProvider;
    this._contractAddress = _contractAddress;
    this._smartContractViewSchema = _smartContractViewSchema;
    this._contractStorageType = _contractStorageType;
    this._args = _args;
  }
  /**
   * @description Get the signature of the smart contract view
   */
  getSignature() {
    return {
      parameter: this._smartContractViewSchema.extractArgsSchema(),
      result: this._smartContractViewSchema.extractResultSchema()
    };
  }
  /**
   * @description Get the result of the view simulation
   * @param executionContext.source the public key hash of the account who initialized this view execution.
   * @param executionContext.viewCaller the contract address which is the caller of view.
   */
  executeView(executionContext) {
    return __awaiter$8(this, void 0, void 0, function* () {
      this.verifyContextExecution(executionContext);
      const chainId = yield this._readProvider.getChainId();
      const viewArgs = this.transformArgsToMichelson();
      const scriptView = {
        contract: this._contractAddress,
        view: this._smartContractViewSchema.viewName,
        input: viewArgs,
        chain_id: chainId,
        source: executionContext.viewCaller
      };
      if (executionContext.source) {
        scriptView.payer = executionContext.source;
      }
      return this.executeViewAndDecodeResult(scriptView);
    });
  }
  verifyContextExecution(executionContext) {
    if (executionContext.source && validateAddress(executionContext.source) !== ValidationResult.VALID) {
      throw new InvalidViewSimulationContext(`The source account who initialized the view execution is invalid: ${executionContext.source}.`);
    }
    if (!executionContext.viewCaller || validateAddress(executionContext.viewCaller) !== ValidationResult.VALID) {
      throw new InvalidViewSimulationContext(`The contract which is the caller of view is invalid: ${executionContext.viewCaller}.`);
    }
  }
  transformArgsToMichelson() {
    try {
      return this._smartContractViewSchema.encodeViewArgs(this._args);
    } catch (error) {
      throw new InvalidViewParameterError(this._smartContractViewSchema.viewName, this.getSignature(), this._args, error);
    }
  }
  /**
   * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.
   *
   * Certain specific instructions have different semantics in view:
   * BALANCE represents the current amount of mutez held by the contract where view is;
   * SENDER represents the contract which is the caller of view;
   * SELF_ADDRESS represents the contract where view is;
   * AMOUNT is always 0 mutez.
   *
   */
  adaptViewCodeToContext(instructions, viewCaller, contractBalance) {
    const instructionsToReplace = {
      BALANCE: [{ prim: "PUSH", args: [{ prim: "mutez" }, { int: contractBalance }] }],
      SENDER: [{ prim: "PUSH", args: [{ prim: "address" }, { string: viewCaller }] }],
      SELF_ADDRESS: [
        { prim: "PUSH", args: [{ prim: "address" }, { string: this._contractAddress }] }
      ],
      AMOUNT: [{ prim: "PUSH", args: [{ prim: "mutez" }, { int: "0" }] }]
    };
    instructions.forEach((inst, i2) => {
      if (inst.prim in instructionsToReplace) {
        instructions[i2] = Object(instructionsToReplace)[inst.prim];
      }
      if (inst.args && inst.args.length !== 0) {
        this.adaptViewCodeToContext(inst.args, viewCaller, contractBalance);
      } else if (Array.isArray(inst)) {
        this.adaptViewCodeToContext(inst, viewCaller, contractBalance);
      }
    });
    return instructions;
  }
  executeViewAndDecodeResult(viewScript) {
    return __awaiter$8(this, void 0, void 0, function* () {
      let storage;
      try {
        storage = (yield this._rpc.runScriptView(viewScript)).data;
      } catch (error) {
        const failWith = validateAndExtractFailwith(error);
        throw failWith ? new ViewSimulationError(`The simulation of the on-chain view named ${this._smartContractViewSchema.viewName} failed with: ${JSON.stringify(failWith)}`, this._smartContractViewSchema.viewName, failWith, error) : error;
      }
      return this._smartContractViewSchema.decodeViewResult(storage);
    });
  }
}
class ContractMethodFactory {
  constructor(provider, contractAddress) {
    this.provider = provider;
    this.contractAddress = contractAddress;
  }
  createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {
    return new ContractMethod(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);
  }
  createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {
    return new ContractMethodObject(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);
  }
  createContractViewObjectParam(rpc, readProvider, smartContractViewSchema, contractStorageType, viewArgs) {
    return new OnChainView(rpc, readProvider, this.contractAddress, smartContractViewSchema, contractStorageType, viewArgs);
  }
}
const DEFAULT_SMART_CONTRACT_METHOD_NAME = "default";
class ContractView {
  constructor(currentContract, name2, callbackParametersSchema, parameterSchema, args, rpc, readProvider) {
    this.currentContract = currentContract;
    this.name = name2;
    this.callbackParametersSchema = callbackParametersSchema;
    this.parameterSchema = parameterSchema;
    this.args = args;
    this.rpc = rpc;
    this.readProvider = readProvider;
  }
  read(chainId) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(chainId !== null && chainId !== void 0 ? chainId : "") == ValidationResult.VALID) {
        throw new DeprecationError(`Since version 12, the lambda view no longer depends on a lambda contract. The read method no longer accepts a contract address as a parameter.`);
      } else if (chainId && validateChain(chainId) !== ValidationResult.VALID) {
        throw new InvalidChainIdError(chainId);
      }
      const arg = this.parameterSchema.Encode(...this.args);
      const result = yield this.rpc.runView({
        contract: this.currentContract.address,
        entrypoint: this.name,
        input: arg,
        chain_id: chainId ? chainId : yield this.readProvider.getChainId()
      });
      return this.callbackParametersSchema.Execute(result.data);
    });
  }
}
const validateArgs = (args, schema, name2) => {
  const sigs = schema.ExtractSignatures();
  if (!sigs.find((x2) => x2.length === args.length)) {
    throw new InvalidParameterError(name2, sigs, args);
  }
};
const isView = (entrypoint) => {
  let isView2 = false;
  if ("prim" in entrypoint && entrypoint.prim === "pair" && entrypoint.args) {
    const lastElement = entrypoint.args[entrypoint.args.length - 1];
    if ("prim" in lastElement && lastElement.prim === "contract") {
      isView2 = true;
    }
  }
  return isView2;
};
class ContractAbstraction {
  constructor(address, script, provider, storageProvider, entrypoints, rpc, readProvider) {
    this.address = address;
    this.script = script;
    this.storageProvider = storageProvider;
    this.entrypoints = entrypoints;
    this.rpc = rpc;
    this.readProvider = readProvider;
    this.methods = {};
    this.methodsObject = {};
    this.views = {};
    this.contractViews = {};
    this.contractMethodFactory = new ContractMethodFactory(provider, address);
    this.schema = Schema.fromRPCResponse({ script: this.script });
    this.parameterSchema = ParameterSchema.fromRPCResponse({ script: this.script });
    this.viewSchema = ViewSchema.fromRPCResponse({ script: this.script });
    if (this.viewSchema.length !== 0) {
      this._initializeOnChainViews(this, rpc, this.readProvider, this.viewSchema);
    }
    this._initializeMethods(this, this.entrypoints.entrypoints, this.rpc, this.readProvider);
  }
  _initializeMethods(currentContract, entrypoints, rpc, readProvider) {
    const parameterSchema = this.parameterSchema;
    const keys = Object.keys(entrypoints);
    if (parameterSchema.isMultipleEntryPoint) {
      keys.forEach((smartContractMethodName) => {
        const smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);
        this.methods[smartContractMethodName] = function(...args) {
          return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args);
        };
        this.methodsObject[smartContractMethodName] = function(args) {
          return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args);
        };
        if (isView(entrypoints[smartContractMethodName])) {
          const view = function(...args) {
            const entrypointParamWithoutCallback = entrypoints[smartContractMethodName].args[0];
            const smartContractMethodSchemaWithoutCallback = new ParameterSchema(entrypointParamWithoutCallback);
            const parametersCallback = entrypoints[smartContractMethodName].args[1].args[0];
            const smartContractMethodCallbackSchema = new ParameterSchema(parametersCallback);
            validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);
            return new ContractView(currentContract, smartContractMethodName, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args, rpc, readProvider);
          };
          this.views[smartContractMethodName] = view;
        }
      });
      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter((key2) => Object.keys(entrypoints).indexOf(key2) === -1);
      anonymousMethods.forEach((smartContractMethodName) => {
        this.methods[smartContractMethodName] = function(...args) {
          return currentContract.contractMethodFactory.createContractMethodFlatParams(parameterSchema, smartContractMethodName, args, false, true);
        };
        this.methodsObject[smartContractMethodName] = function(args) {
          return currentContract.contractMethodFactory.createContractMethodObjectParam(parameterSchema, smartContractMethodName, args, false, true);
        };
      });
    } else {
      const smartContractMethodSchema = this.parameterSchema;
      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function(...args) {
        return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
      };
      this.methodsObject[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function(args) {
        return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
      };
    }
  }
  _initializeOnChainViews(currentContract, rpc, readProvider, allContractViews) {
    const storageType = this.schema.val;
    allContractViews.forEach((viewSchema) => {
      this.contractViews[viewSchema.viewName] = function(args) {
        return currentContract.contractMethodFactory.createContractViewObjectParam(rpc, readProvider, viewSchema, storageType, args);
      };
    });
  }
  /**
   * @description Return a friendly representation of the smart contract storage
   */
  storage() {
    return this.storageProvider.getStorage(this.address, this.schema);
  }
  /**
   *
   * @description Return a friendly representation of the smart contract big map value
   *
   * @param key BigMap key to fetch
   *
   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
   */
  bigMap(key2) {
    return this.storageProvider.getBigMapKey(this.address, key2, this.schema);
  }
}
class BigMapAbstraction {
  constructor(id2, schema, provider) {
    this.id = id2;
    this.schema = schema;
    this.provider = provider;
  }
  /**
   *
   * @description Fetch one value in a big map
   *
   * @param keysToEncode Key to query (will be encoded properly according to the schema)
   * @param block optional block level to fetch the values from (head will be use by default)
   * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map
   *
   */
  get(keyToEncode, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      try {
        const id2 = yield this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema, block);
        return id2;
      } catch (e) {
        if (e instanceof HttpResponseError && e.status === STATUS_CODE.NOT_FOUND) {
          return void 0;
        } else {
          throw e;
        }
      }
    });
  }
  /**
   *
   * @description Fetch multiple values in a big map
   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
   * If one of the keys does not exist in the big map, its value will be set to undefined.
   *
   * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)
   * @param block optional block level to fetch the values from
   * @param batchSize optional batch size representing the number of requests to execute in parallel
   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
   *
   */
  getMultipleValues(keysToEncode, block, batchSize = 5) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.provider.getBigMapKeysByID(this.id.toString(), keysToEncode, this.schema, block, batchSize);
    });
  }
  toJSON() {
    return this.id.toString();
  }
  toString() {
    return this.id.toString();
  }
}
const smartContractAbstractionSemantic = (provider) => ({
  // Provide a specific abstraction for BigMaps
  big_map: (val, code2) => {
    if (!val || !("int" in val) || val.int === void 0) {
      return {};
    } else {
      const schema = new Schema(code2);
      return new BigMapAbstraction(new BigNumber$1(val.int), schema, provider);
    }
  },
  sapling_state: (val) => {
    if (!val || !("int" in val) || val.int === void 0) {
      return {};
    } else {
      return new SaplingStateAbstraction(new BigNumber$1(val.int), provider);
    }
  }
  /*
  // TODO: embed useful other abstractions
  'contract':  () => {},
  'address':  () => {}
  */
});
class TxRollupOriginationOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
    this.originatedRollup = this.operationResults && this.operationResults.originated_rollup;
  }
  get operationResults() {
    const rollupOriginationOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "tx_rollup_origination");
    const result = rollupOriginationOp && rollupOriginationOp.metadata && rollupOriginationOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
}
class TxRollupBatchOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const txrollupBatchOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "tx_rollup_submit_batch");
    const result = txrollupBatchOp && txrollupBatchOp.metadata && txrollupBatchOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get content() {
    return this.params.content;
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
}
class BallotOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const ballotOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "ballot");
    const result = ballotOp;
    return result ? result : void 0;
  }
  get period() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.period;
  }
  get proposal() {
    return this.params.proposal;
  }
  get ballot() {
    return this.params.ballot;
  }
}
class DrainDelegateOperation extends Operation {
  constructor(hash3, params, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
  }
  get operationResults() {
    const drainDelegateOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "drain_delegate");
    const result = drainDelegateOp && drainDelegateOp.metadata && drainDelegateOp.metadata.balance_updates;
    return result ? result : void 0;
  }
  get consensusKey() {
    return this.params.consensus_key;
  }
  get delegate() {
    return this.params.delegate;
  }
  get destination() {
    return this.params.destination;
  }
}
class TransferTicketOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const transferOp = Array.isArray(this.results) && this.results.find((op) => op.kind === OpKind.TRANSFER_TICKET);
    const result = transferOp && transferOp.metadata && transferOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get consumedGas() {
    BigNumber$1.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber$1.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber$1(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
}
class IncreasePaidStorageOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const increasePaidStorageOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "increase_paid_storage");
    const result = increasePaidStorageOp && increasePaidStorageOp.metadata && increasePaidStorageOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
  get amount() {
    return this.params.amount;
  }
  get destination() {
    return this.params.destination;
  }
}
class ProposalsOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const proposalsOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "proposals");
    const result = proposalsOp;
    return result ? result : void 0;
  }
  get proposals() {
    return this.params.proposals;
  }
  get period() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.period;
  }
}
class UpdateConsensusKeyOperation extends Operation {
  constructor(hash3, params, source, raw, results, context) {
    super(hash3, raw, results, context);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const updateConsensusKeyOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "update_consensus_key");
    const result = updateConsensusKeyOp && updateConsensusKeyOp.metadata && updateConsensusKeyOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a2, _b;
    return (_b = (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return this.params.fee;
  }
  get gasLimit() {
    return this.params.gas_limit;
  }
  get storageLimit() {
    return this.params.storage_limit;
  }
  get pk() {
    return this.params.pk;
  }
  get consumedMilliGas() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.consumed_milligas;
  }
  get errors() {
    var _a2;
    return (_a2 = this.operationResults) === null || _a2 === void 0 ? void 0 : _a2.errors;
  }
}
class RpcContractProvider extends OperationEmitter {
  constructor(context, estimator) {
    super(context);
    this.estimator = estimator;
    this.contractProviderTypeSymbol = Symbol.for("taquito-contract-provider-type-symbol");
  }
  /**
   *
   * @description Return a well formatted json object of the contract storage
   *
   * @param contract contract address you want to get the storage from
   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
   */
  getStorage(contract, schema) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(contract) !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(contract);
      }
      const script = yield this.context.readProvider.getScript(contract, "head");
      if (!schema) {
        schema = script;
      }
      let contractSchema;
      if (Schema.isSchema(schema)) {
        contractSchema = schema;
      } else {
        contractSchema = Schema.fromRPCResponse({ script: schema });
      }
      return contractSchema.Execute(script.storage, smartContractAbstractionSemantic(this));
    });
  }
  /**
   *
   * @description Return a well formatted json object of the contract big map storage
   *
   * @param contract contract address you want to get the storage from
   * @param key contract big map key to fetch value from
   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
   *
   * @deprecated Deprecated in favor of getBigMapKeyByID
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
   */
  getBigMapKey(contract, key2, schema) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(contract) !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(contract);
      }
      if (!schema) {
        schema = (yield this.rpc.getContract(contract)).script;
      }
      let contractSchema;
      if (Schema.isSchema(schema)) {
        contractSchema = schema;
      } else {
        contractSchema = Schema.fromRPCResponse({ script: schema });
      }
      const encodedKey = contractSchema.EncodeBigMapKey(key2);
      const val = yield this.rpc.getBigMapKey(contract, encodedKey);
      return contractSchema.ExecuteOnBigMapValue(val);
    });
  }
  /**
   *
   * @description Return a well formatted json object of a big map value
   *
   * @param id Big Map ID
   * @param keyToEncode key to query (will be encoded properly according to the schema)
   * @param schema Big Map schema (can be determined using your contract type)
   * @param block optional block level to fetch the values from
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
   */
  getBigMapKeyByID(id2, keyToEncode, schema, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { key: key2, type } = schema.EncodeBigMapKey(keyToEncode);
      const { packed } = yield this.context.packer.packData({ data: key2, type });
      const encodedExpr = encodeExpr(packed);
      const bigMapValue = block ? yield this.context.readProvider.getBigMapValue({ id: id2.toString(), expr: encodedExpr }, block) : yield this.context.readProvider.getBigMapValue({ id: id2.toString(), expr: encodedExpr }, "head");
      return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this));
    });
  }
  /**
   *
   * @description Fetch multiple values in a big map
   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
   * If one of the keys does not exist in the big map, its value will be set to undefined.
   *
   * @param id Big Map ID
   * @param keys Array of keys to query (will be encoded properly according to the schema)
   * @param schema Big Map schema (can be determined using your contract type)
   * @param block optional block level to fetch the values from
   * @param batchSize optional batch size representing the number of requests to execute in parallel
   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
   *
   */
  getBigMapKeysByID(id2, keys, schema, block, batchSize = 5) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const level = yield this.getBlockForRequest(keys, block);
      const bigMapValues = new MichelsonMap();
      let position = 0;
      let results = [];
      while (position < keys.length) {
        const keysBatch = keys.slice(position, position + batchSize);
        const batch = keysBatch.map((keyToEncode) => this.getBigMapValueOrUndefined(keyToEncode, id2, schema, level));
        results = [...results, ...yield Promise.all(batch)];
        position += batchSize;
      }
      for (let i2 = 0; i2 < results.length; i2++) {
        bigMapValues.set(keys[i2], results[i2]);
      }
      return bigMapValues;
    });
  }
  getBlockForRequest(keys, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return keys.length === 1 || typeof block !== "undefined" ? block : yield this.context.readProvider.getBlockLevel("head");
    });
  }
  getBigMapValueOrUndefined(keyToEncode, id2, schema, level) {
    return __awaiter$8(this, void 0, void 0, function* () {
      try {
        return yield this.getBigMapKeyByID(id2, keyToEncode, schema, level);
      } catch (ex) {
        if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {
          return;
        } else {
          throw ex;
        }
      }
    });
  }
  /**
   *
   * @description Return a well formatted json object of a sapling state
   *
   * @param id Sapling state ID
   * @param block optional block level to fetch the value from
   *
   */
  getSaplingDiffByID(id2, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const saplingState = block ? yield this.context.readProvider.getSaplingDiffById({ id: id2.toString() }, block) : yield this.context.readProvider.getSaplingDiffById({ id: id2.toString() }, "head");
      return saplingState;
    });
  }
  addRevealOperationIfNeeded(operation, publicKeyHash) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (isOpRequireReveal(operation)) {
        const ops = [operation];
        const publicKey = yield this.signer.publicKey();
        const estimateReveal = yield this.estimator.reveal();
        if (estimateReveal) {
          const reveal = { kind: OpKind.REVEAL };
          const estimatedReveal = yield this.estimate(reveal, () => __awaiter$8(this, void 0, void 0, function* () {
            return estimateReveal;
          }));
          ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
          return ops;
        }
      }
      return operation;
    });
  }
  /**
   *
   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)
   *
   * @param OriginationOperation Originate operation parameter
   */
  originate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const estimate = yield this.estimate(params, this.estimator.originate.bind(this.estimator));
      const publicKeyHash = yield this.signer.publicKeyHash();
      const operation = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, params), estimate)));
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const preparedOrigination = yield this.prepareOperation({
        operation: ops,
        source: publicKeyHash
      });
      const forgedOrigination = yield this.forge(preparedOrigination);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(forgedOrigination);
      return new OriginationOperation(hash3, operation, forgedBytes, opResponse, context, this);
    });
  }
  /**
   *
   * @description Set the delegate for a contract. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param SetDelegate operation parameter
   */
  setDelegate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source);
      }
      if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.delegate);
      }
      if (/kt1/i.test(params.source)) {
        throw new InvalidDelegationSource(params.source);
      }
      const estimate = yield this.estimate(params, this.estimator.setDelegate.bind(this.estimator));
      const publicKeyHash = yield this.signer.publicKeyHash();
      const operation = yield createSetDelegateOperation(Object.assign(Object.assign({}, params), estimate));
      const sourceOrDefault = params.source || publicKeyHash;
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const prepared = yield this.prepareOperation({
        operation: ops,
        source: sourceOrDefault
      });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new DelegateOperation(hash3, operation, sourceOrDefault, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Register the current address as delegate. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param RegisterDelegate operation parameter
   */
  registerDelegate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const estimate = yield this.estimate(params, this.estimator.registerDelegate.bind(this.estimator));
      const source = yield this.signer.publicKeyHash();
      const operation = yield createRegisterDelegateOperation(Object.assign(Object.assign({}, params), estimate), source);
      const ops = yield this.addRevealOperationIfNeeded(operation, source);
      const prepared = yield this.prepareOperation({ operation: ops });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new DelegateOperation(hash3, operation, source, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param Transfer operation parameter
   */
  transfer(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateAddress(params.to) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.to);
      }
      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source);
      }
      const publickKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.transfer.bind(this.estimator));
      const operation = yield createTransferOperation(Object.assign(Object.assign({}, params), estimate));
      const source = params.source || publickKeyHash;
      const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new TransactionOperation(hash3, operation, source, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Transfer Tickets to a smart contract address
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param TransferTicketParams operation parameter
   */
  transferTicket(params) {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(params.destination) !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(params.destination);
      }
      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source);
      }
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.transferTicket.bind(this.estimator));
      const operation = yield createTransferTicketOperation(Object.assign(Object.assign({}, params), estimate));
      const source = (_a2 = params.source) !== null && _a2 !== void 0 ? _a2 : publicKeyHash;
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new TransferTicketOperation(hash3, operation, source, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Reveal the current address. Will throw an error if the address is already revealed.
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param RevealParams operation parameter
   */
  reveal(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimateReveal = yield this.estimator.reveal(params);
      if (estimateReveal) {
        const estimated = yield this.estimate(params, () => __awaiter$8(this, void 0, void 0, function* () {
          return estimateReveal;
        }));
        const operation = yield createRevealOperation(Object.assign({}, estimated), publicKeyHash, yield this.signer.publicKey());
        const prepared = yield this.prepareOperation({ operation, source: publicKeyHash });
        const opBytes = yield this.forge(prepared);
        const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
        return new RevealOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
      } else {
        throw new RevealOperationError(`The publicKeyHash '${publicKeyHash}' has already been revealed.`);
      }
    });
  }
  /**
   *
   * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param params registerGlobalConstant operation parameter
   */
  registerGlobalConstant(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publickKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.registerGlobalConstant.bind(this.estimator));
      const operation = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, params), estimate));
      const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: publickKeyHash });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new RegisterGlobalConstantOperation(hash3, operation, publickKeyHash, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Increase the paid storage of a smart contract
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param params increasePaidStorage operation parameter
   */
  increasePaidStorage(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.increasePaidStorage.bind(this.estimator));
      const operation = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, params), estimate));
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new IncreasePaidStorageOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Transfers the spendable balance of the delegate to destination when consensus_key is the active consensus key of delegate
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param params drainDelegate operation parameter
   */
  drainDelegate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const operation = yield createDrainDelegateOperation(Object.assign({}, params));
      const prepared = yield this.prepareOperation({ operation });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new DrainDelegateOperation(hash3, operation, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Originate a new tx rollup. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param TxRollupOriginateParams Originate rollup operation parameter
   */
  txRollupOriginate(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params ? params : {}, this.estimator.txRollupOriginate.bind(this.estimator));
      const operation = yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, params), estimate));
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new TxRollupOriginationOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Submit a tx rollup batch. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param TxRollupBatchParams Batch tx rollup operation parameter
   */
  txRollupSubmitBatch(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.txRollupSubmitBatch.bind(this.estimator));
      const operation = yield createTxRollupBatchOperation(Object.assign(Object.assign({}, params), estimate));
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new TxRollupBatchOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Submit a ballot vote to a specified proposal
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param BallotParams Ballot operation parameter
   */
  ballot(params) {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source);
      }
      const source = (_a2 = params.source) !== null && _a2 !== void 0 ? _a2 : publicKeyHash;
      const operation = yield createBallotOperation(Object.assign(Object.assign({}, params), { source }));
      const prepared = yield this.prepareOperation({ operation, source });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new BallotOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Submit or upvote a proposal during the Proposal period
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param BallotParams Proposals operation parameter
   */
  proposals(params) {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source);
      }
      const source = (_a2 = params.source) !== null && _a2 !== void 0 ? _a2 : publicKeyHash;
      const operation = yield createProposalsOperation(Object.assign(Object.assign({}, params), { source }));
      const prepared = yield this.prepareOperation({ operation, source });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new ProposalsOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
    });
  }
  /**
   *
   * @description Updates the consensus key of the baker to public_key starting from the current cycle plus PRESERVED_CYCLES + 1
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param UpdateConsensusKeyParams
   */
  updateConsensusKey(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.updateConsensusKey.bind(this.estimator));
      const operation = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, params), estimate));
      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
      const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
      const opBytes = yield this.forge(prepared);
      const { hash: hash3, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new UpdateConsensusKeyOperation(hash3, operation, publicKeyHash, forgedBytes, opResponse, context);
    });
  }
  at(address, contractAbstractionComposer = (x2) => x2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (validateContractAddress(address) !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(address);
      }
      const rpc = this.context.withExtensions().rpc;
      const readProvider = this.context.withExtensions().readProvider;
      const script = yield readProvider.getScript(address, "head");
      const entrypoints = yield readProvider.getEntrypoints(address);
      const abs = new ContractAbstraction(address, script, this, this, entrypoints, rpc, readProvider);
      return contractAbstractionComposer(abs, this.context);
    });
  }
  /**
   *
   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
   *
   * @returns A batch object from which we can add more operation or send a command to execute the batch
   *
   * @param params List of operation to batch together
   */
  batch(params) {
    const batch = new OperationBatch(this.context, this.estimator);
    if (Array.isArray(params)) {
      batch.with(params);
    }
    return batch;
  }
}
class MichelCodecParser {
  constructor(context) {
    this.context = context;
  }
  getNextProto() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.context.proto) {
        const nextProto = yield this.context.readProvider.getNextProtocol("head");
        this.context.proto = nextProto;
      }
      return this.context.proto;
    });
  }
  parseScript(src2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const parser = new Parser({ protocol: yield this.getNextProto() });
      return parser.parseScript(src2);
    });
  }
  parseMichelineExpression(src2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const parser = new Parser({ protocol: yield this.getNextProto() });
      return parser.parseMichelineExpression(src2);
    });
  }
  parseJSON(src2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const parser = new Parser({ protocol: yield this.getNextProto() });
      return parser.parseJSON(src2);
    });
  }
  prepareCodeOrigination(params) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const parsedParams = params;
      parsedParams.code = yield this.formatCodeParam(params.code);
      if (params.init) {
        parsedParams.init = yield this.formatInitParam(params.init);
      } else if (params.storage) {
        const storageType = parsedParams.code.find((p2) => "prim" in p2 && p2.prim === "storage");
        if (!(storageType === null || storageType === void 0 ? void 0 : storageType.args)) {
          throw new InvalidCodeParameter("The storage section is missing from the script", params.code);
        }
        const schema = new Schema(storageType.args[0]);
        const globalconstantsHashAndValue = yield this.findGlobalConstantsHashAndValue(schema);
        if (Object.keys(globalconstantsHashAndValue).length !== 0) {
          const p2 = new Parser({ expandGlobalConstant: globalconstantsHashAndValue });
          const storageTypeNoGlobalConst = p2.parseJSON(storageType.args[0]);
          const schemaNoGlobalConst = new Schema(storageTypeNoGlobalConst);
          parsedParams.init = schemaNoGlobalConst.Encode(params.storage);
        } else {
          parsedParams.init = schema.Encode(params.storage);
        }
        delete parsedParams.storage;
      }
      return parsedParams;
    });
  }
  formatCodeParam(code2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      let parsedCode;
      if (typeof code2 === "string") {
        const c2 = yield this.parseScript(code2);
        if (c2 === null) {
          throw new InvalidCodeParameter("Invalid code parameter", code2);
        }
        parsedCode = c2;
      } else {
        const c2 = yield this.parseJSON(code2);
        const order = ["parameter", "storage", "code"];
        parsedCode = c2.sort((a2, b2) => order.indexOf(a2.prim) - order.indexOf(b2.prim));
      }
      return parsedCode;
    });
  }
  formatInitParam(init5) {
    return __awaiter$8(this, void 0, void 0, function* () {
      let parsedInit;
      if (typeof init5 === "string") {
        const c2 = yield this.parseMichelineExpression(init5);
        if (c2 === null) {
          throw new InvalidInitParameter("Invalid init parameter", init5);
        }
        parsedInit = c2;
      } else {
        parsedInit = yield this.parseJSON(init5);
      }
      return parsedInit;
    });
  }
  findGlobalConstantsHashAndValue(schema) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const globalConstantTokens = schema.findToken("constant");
      const globalConstantsHashAndValue = {};
      if (globalConstantTokens.length !== 0) {
        for (const token of globalConstantTokens) {
          const tokenArgs = token.tokenVal.args;
          if (tokenArgs) {
            const expression = tokenArgs[0];
            if (expression.string) {
              const hash3 = expression.string;
              const michelineValue = yield this.context.globalConstantsProvider.getGlobalConstantByHash(hash3);
              Object.assign(globalConstantsHashAndValue, {
                [hash3]: michelineValue
              });
            }
          }
        }
      }
      return globalConstantsHashAndValue;
    });
  }
}
class RpcPacker {
  constructor(context) {
    this.context = context;
  }
  packData(data2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.context.rpc.packData(data2);
    });
  }
}
class UnconfiguredGlobalConstantsProviderError extends Error {
  constructor() {
    super("No global constants provider has been configured. Please configure one by calling setGlobalConstantsProvider({globalConstantsProvider}) on your TezosToolkit instance.");
    this.name = "UnconfiguredGlobalConstantsProviderError";
  }
}
class NoopGlobalConstantsProvider {
  getGlobalConstantByHash(_hash) {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new UnconfiguredGlobalConstantsProviderError();
    });
  }
}
class RpcReadAdapter {
  constructor(rpc) {
    this.rpc = rpc;
  }
  /**
   * @description Access the balance of a contract.
   * @param address address from which we want to retrieve the balance
   * @param block from which we want to retrieve the balance
   * @returns the balance in mutez
   */
  getBalance(address, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getBalance(address, { block: String(block) });
    });
  }
  /**
   * @description Access the delegate of a contract, if any.
   * @param address contract address from which we want to retrieve the delegate (baker)
   * @param block from which we want to retrieve the delegate
   * @returns the public key hash of the delegate or null if no delegate
   */
  getDelegate(address, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getDelegate(address, { block: String(block) });
    });
  }
  /**
   * @description Access the next protocol hash
   * @param block from which we want to retrieve the next protocol hash
   */
  getNextProtocol(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const protocols = yield this.rpc.getProtocols({ block: String(block) });
      return protocols.next_protocol;
    });
  }
  /**
   * @description Access protocol constants used in Taquito
   * @param block from which we want to retrieve the constants
   */
  getProtocolConstants(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { time_between_blocks, minimal_block_delay, hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, tx_rollup_origination_size } = yield this.rpc.getConstants({ block: String(block) });
      return {
        time_between_blocks,
        minimal_block_delay,
        hard_gas_limit_per_operation,
        hard_gas_limit_per_block,
        hard_storage_limit_per_operation,
        cost_per_byte,
        tx_rollup_origination_size
      };
    });
  }
  /**
   * @description Access the script (code and storage) of a smart contract
   * @param contract contract address from which we want to retrieve the script
   * @param block from which we want to retrieve the storage value
   * @returns Note: The code must be in the JSON format and not contain global constant
   */
  getScript(contract, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { script } = yield this.rpc.getContract(contract, { block: String(block) });
      return script;
    });
  }
  /**
   * @description Access the storage value of a contract
   * @param contract contract address from which we want to retrieve the storage
   * @param block from which we want to retrieve the storage value
   */
  getStorage(contract, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getStorage(contract, { block: String(block) });
    });
  }
  /**
   * @description Access the block hash
   */
  getBlockHash(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { hash: hash3 } = yield this.rpc.getBlockHeader({ block: String(block) });
      return hash3;
    });
  }
  /**
   * @description Access the block level
   */
  getBlockLevel(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { level } = yield this.rpc.getBlockHeader({ block: String(block) });
      return level;
    });
  }
  /**
   * @description Access the counter of an address
   * @param pkh from which we want to retrieve the counter
   * @param block from which we want to retrieve the counter
   */
  getCounter(pkh, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { counter } = yield this.rpc.getContract(pkh, { block: String(block) });
      return counter || "0";
    });
  }
  /**
   * @description Access the timestamp of a block
   * @param block from which we want to retrieve the timestamp
   * @returns date ISO format zero UTC offset ("2022-01-19T22:37:07Z")
   */
  getBlockTimestamp(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const { timestamp } = yield this.rpc.getBlockHeader({ block: String(block) });
      return timestamp;
    });
  }
  /**
   * @description Access the value associated with a key in a big map.
   * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)
   * @param block from which we want to retrieve the big map value
   */
  getBigMapValue(bigMapQuery, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {
        block: String(block)
      });
    });
  }
  /**
   * @description Access the value associated with a sapling state ID.
   * @param id Sapling state ID
   * @param block from which we want to retrieve the sapling state
   */
  getSaplingDiffById(saplingStateQuery, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getSaplingDiffById(saplingStateQuery.id, { block: String(block) });
    });
  }
  /**
   * @description Access the sapling state of a smart contract.
   * @param contractAddress The address of the smart contract
   * @param block The block you want to retrieve the sapling state from
   */
  getSaplingDiffByContract(contractAddress, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getSaplingDiffByContract(contractAddress, { block: String(block) });
    });
  }
  /**
   * @description Return the list of entrypoints of the contract
   * @param contract address of the contract we want to get the entrypoints of
   */
  getEntrypoints(contract) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getEntrypoints(contract);
    });
  }
  /**
   * @description Access the chain id
   */
  getChainId() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getChainId();
    });
  }
  /**
   * @description Indicate if an account is revealed
   * @param publicKeyHash of the account
   * @param block from which we want to know if the account is revealed
   */
  isAccountRevealed(publicKeyHash, block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const manager = yield this.rpc.getManagerKey(publicKeyHash, { block: String(block) });
      const haveManager = manager && typeof manager === "object" ? !!manager.key : !!manager;
      return haveManager;
    });
  }
  /**
   * @description Return all the information about a block
   * @param block from which we want to retrieve the information
   */
  getBlock(block) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.rpc.getBlock({ block: String(block) });
    });
  }
  /**
   * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
   * @param block from which we want to retrieve the information
   */
  getLiveBlocks(block) {
    return this.rpc.getLiveBlocks({ block: String(block) });
  }
}
const opHashFilter = (op, filter2) => op.hash === filter2.opHash;
const sourceFilter = (x2, filter2) => {
  switch (x2.kind) {
    case "endorsement":
      return "metadata" in x2 && x2.metadata.delegate === filter2.source;
    case "activate_account":
      return "metadata" in x2 && x2.pkh === filter2.source;
    default:
      return "source" in x2 && x2.source === filter2.source;
  }
};
const kindFilter = (x2, filter2) => "kind" in x2 && x2.kind === filter2.kind;
const destinationFilter = (x2, filter2) => {
  switch (x2.kind) {
    case "delegation":
      return x2.delegate === filter2.destination;
    case "origination":
      if ("metadata" in x2 && "operation_result" in x2.metadata && "originated_contracts" in x2.metadata.operation_result && Array.isArray(x2.metadata.operation_result.originated_contracts)) {
        return x2.metadata.operation_result.originated_contracts.some((contract) => contract === filter2.destination);
      }
      break;
    case "transaction":
      return x2.destination === filter2.destination;
    default:
      return false;
  }
};
const eventFilter = (result, address, tag) => {
  if (result.kind === "event") {
    if (address && tag) {
      return result.source === address && result.tag === tag;
    } else if (address && !tag) {
      return result.source === address;
    } else if (tag) {
      return result.tag === tag;
    } else {
      return true;
    }
  } else {
    return false;
  }
};
const evaluateOpFilter = (op, filter2) => {
  if ("opHash" in filter2) {
    return opHashFilter(op, filter2);
  } else if ("source" in filter2) {
    return sourceFilter(op, filter2);
  } else if ("kind" in filter2) {
    return kindFilter(op, filter2);
  } else if ("destination" in filter2) {
    return destinationFilter(op, filter2);
  }
  return false;
};
const evaluateExpression = (op, exp) => {
  if (Array.isArray(exp.and)) {
    return exp.and.every((x2) => evaluateFilter(op, x2));
  } else if (Array.isArray(exp.or)) {
    return exp.or.some((x2) => evaluateFilter(op, x2));
  } else {
    throw new InvalidFilterExpressionError("Filter expression must contain either and/or property");
  }
};
const evaluateFilter = (op, filter2) => {
  const filters = [];
  if (!Array.isArray(filter2)) {
    filters.push(filter2);
  } else {
    filters.push(...filter2);
  }
  return filters.every((filterOrExp) => {
    if ("and" in filterOrExp || "or" in filterOrExp) {
      return evaluateExpression(op, filterOrExp);
    } else {
      return evaluateOpFilter(op, filterOrExp);
    }
  });
};
class UnsupportedEventError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "UnsupportedEventError";
  }
}
class ObservableSubscription {
  constructor(obs, shouldRetry = false, operatorFunction = retry()) {
    this.shouldRetry = shouldRetry;
    this.operatorFunction = operatorFunction;
    this.errorListeners = [];
    this.messageListeners = [];
    this.closeListeners = [];
    this.completed$ = new Subject();
    obs.pipe(takeUntil(this.completed$), tap((data2) => {
      this.call(this.messageListeners, data2);
    }, (error) => {
      this.call(this.errorListeners, error);
    }, () => {
      this.call(this.closeListeners);
    }), this.shouldRetry ? operatorFunction : tap(), catchError(() => NEVER)).subscribe();
  }
  call(listeners2, value) {
    for (const l2 of listeners2) {
      try {
        l2(value);
      } catch (ex) {
        console.error(ex);
      }
    }
  }
  remove(listeners2, value) {
    const idx = listeners2.indexOf(value);
    if (idx !== -1) {
      listeners2.splice(idx, 1);
    }
  }
  on(type, cb) {
    switch (type) {
      case "data":
        this.messageListeners.push(cb);
        break;
      case "error":
        this.errorListeners.push(cb);
        break;
      case "close":
        this.closeListeners.push(cb);
        break;
      default:
        throw new UnsupportedEventError(`Trying to register on an unsupported event: ${type}`);
    }
  }
  off(type, cb) {
    switch (type) {
      case "data":
        this.remove(this.messageListeners, cb);
        break;
      case "error":
        this.remove(this.errorListeners, cb);
        break;
      case "close":
        this.remove(this.closeListeners, cb);
        break;
      default:
        throw new UnsupportedEventError(`Trying to unregister on an unsupported event: ${type}`);
    }
  }
  close() {
    this.completed$.next();
  }
}
const defaultConfigStreamer = {
  shouldObservableSubscriptionRetry: false,
  observableSubscriptionRetryFunction: retry()
};
const getLastBlock = (context) => {
  return from(context.rpc.getBlock()).pipe(first());
};
const applyFilter = (filter2) => concatMap((block) => {
  return new Observable((sub) => {
    for (const ops of block.operations) {
      for (const op of ops) {
        for (const content of op.contents) {
          if (evaluateFilter(Object.assign({ hash: op.hash }, content), filter2)) {
            sub.next(Object.assign({ hash: op.hash }, content));
          }
        }
      }
    }
    sub.complete();
  });
});
const applyEventFilter = (filter2) => concatMap((block) => {
  return new Observable((sub) => {
    for (const ops of block.operations) {
      for (const op of ops) {
        for (const content of op.contents) {
          const tx = content;
          const internalOpResults = tx.metadata.internal_operation_results;
          if (internalOpResults) {
            for (const event of internalOpResults) {
              if (eventFilter(event, filter2 === null || filter2 === void 0 ? void 0 : filter2.address, filter2 === null || filter2 === void 0 ? void 0 : filter2.tag)) {
                sub.next(Object.assign({ opHash: op.hash, blockHash: block.hash, level: block.header.level }, event));
              }
            }
          }
        }
      }
    }
    sub.complete();
  });
});
class PollingSubscribeProvider {
  constructor(context, config2 = {}) {
    this.context = context;
    this._config$ = new BehaviorSubject(Object.assign(Object.assign({}, defaultConfigStreamer), config2));
    this.timer$ = this._config$.pipe(pluck("pollingIntervalMilliseconds"), switchMap((pollingIntervalMilliseconds) => {
      if (!pollingIntervalMilliseconds) {
        return from(this.getConfirmationPollingInterval()).pipe(switchMap((interval) => {
          return timer(0, interval);
        }));
      } else {
        return timer(0, pollingIntervalMilliseconds);
      }
    }));
    this.newBlock$ = this.timer$.pipe(switchMap(() => getLastBlock(this.context)), distinctUntilKeyChanged("hash"), publish(), refCount());
  }
  get config() {
    return this._config$.getValue();
  }
  getConfirmationPollingInterval() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.config.pollingIntervalMilliseconds) {
        const defaultIntervalTestnetsMainnet = 5e3;
        const defaultIntervalSandbox = 1e3;
        try {
          const constants = yield this.context.readProvider.getProtocolConstants("head");
          const blockTime = constants.minimal_block_delay ? constants.minimal_block_delay.multipliedBy(1e3) : constants.time_between_blocks ? constants.time_between_blocks[0].multipliedBy(1e3) : new BigNumber$1(defaultIntervalTestnetsMainnet);
          const confirmationPollingInterval = blockTime.dividedBy(3);
          this.config.pollingIntervalMilliseconds = confirmationPollingInterval.toNumber() === 0 ? defaultIntervalSandbox : confirmationPollingInterval.toNumber();
        } catch (exception) {
          return defaultIntervalTestnetsMainnet;
        }
      }
      return this.config.pollingIntervalMilliseconds;
    });
  }
  subscribeBlock(_filter) {
    return new ObservableSubscription(this.newBlock$, this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
  subscribe(_filter) {
    return new ObservableSubscription(this.newBlock$.pipe(pluck("hash")), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
  subscribeOperation(filter2) {
    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter2)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
  subscribeEvent(eventFilter2) {
    return new ObservableSubscription(this.newBlock$.pipe(applyEventFilter(eventFilter2)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
}
class TaquitoLocalForger {
  constructor(context) {
    this.context = context;
  }
  getNextProto() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.context.proto) {
        const nextProto = yield this.context.readProvider.getNextProtocol("head");
        this.context.proto = nextProto;
      }
      return this.context.proto;
    });
  }
  forge({ branch, contents }) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const forger = new LocalForger(yield this.getNextProto());
      return forger.forge({ branch, contents });
    });
  }
}
const defaultConfigConfirmation = {
  defaultConfirmationCount: 1,
  confirmationPollingTimeoutSecond: 180
};
class Context {
  constructor(_rpc, _signer = new NoopSigner(), _proto, _config = new BehaviorSubject(Object.assign({}, defaultConfigConfirmation)), forger, injector, packer, wallet, parser, globalConstantsProvider, readProvider, stream) {
    this._rpc = _rpc;
    this._signer = _signer;
    this._proto = _proto;
    this._config = _config;
    this.providerDecorator = [];
    this.tz = new RpcTzProvider(this);
    this.estimate = new RPCEstimateProvider(this);
    this.contract = new RpcContractProvider(this, this.estimate);
    this.batch = new RPCBatchProvider(this, this.estimate);
    this.wallet = new Wallet(this);
    this.withExtensions = () => {
      let clonedContext = this.clone();
      this.providerDecorator.forEach((decorator) => {
        clonedContext = decorator(clonedContext);
      });
      return clonedContext;
    };
    if (typeof this._rpc === "string") {
      this._rpcClient = new RpcClient(this._rpc);
    } else {
      this._rpcClient = this._rpc;
    }
    this._forger = forger ? forger : new TaquitoLocalForger(this);
    this._injector = injector ? injector : new RpcInjector(this);
    this.operationFactory = new OperationFactory(this);
    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);
    this._parser = parser ? parser : new MichelCodecParser(this);
    this._packer = packer ? packer : new RpcPacker(this);
    this._globalConstantsProvider = globalConstantsProvider ? globalConstantsProvider : new NoopGlobalConstantsProvider();
    this._readProvider = readProvider ? readProvider : new RpcReadAdapter(this._rpcClient);
    this._stream = stream ? stream : new PollingSubscribeProvider(this);
  }
  get config() {
    return this._config.getValue();
  }
  set config(value) {
    this._config.next(Object.assign({}, value));
  }
  setPartialConfig(value) {
    this._config.next(Object.assign(Object.assign({}, this._config.getValue()), value));
  }
  get rpc() {
    return this._rpcClient;
  }
  set rpc(value) {
    this._rpcClient = value;
  }
  get injector() {
    return this._injector;
  }
  set injector(value) {
    this._injector = value;
  }
  get forger() {
    return this._forger;
  }
  set forger(value) {
    this._forger = value;
  }
  get signer() {
    return this._signer;
  }
  set signer(value) {
    this._signer = value;
  }
  get walletProvider() {
    return this._walletProvider;
  }
  set walletProvider(value) {
    this._walletProvider = value;
  }
  set proto(value) {
    this._proto = value;
  }
  get proto() {
    return this._proto;
  }
  get parser() {
    return this._parser;
  }
  set parser(value) {
    this._parser = value;
  }
  get packer() {
    return this._packer;
  }
  set packer(value) {
    this._packer = value;
  }
  get globalConstantsProvider() {
    return this._globalConstantsProvider;
  }
  set globalConstantsProvider(value) {
    this._globalConstantsProvider = value;
  }
  get readProvider() {
    return this._readProvider;
  }
  set readProvider(value) {
    this._readProvider = value;
  }
  get stream() {
    return this._stream;
  }
  set stream(value) {
    this._stream = value;
  }
  isAnyProtocolActive(protocol = []) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (this._proto) {
        return protocol.includes(this._proto);
      } else {
        const next_protocol = yield this.readProvider.getNextProtocol("head");
        return protocol.includes(next_protocol);
      }
    });
  }
  isAnySignerConfigured() {
    return !(this.signer instanceof NoopSigner);
  }
  /**
   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation
   */
  clone() {
    return new Context(this.rpc, this.signer, this.proto, this._config, this.forger, this._injector, this.packer, this._walletProvider, this._parser, this._globalConstantsProvider, this._readProvider, this._stream);
  }
  /**
   * @description Allows extensions set on the TezosToolkit to inject logic into the context
   */
  registerProviderDecorator(fx) {
    this.providerDecorator.push(fx);
  }
}
const VERSION = {
  "commitHash": "6182616eaed81e655f9af9477d5f0078782a817b",
  "version": "15.0.1"
};
class TezosToolkit {
  constructor(_rpc) {
    this._rpc = _rpc;
    this._options = {};
    this.format = format;
    if (typeof this._rpc === "string") {
      this._rpcClient = new RpcClient(this._rpc);
    } else {
      this._rpcClient = this._rpc;
    }
    this._context = new Context(_rpc);
    this._wallet = new Wallet(this._context);
    this.setProvider({ rpc: this._rpcClient });
    this.batch = this._context.batch.batch.bind(this._context.batch);
  }
  /**
   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth
   *
   * @param options rpc url or rpcClient to use to interact with the Tezos network
   *
   * @example Tezos.setProvider({rpc: 'https://mainnet.api.tez.ie/', signer: new InMemorySigner.fromSecretKey(edsk...)})
   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})
   *
   */
  setProvider({ rpc, stream, signer, protocol, config: config2, forger, wallet, packer, globalConstantsProvider, readProvider, parserProvider }) {
    this.setRpcProvider(rpc);
    this.setStreamProvider(stream);
    this.setSignerProvider(signer);
    this.setForgerProvider(forger);
    this.setWalletProvider(wallet);
    this.setPackerProvider(packer);
    this.setGlobalConstantsProvider(globalConstantsProvider);
    this.setReadProvider(readProvider);
    this.setParserProvider(parserProvider);
    this._context.proto = protocol;
    if (config2) {
      this._context.setPartialConfig(config2);
    }
  }
  /**
   * @description Sets signer provider on the Tezos Taquito instance.
   *
   * @param options signer to use to interact with the Tezos network
   *
   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))
   *
   */
  setSignerProvider(signer) {
    if (!this._options.signer && typeof signer === "undefined") {
      this._context.signer = new NoopSigner();
      this._options.signer = signer;
    } else if (typeof signer !== "undefined") {
      this._context.signer = signer;
      this._options.signer = signer;
    }
  }
  /**
   * @description Sets rpc provider on the Tezos Taquito instance
   *
   * @param options rpc url or rpcClient to use to interact with the Tezos network
   *
   * @example Tezos.setRpcProvider('https://mainnet.api.tez.ie/')
   *
   */
  setRpcProvider(rpc) {
    if (typeof rpc === "string") {
      this._rpcClient = new RpcClient(rpc);
    } else if (rpc === void 0)
      ;
    else {
      this._rpcClient = rpc;
    }
    this._options.rpc = this._rpcClient;
    this._context.rpc = this._rpcClient;
  }
  /**
   * @description Sets forger provider on the Tezos Taquito instance
   * The `LocalForger` from `@taquito/local-forging` is set by default.
   *
   * @param options forger to use to interact with the Tezos network
   *
   * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())
   *
   */
  setForgerProvider(forger) {
    if (typeof forger !== "undefined") {
      this._options.forger = forger;
      this._context.forger = forger;
    } else if (this._options.forger === void 0) {
      const f2 = this.getFactory(TaquitoLocalForger)();
      this._options.forger = f2;
      this._context.forger = f2;
    }
  }
  /**
   * @description Sets stream provider on the Tezos Taquito instance
   *
   * @param options stream to use to interact with the Tezos network
   *
   * @example Tezos.setStreamProvider(...)
   *
   */
  setStreamProvider(stream) {
    if (typeof stream === "string") {
      const s2 = new PollingSubscribeProvider(new Context(new RpcClient(stream)));
      this._options.stream = s2;
      this._context.stream = s2;
    } else if (typeof stream !== "undefined") {
      this._options.stream = stream;
      this._context.stream = stream;
    } else if (this._options.stream === void 0) {
      const s2 = this.getFactory(PollingSubscribeProvider)();
      this._options.stream = s2;
      this._context.stream = s2;
    }
  }
  /**
   * @description Sets wallet provider on the Tezos Taquito instance
   *
   * @param options wallet to use to interact with the Tezos network
   *
   * @example Tezos.setWalletProvider(...)
   *
   */
  setWalletProvider(wallet) {
    if (!this._options.wallet && typeof wallet === "undefined") {
      const w2 = this.getFactory(LegacyWalletProvider)();
      this._options.wallet = w2;
      this._context.walletProvider = w2;
    } else if (typeof wallet !== "undefined") {
      this._options.wallet = wallet;
      this._context.walletProvider = wallet;
    }
  }
  /**
   * @description Sets Packer provider on the Tezos Taquito instance
   *
   * @param options packer to use to interact with the Tezos network
   *
   * @example Tezos.setPackerProvider(new MichelCodecPacker())
   *
   */
  setPackerProvider(packer) {
    if (!this._options.packer && typeof packer === "undefined") {
      const p2 = this.getFactory(RpcPacker)();
      this._context.packer = p2;
      this._options.packer = p2;
    } else if (typeof packer !== "undefined") {
      this._context.packer = packer;
      this._options.packer = packer;
    }
  }
  /**
   * @description Sets global constants provider on the Tezos Taquito instance
   *
   * @param options globalConstantsProvider to use to interact with the Tezos network
   *
   * @example
   * ```
   * const globalConst = new DefaultGlobalConstantsProvider();
   * globalConst.loadGlobalConstant({
   *  "expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre": { prim: "int" },
   *  // ...
   * })
   * Tezos.setGlobalConstantsProvider(globalConst);
   * ```
   *
   */
  setGlobalConstantsProvider(globalConstantsProvider) {
    if (!this._options.globalConstantsProvider && typeof globalConstantsProvider === "undefined") {
      const g2 = new NoopGlobalConstantsProvider();
      this._context.globalConstantsProvider = g2;
      this._options.globalConstantsProvider = g2;
    } else if (typeof globalConstantsProvider !== "undefined") {
      this._context.globalConstantsProvider = globalConstantsProvider;
      this._options.globalConstantsProvider = globalConstantsProvider;
    }
  }
  /**
   * @description Sets read provider on the Tezos Taquito instance
   * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface
   *
   * @param options TzReadProvider to use to interact with the Tezos network
   *
   */
  setReadProvider(readProvider) {
    const readP = readProvider ? readProvider : new RpcReadAdapter(this._context.rpc);
    this._options.readProvider = readP;
    this._context.readProvider = readP;
  }
  /**
   * @description Sets parser provider on the Tezos Taquito instance
   *
   * @param options parserProvider to use to interact with the Tezos network
   *
   */
  setParserProvider(parserProvider) {
    if (!this._options.parserProvider && typeof parserProvider === "undefined") {
      const p2 = new MichelCodecParser(this._context);
      this._context.parser = p2;
      this._options.parserProvider = p2;
    } else if (typeof parserProvider !== "undefined") {
      this._context.parser = parserProvider;
      this._options.parserProvider = parserProvider;
    }
  }
  /**
   * @description Provide access to tezos account management
   */
  get tz() {
    return this._context.tz;
  }
  /**
   * @description Provide access to smart contract utilities
   */
  get contract() {
    return this._context.contract;
  }
  get wallet() {
    return this._wallet;
  }
  get operation() {
    return this._context.operationFactory;
  }
  /**
   * @description Provide access to operation estimation utilities
   */
  get estimate() {
    return this._context.estimate;
  }
  /**
   * @description Provide access to streaming utilities backed by an streamer implementation
   */
  get stream() {
    return this._context.stream;
  }
  /**
   * @description Provide access to the currently used rpc client
   */
  get rpc() {
    return this._context.rpc;
  }
  /**
   * @description Provide access to the currently used signer
   */
  get signer() {
    return this._context.signer;
  }
  /**
   * @description Provide access to the currently used globalConstantsProvider
   */
  get globalConstants() {
    return this._context.globalConstantsProvider;
  }
  /**
   * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.
   *
   * @param module extension to add to the TezosToolkit instance
   *
   * @example Tezos.addExtension(new Tzip16Module());
   */
  addExtension(module) {
    if (Array.isArray(module)) {
      module.forEach((extension) => extension.configureContext(this._context));
    } else {
      module.configureContext(this._context);
    }
  }
  getFactory(ctor) {
    return (...args) => {
      return new ctor(this._context, ...args);
    };
  }
  /**
   * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from
   */
  getVersionInfo() {
    return VERSION;
  }
}
let nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id2, byte) => {
  byte &= 63;
  if (byte < 36) {
    id2 += byte.toString(36);
  } else if (byte < 62) {
    id2 += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id2 += "-";
  } else {
    id2 += "_";
  }
  return id2;
}, "");
var s, a, u;
function c() {
  return c = Object.assign || function(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = arguments[r2];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    }
    return e;
  }, c.apply(this, arguments);
}
function m(e, r2) {
  e.prototype = Object.create(r2.prototype), e.prototype.constructor = e, l(e, r2);
}
function l(e, r2) {
  return l = Object.setPrototypeOf || function(e2, r3) {
    return e2.__proto__ = r3, e2;
  }, l(e, r2);
}
function p(e, r2) {
  if (null == e)
    return {};
  var t, n, o = {}, i2 = Object.keys(e);
  for (n = 0; n < i2.length; n++)
    r2.indexOf(t = i2[n]) >= 0 || (o[t] = e[t]);
  return o;
}
!function(e) {
  e.GetCurrentPermissionRequest = "GET_CURRENT_PERMISSION_REQUEST", e.GetCurrentPermissionResponse = "GET_CURRENT_PERMISSION_RESPONSE", e.PermissionRequest = "PERMISSION_REQUEST", e.PermissionResponse = "PERMISSION_RESPONSE", e.OperationRequest = "OPERATION_REQUEST", e.OperationResponse = "OPERATION_RESPONSE", e.SignRequest = "SIGN_REQUEST", e.SignResponse = "SIGN_RESPONSE", e.BroadcastRequest = "BROADCAST_REQUEST", e.BroadcastResponse = "BROADCAST_RESPONSE";
}(s || (s = {})), function(e) {
  e.NotGranted = "NOT_GRANTED", e.NotFound = "NOT_FOUND", e.InvalidParams = "INVALID_PARAMS", e.TezosOperation = "TEZOS_OPERATION";
}(a || (a = {})), function(e) {
  e.Request = "TEMPLE_PAGE_REQUEST", e.Response = "TEMPLE_PAGE_RESPONSE", e.ErrorResponse = "TEMPLE_PAGE_ERROR_RESPONSE";
}(u || (u = {}));
var f = function(e) {
  try {
    return Promise.resolve(R({ type: s.BroadcastRequest, signedOpBytes: e })).then(function(e2) {
      return O(e2.type === s.BroadcastResponse), e2.opHash;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
}, P = function(e, r2) {
  try {
    return Promise.resolve(R({ type: s.SignRequest, sourcePkh: e, payload: r2 })).then(function(e2) {
      return O(e2.type === s.SignResponse), e2.signature;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
}, h = function(e, r2) {
  try {
    return Promise.resolve(R({ type: s.OperationRequest, sourcePkh: e, opParams: r2 })).then(function(e2) {
      return O(e2.type === s.OperationResponse), e2.opHash;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
}, v = function(e, r2, t) {
  try {
    return Promise.resolve(R({ type: s.PermissionRequest, network: e, appMeta: r2, force: t })).then(function(e2) {
      return O(e2.type === s.PermissionResponse), { rpc: e2.rpc, pkh: e2.pkh, publicKey: e2.publicKey };
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
}, d = function() {
  try {
    return Promise.resolve(R({ type: s.GetCurrentPermissionRequest })).then(function(e) {
      return O(e.type === s.GetCurrentPermissionResponse), e.permission;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
function y() {
  return new Promise(function(e) {
    var r2 = function(e2) {
      var r3, n2;
      e2.source === window && (null === (r3 = e2.data) || void 0 === r3 ? void 0 : r3.type) === u.Response && "PONG" === (null === (n2 = e2.data) || void 0 === n2 ? void 0 : n2.payload) && t(true);
    }, t = function(t2) {
      e(t2), window.removeEventListener("message", r2), clearTimeout(n);
    };
    _({ type: u.Request, payload: "PING" }), window.addEventListener("message", r2);
    var n = setTimeout(function() {
      return t(false);
    }, 500);
  });
}
function g(e) {
  var r2, t = false;
  return function n(o) {
    void 0 === o && (o = 0);
    try {
      var i2 = o < 5;
      return Promise.resolve(y()).then(function(s2) {
        t !== s2 && (e(s2), t = s2), r2 = setTimeout(n, s2 ? 1e4 : i2 ? 0 : 5e3, i2 ? o + 1 : o);
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  }(), function() {
    return clearTimeout(r2);
  };
}
function E(e) {
  var r2, t = null;
  return function n() {
    try {
      var o = function() {
        r2 = setTimeout(n, 1e4);
      }, i2 = function(r3, n2) {
        try {
          var o2 = Promise.resolve(d()).then(function(r4) {
            var n3, o3;
            o3 = t, (null === (n3 = r4) ? null === o3 : n3.pkh === (null == o3 ? void 0 : o3.pkh) && n3.rpc === (null == o3 ? void 0 : o3.rpc)) || (e(r4), t = r4);
          });
        } catch (e2) {
          return;
        }
        return o2 && o2.then ? o2.then(void 0, function() {
        }) : o2;
      }();
      return Promise.resolve(i2 && i2.then ? i2.then(o) : o());
    } catch (e2) {
      return Promise.reject(e2);
    }
  }(), function() {
    return clearTimeout(r2);
  };
}
function R(t) {
  return new Promise(function(n, o) {
    var i2 = nanoid();
    _({ type: u.Request, payload: t, reqId: i2 }), window.addEventListener("message", function e(t2) {
      var s2 = t2.data;
      switch (true) {
        case (t2.source !== window || (null == s2 ? void 0 : s2.reqId) !== i2):
          return;
        case (null == s2 ? void 0 : s2.type) === u.Response:
          n(s2.payload), window.removeEventListener("message", e);
          break;
        case (null == s2 ? void 0 : s2.type) === u.ErrorResponse:
          o(function(e2) {
            switch (true) {
              case e2 === a.NotGranted:
                return new T();
              case e2 === a.NotFound:
                return new w();
              case e2 === a.InvalidParams:
                return new N();
              case (Array.isArray(e2) && e2[0] === a.TezosOperation && Array.isArray(e2[1]) && e2[1].length > 0):
                return new TezosOperationError(e2[1]);
              case ("string" == typeof e2 && e2.startsWith("__tezos__")):
                return new Error(e2.replace("__tezos__", ""));
              default:
                return new S();
            }
          }(s2.payload)), window.removeEventListener("message", e);
      }
    });
  });
}
function O(e) {
  if (!e)
    throw new Error("Invalid response recieved");
}
function _(e) {
  window.postMessage(e, "*");
}
var S = function() {
  this.name = "TempleWalletError", this.message = "An unknown error occured. Please try again or report it";
}, T = /* @__PURE__ */ function(e) {
  function r2() {
    for (var r3, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
      n[o] = arguments[o];
    return (r3 = e.call.apply(e, [this].concat(n)) || this).name = "NotGrantedTempleWalletError", r3.message = "Permission Not Granted", r3;
  }
  return m(r2, e), r2;
}(S), w = /* @__PURE__ */ function(e) {
  function r2() {
    for (var r3, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
      n[o] = arguments[o];
    return (r3 = e.call.apply(e, [this].concat(n)) || this).name = "NotFoundTempleWalletError", r3.message = "Account Not Found. Try connect again", r3;
  }
  return m(r2, e), r2;
}(S), N = /* @__PURE__ */ function(e) {
  function r2() {
    for (var r3, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
      n[o] = arguments[o];
    return (r3 = e.call.apply(e, [this].concat(n)) || this).name = "InvalidParamsTempleWalletError", r3.message = "Some of the parameters you provided are invalid", r3;
  }
  return m(r2, e), r2;
}(S), A = ["fee", "gas_limit", "storage_limit"], L = ["destination", "amount", "parameters"], I = /* @__PURE__ */ function() {
  function e(e2, r3) {
    this.appName = void 0, this.permission = null, this.appName = e2, r3 && (this.permission = r3);
  }
  var r2, s2 = e.prototype;
  return s2.toTezos = function() {
    G(this.permission);
    var e2 = new TezosToolkit(this.permission.rpc);
    return e2.setProvider({ wallet: this }), e2;
  }, s2.connect = function(e2, r3) {
    void 0 === r3 && (r3 = { forcePermission: false });
    try {
      var t = this;
      return Promise.resolve(v(e2, { name: t.appName }, r3.forcePermission)).then(function(e3) {
        t.permission = e3;
      });
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.reconnect = function(e2) {
    return this.connect(e2, { forcePermission: true });
  }, s2.getPKH = function() {
    try {
      return G(this.permission), Promise.resolve(this.permission.pkh);
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, s2.mapTransferParamsToWalletParams = function(e2) {
    try {
      var r3 = this;
      return Promise.resolve(e2()).then(function(e3) {
        var t = r3.removeDefaultParams;
        return Promise.resolve(createTransferOperation(r3.formatParameters(e3))).then(function(n) {
          return t.call(r3, e3, n);
        });
      });
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.mapOriginateParamsToWalletParams = function(e2) {
    try {
      var r3 = this;
      return Promise.resolve(e2()).then(function(e3) {
        var t = r3.removeDefaultParams;
        return Promise.resolve(createOriginationOperation(r3.formatParameters(e3))).then(function(n) {
          return t.call(r3, e3, n);
        });
      });
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.mapDelegateParamsToWalletParams = function(e2) {
    try {
      var r3 = this;
      return Promise.resolve(e2()).then(function(e3) {
        var t = r3.removeDefaultParams;
        return Promise.resolve(createSetDelegateOperation(r3.formatParameters(e3))).then(function(n) {
          return t.call(r3, e3, n);
        });
      });
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.sendOperations = function(e2) {
    try {
      return G(this.permission), Promise.resolve(h(this.permission.pkh, e2.map(b)));
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.sign = function(e2) {
    try {
      return G(this.permission), Promise.resolve(P(this.permission.pkh, e2));
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.broadcast = function(e2) {
    try {
      return G(this.permission), Promise.resolve(f(e2));
    } catch (e3) {
      return Promise.reject(e3);
    }
  }, s2.formatParameters = function(e2) {
    return e2.fee && (e2.fee = e2.fee.toString()), e2.storageLimit && (e2.storageLimit = e2.storageLimit.toString()), e2.gasLimit && (e2.gasLimit = e2.gasLimit.toString()), e2;
  }, s2.removeDefaultParams = function(e2, r3) {
    return e2.fee || delete r3.fee, e2.storageLimit || delete r3.storage_limit, e2.gasLimit || delete r3.gas_limit, r3;
  }, (r2 = [{ key: "connected", get: function() {
    return Boolean(this.permission);
  } }]) && function(e2, r3) {
    for (var t = 0; t < r3.length; t++) {
      var n = r3[t];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e2, n.key, n);
    }
  }(e.prototype, r2), e;
}();
I.isAvailable = y, I.onAvailabilityChange = g, I.getCurrentPermission = d, I.onPermissionChange = E;
var j = /* @__PURE__ */ function(e) {
  function r2() {
    for (var r3, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
      n[o] = arguments[o];
    return (r3 = e.call.apply(e, [this].concat(n)) || this).name = "TempleWalletNotConnected", r3.message = "You need to connect TempleWallet by calling templeWallet.connect() first", r3;
  }
  return m(r2, e), r2;
}(S);
function G(e) {
  if (!e)
    throw new j();
}
function b(e) {
  var r2 = e.fee, t = e.gas_limit, n = e.storage_limit, o = p(e, A);
  switch (e.kind) {
    case "origination":
      return c({}, o, { mutez: true, fee: r2, gasLimit: t, storageLimit: n });
    case "transaction":
      var i2 = o.destination, s2 = o.amount, a2 = o.parameters;
      return c({}, p(o, L), { to: i2, amount: +s2, mutez: true, parameter: a2, fee: r2, gasLimit: t, storageLimit: n });
    default:
      return c({}, o, { fee: r2, gasLimit: t, storageLimit: n });
  }
}
class ReadOnlySigner {
  constructor(pkh, pk) {
    this.pkh = pkh;
    this.pk = pk;
  }
  async publicKey() {
    return this.pk;
  }
  async publicKeyHash() {
    return this.pkh;
  }
  async sign() {
    throw new Error("Cannot sign");
  }
  async secretKey() {
    throw new Error("Secret key cannot be exposed");
  }
}
class TempleWallet extends Wallet$1 {
  constructor() {
    super();
    I.isAvailable().then((isAvailable) => {
      if (!isAvailable) {
        this.available = false;
      } else {
        this.available = true;
        this.wallet = new I("Bifrost bridge");
      }
    });
  }
  async connectInjected() {
    if (!this.available)
      throw new Error("Temple Wallet not installed");
    if (this.wallet.connected) {
      return;
    }
    await this.wallet.connect("kathmandunet", {
      forcePermission: true
    });
    this.address = this.wallet.pkh || await this.wallet.getPKH();
    const { pkh, publicKey } = this.wallet.permission;
    let url = "https://kathmandunet.ecadinfra.com";
    const tzs = new TezosToolkit(url);
    tzs.setWalletProvider(this.wallet);
    tzs.setSignerProvider(new ReadOnlySigner(pkh, publicKey));
    return this.address;
  }
  async connectExternal(cb) {
    throw new Error("External Temple Wallet is not supported.");
  }
  async lockCoins(destAddress, destCoinId, amount) {
  }
  async burnTokens(token, amount) {
  }
}
class TonConnectError extends Error {
  constructor(message, options) {
    if (message) {
      message = TonConnectError.prefix + " " + message;
    }
    super(message, options);
    Object.setPrototypeOf(this, TonConnectError.prototype);
  }
}
TonConnectError.prefix = "[TON_CONNECT_SDK_ERROR]";
class DappMetadataError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, DappMetadataError.prototype);
  }
}
class ManifestContentErrorError extends TonConnectError {
  constructor(message) {
    super(message || "" + ManifestContentErrorError.additionalMessage);
    Object.setPrototypeOf(this, ManifestContentErrorError.prototype);
  }
}
ManifestContentErrorError.additionalMessage = "\nPassed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
class ManifestNotFoundError extends TonConnectError {
  constructor(message) {
    super(message || "" + ManifestNotFoundError.additionalMessage);
    Object.setPrototypeOf(this, ManifestNotFoundError.prototype);
  }
}
ManifestNotFoundError.additionalMessage = "\nManifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
class WalletAlreadyConnectedError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype);
  }
}
class WalletNotConnectedError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, WalletNotConnectedError.prototype);
  }
}
class WalletNotSupportFeatureError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype);
  }
}
function isWalletConnectionSourceJS(value) {
  return "jsBridgeKey" in value;
}
class UserRejectsError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, UserRejectsError.prototype);
  }
}
class BadRequestError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, BadRequestError.prototype);
  }
}
class UnknownAppError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, UnknownAppError.prototype);
  }
}
class WalletNotInjectedError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, WalletNotInjectedError.prototype);
  }
}
class LocalstorageNotFoundError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, LocalstorageNotFoundError.prototype);
  }
}
class FetchWalletsError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, FetchWalletsError.prototype);
  }
}
class UnknownError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, UnknownError.prototype);
  }
}
var CONNECT_EVENT_ERROR_CODES;
(function(CONNECT_EVENT_ERROR_CODES2) {
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES2) {
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(SEND_TRANSACTION_ERROR_CODES2) {
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["MAINNET"] = "-239";
  CHAIN2["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));
var naclUtilExports = {};
var naclUtil = {
  get exports() {
    return naclUtilExports;
  },
  set exports(v2) {
    naclUtilExports = v2;
  }
};
(function(module) {
  (function(root, f2) {
    if (module.exports)
      module.exports = f2();
    else if (root.nacl)
      root.nacl.util = f2();
    else {
      root.nacl = {};
      root.nacl.util = f2();
    }
  })(commonjsGlobal, function() {
    var util2 = {};
    function validateBase64(s2) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
        throw new TypeError("invalid encoding");
      }
    }
    util2.decodeUTF8 = function(s2) {
      if (typeof s2 !== "string")
        throw new TypeError("expected string");
      var i2, d2 = unescape(encodeURIComponent(s2)), b2 = new Uint8Array(d2.length);
      for (i2 = 0; i2 < d2.length; i2++)
        b2[i2] = d2.charCodeAt(i2);
      return b2;
    };
    util2.encodeUTF8 = function(arr) {
      var i2, s2 = [];
      for (i2 = 0; i2 < arr.length; i2++)
        s2.push(String.fromCharCode(arr[i2]));
      return decodeURIComponent(escape(s2.join("")));
    };
    if (typeof atob === "undefined") {
      if (typeof Buffer.from !== "undefined") {
        util2.encodeBase64 = function(arr) {
          return Buffer.from(arr).toString("base64");
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
        };
      } else {
        util2.encodeBase64 = function(arr) {
          return new Buffer(arr).toString("base64");
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
        };
      }
    } else {
      util2.encodeBase64 = function(arr) {
        var i2, s2 = [], len2 = arr.length;
        for (i2 = 0; i2 < len2; i2++)
          s2.push(String.fromCharCode(arr[i2]));
        return btoa(s2.join(""));
      };
      util2.decodeBase64 = function(s2) {
        validateBase64(s2);
        var i2, d2 = atob(s2), b2 = new Uint8Array(d2.length);
        for (i2 = 0; i2 < d2.length; i2++)
          b2[i2] = d2.charCodeAt(i2);
        return b2;
      };
    }
    return util2;
  });
})(naclUtil);
const nacl = naclUtilExports;
function encodeUint8Array(value, urlSafe) {
  const encoded = nacl.encodeBase64(value);
  if (!urlSafe) {
    return encoded;
  }
  return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
  if (urlSafe) {
    value = decodeURIComponent(value);
  }
  return nacl.decodeBase64(value);
}
function encode(value, urlSafe = false) {
  let uint8Array;
  if (value instanceof Uint8Array) {
    uint8Array = value;
  } else {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    uint8Array = nacl.decodeUTF8(value);
  }
  return encodeUint8Array(uint8Array, urlSafe);
}
function decode(value, urlSafe = false) {
  const decodedUint8Array = decodeToUint8Array(value, urlSafe);
  return {
    toString() {
      return nacl.encodeUTF8(decodedUint8Array);
    },
    toObject() {
      try {
        return JSON.parse(nacl.encodeUTF8(decodedUint8Array));
      } catch (e) {
        return null;
      }
    },
    toUint8Array() {
      return decodedUint8Array;
    }
  };
}
const Base64 = {
  encode,
  decode
};
function concatUint8Arrays(buffer1, buffer2) {
  const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
  mergedArray.set(buffer1);
  mergedArray.set(buffer2, buffer1.length);
  return mergedArray;
}
function splitToUint8Arrays(array, index) {
  if (index >= array.length) {
    throw new Error("Index is out of buffer");
  }
  const subArray1 = array.slice(0, index);
  const subArray2 = array.slice(index);
  return [subArray1, subArray2];
}
function toHexString(byteArray) {
  let hexString = "";
  byteArray.forEach((byte) => {
    hexString += ("0" + (byte & 255).toString(16)).slice(-2);
  });
  return hexString;
}
function hexToByteArray(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error(`Cannot convert ${hexString} to bytesArray`);
  }
  const result = new Uint8Array(hexString.length / 2);
  for (let i2 = 0; i2 < hexString.length; i2 += 2) {
    result[i2 / 2] = parseInt(hexString.slice(i2, i2 + 2), 16);
  }
  return result;
}
function isNode() {
  return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
}
if (isNode()) {
  try {
    eval("global.crypto = require('crypto').webcrypto");
  } catch (err) {
  }
}
class SessionCrypto {
  constructor(keyPair3) {
    this.nonceLength = 24;
    this.keyPair = keyPair3 ? this.createKeypairFromString(keyPair3) : this.createKeypair();
    this.sessionId = toHexString(this.keyPair.publicKey);
  }
  createKeypair() {
    return naclFastExports.box.keyPair();
  }
  createKeypairFromString(keyPair3) {
    return {
      publicKey: hexToByteArray(keyPair3.publicKey),
      secretKey: hexToByteArray(keyPair3.secretKey)
    };
  }
  createNonce() {
    const buffer2 = new Uint8Array(this.nonceLength);
    return crypto.getRandomValues(buffer2);
  }
  encrypt(message, receiverPublicKey) {
    const encodedMessage = new TextEncoder().encode(message);
    const nonce = this.createNonce();
    const encrypted = naclFastExports.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
    return concatUint8Arrays(nonce, encrypted);
  }
  decrypt(message, senderPublicKey) {
    const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
    const decrypted = naclFastExports.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
    if (!decrypted) {
      throw new Error(`Decryption error: 
 message: ${message.toString()} 
 sender pubkey: ${senderPublicKey.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    }
    return new TextDecoder().decode(decrypted);
  }
  stringifyKeypair() {
    return {
      publicKey: toHexString(this.keyPair.publicKey),
      secretKey: toHexString(this.keyPair.secretKey)
    };
  }
}
const connectEventErrorsCodes = {
  [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
  [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
  [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
  [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,
  [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,
  [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError
};
class ConnectErrorsParser {
  parseError(error) {
    let ErrorConstructor = UnknownError;
    if (error.code in connectEventErrorsCodes) {
      ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;
    }
    return new ErrorConstructor(error.message);
  }
}
const connectErrorsParser = new ConnectErrorsParser();
class RpcParser {
  isError(response) {
    return "error" in response;
  }
}
const sendTransactionErrors = {
  [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
  [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
  [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
  [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
class SendTransactionParser extends RpcParser {
  convertToRpcRequest(request2) {
    return {
      method: "sendTransaction",
      params: [JSON.stringify(request2)]
    };
  }
  parseAndThrowError(response) {
    let ErrorConstructor = UnknownError;
    if (response.error.code in sendTransactionErrors) {
      ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;
    }
    throw new ErrorConstructor(response.error.message);
  }
  convertFromRpcResponse(rpcResponse) {
    return {
      boc: rpcResponse.result
    };
  }
}
const sendTransactionParser = new SendTransactionParser();
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class HttpBridgeGatewayStorage {
  constructor(storage) {
    this.storage = storage;
    this.storeKey = "ton-connect-storage_http-bridge-gateway";
  }
  storeLastEventId(lastEventId) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this.storage.setItem(this.storeKey, lastEventId);
    });
  }
  removeLastEventId() {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getLastEventId() {
    return __awaiter$7(this, void 0, void 0, function* () {
      const stored = yield this.storage.getItem(this.storeKey);
      if (!stored) {
        return null;
      }
      return stored;
    });
  }
}
function removeUrlLastSlash(url) {
  if (url.slice(-1) === "/") {
    return url.slice(0, -1);
  }
  return url;
}
function addPathToUrl(url, path) {
  return removeUrlLastSlash(url) + "/" + path;
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
if (isNode()) {
  try {
    eval("global.EventSource = require('eventsource')");
    eval("global.fetch = require('node-fetch')");
  } catch (err) {
    console.error(err);
  }
}
class BridgeGateway {
  constructor(storage, bridgeUrl, sessionId, listener, errorsListener) {
    this.bridgeUrl = bridgeUrl;
    this.sessionId = sessionId;
    this.listener = listener;
    this.errorsListener = errorsListener;
    this.ssePath = "events";
    this.postPath = "message";
    this.heartbeatMessage = "heartbeat";
    this.defaultTtl = 300;
    this.isClosed = false;
    this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage);
  }
  registerSession() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const url = new URL(addPathToUrl(this.bridgeUrl, this.ssePath));
      url.searchParams.append("client_id", this.sessionId);
      const lastEventId = yield this.bridgeGatewayStorage.getLastEventId();
      if (lastEventId) {
        url.searchParams.append("last_event_id", lastEventId);
      }
      this.eventSource = new EventSource(url.toString());
      return new Promise((resolve, reject) => {
        this.eventSource.onerror = reject;
        this.eventSource.onopen = () => {
          this.eventSource.onerror = this.errorsHandler.bind(this);
          this.eventSource.onmessage = this.messagesHandler.bind(this);
          resolve();
        };
      });
    });
  }
  send(message, receiver, ttl) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));
      url.searchParams.append("client_id", this.sessionId);
      url.searchParams.append("to", receiver);
      url.searchParams.append("ttl", (ttl || this.defaultTtl).toString());
      yield fetch(url, {
        method: "post",
        body: Base64.encode(message)
      });
    });
  }
  close() {
    var _a2;
    this.isClosed = true;
    (_a2 = this.eventSource) === null || _a2 === void 0 ? void 0 : _a2.close();
  }
  errorsHandler(e) {
    var _a2, _b;
    if (!this.isClosed) {
      if (((_a2 = this.eventSource) === null || _a2 === void 0 ? void 0 : _a2.readyState) === EventSource.CLOSED) {
        this.eventSource.close();
        this.registerSession();
        return;
      }
      if (((_b = this.eventSource) === null || _b === void 0 ? void 0 : _b.readyState) === EventSource.CONNECTING) {
        console.debug("[TON_CONNET_SDK_ERROR]: Bridge error", JSON.stringify(e));
        return;
      }
      this.errorsListener(e);
    }
  }
  messagesHandler(e) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (e.data === this.heartbeatMessage) {
        return;
      }
      yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);
      if (!this.isClosed) {
        let bridgeIncomingMessage;
        try {
          bridgeIncomingMessage = JSON.parse(e.data);
        } catch (e2) {
          throw new TonConnectError(`Bridge message parse failed, message ${e2.data}`);
        }
        this.listener(bridgeIncomingMessage);
      }
    });
  }
}
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class BridgeConnectionStorage {
  constructor(storage) {
    this.storage = storage;
    this.storeKey = "ton-connect-storage_bridge-connection";
  }
  storeConnection(connection) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (connection.type === "injected") {
        return this.storage.setItem(this.storeKey, JSON.stringify(connection));
      }
      const rawSession = {
        sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),
        walletPublicKey: connection.session.walletPublicKey,
        walletConnectionSource: connection.session.walletConnectionSource
      };
      const rawConnection = {
        type: "http",
        connectEvent: connection.connectEvent,
        session: rawSession
      };
      return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));
    });
  }
  removeConnection() {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getConnection() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const stored = yield this.storage.getItem(this.storeKey);
      if (!stored) {
        return null;
      }
      const connection = JSON.parse(stored);
      if (connection.type === "injected") {
        return connection;
      }
      const sessionCrypto = new SessionCrypto(connection.session.sessionKeyPair);
      return {
        type: "http",
        connectEvent: connection.connectEvent,
        session: {
          sessionCrypto,
          walletConnectionSource: connection.session.walletConnectionSource,
          walletPublicKey: connection.session.walletPublicKey
        }
      };
    });
  }
  getHttpConnection() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (!connection) {
        throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
      }
      if (connection.type === "injected") {
        throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
      }
      return connection;
    });
  }
  getInjectedConnection() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (!connection) {
        throw new TonConnectError("Trying to read Injected bridge connection source while nothing is stored");
      }
      if ((connection === null || connection === void 0 ? void 0 : connection.type) === "http") {
        throw new TonConnectError("Trying to read Injected bridge connection source while HTTP connection is stored");
      }
      return connection;
    });
  }
  storedConnectionType() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const stored = yield this.storage.getItem(this.storeKey);
      if (!stored) {
        return null;
      }
      const connection = JSON.parse(stored);
      return connection.type;
    });
  }
}
const PROTOCOL_VERSION = 2;
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class BridgeProvider {
  constructor(storage, walletConnectionSource) {
    this.storage = storage;
    this.walletConnectionSource = walletConnectionSource;
    this.type = "http";
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.nextRequestId = 0;
    this.session = null;
    this.bridge = null;
    this.listeners = [];
    this.connectionStorage = new BridgeConnectionStorage(storage);
  }
  static fromStorage(storage) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const bridgeConnectionStorage = new BridgeConnectionStorage(storage);
      const connection = yield bridgeConnectionStorage.getHttpConnection();
      return new BridgeProvider(storage, connection.session.walletConnectionSource);
    });
  }
  connect(message) {
    var _a2;
    (_a2 = this.bridge) === null || _a2 === void 0 ? void 0 : _a2.close();
    const sessionCrypto = new SessionCrypto();
    this.session = {
      sessionCrypto,
      walletConnectionSource: this.walletConnectionSource
    };
    this.bridge = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));
    this.bridge.registerSession();
    return this.generateUniversalLink(message);
  }
  restoreConnection() {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      (_a2 = this.bridge) === null || _a2 === void 0 ? void 0 : _a2.close();
      const storedConnection = yield this.connectionStorage.getHttpConnection();
      if (!storedConnection) {
        return;
      }
      this.session = storedConnection.session;
      this.bridge = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));
      yield this.bridge.registerSession();
      this.listeners.forEach((listener) => listener(storedConnection.connectEvent));
    });
  }
  sendRequest(request2) {
    return new Promise((resolve, reject) => {
      const id2 = this.nextRequestId;
      this.nextRequestId++;
      if (!this.bridge || !this.session || !("walletPublicKey" in this.session)) {
        throw new TonConnectError("Trying to send bridge request without session");
      }
      const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request2), { id: id2 })), hexToByteArray(this.session.walletPublicKey));
      this.bridge.send(encodedRequest, this.session.walletPublicKey).catch(reject);
      this.pendingRequests.set(id2.toString(), resolve);
    });
  }
  closeConnection() {
    var _a2;
    (_a2 = this.bridge) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.listeners = [];
    this.session = null;
    this.bridge = null;
  }
  disconnect() {
    var _a2;
    (_a2 = this.bridge) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.listeners = [];
    return this.removeBridgeAndSession();
  }
  listen(callback) {
    this.listeners.push(callback);
    return () => this.listeners = this.listeners.filter((listener) => listener !== callback);
  }
  gatewayListener(bridgeIncomingMessage) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(bridgeIncomingMessage.message).toUint8Array(), hexToByteArray(bridgeIncomingMessage.from)));
      if (!("event" in walletMessage)) {
        const id2 = walletMessage.id.toString();
        const resolve = this.pendingRequests.get(id2);
        if (!resolve) {
          throw new TonConnectError(`Response id ${id2} doesn't match any request's id`);
        }
        resolve(walletMessage);
        this.pendingRequests.delete(id2);
        return;
      }
      if (walletMessage.event === "connect") {
        yield this.updateSession(walletMessage, bridgeIncomingMessage.from);
      }
      if (walletMessage.event === "disconnect") {
        yield this.removeBridgeAndSession();
      }
      this.listeners.forEach((listener) => listener(walletMessage));
    });
  }
  gatewayErrorsListener(e) {
    return __awaiter$4(this, void 0, void 0, function* () {
      throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);
    });
  }
  updateSession(connectEvent, walletPublicKey) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey });
      const tonAddrItem = connectEvent.payload.items.find((item) => item.name === "ton_addr");
      const connectEventToSave = Object.assign(Object.assign({}, connectEvent), { payload: Object.assign(Object.assign({}, connectEvent.payload), { items: [tonAddrItem] }) });
      yield this.connectionStorage.storeConnection({
        type: "http",
        session: this.session,
        connectEvent: connectEventToSave
      });
    });
  }
  removeBridgeAndSession() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.session = null;
      this.bridge = null;
      yield this.connectionStorage.removeConnection();
    });
  }
  generateUniversalLink(message) {
    const url = new URL(this.walletConnectionSource.universalLink);
    url.searchParams.append("v", PROTOCOL_VERSION.toString());
    url.searchParams.append("id", this.session.sessionCrypto.sessionId);
    url.searchParams.append("r", JSON.stringify(message));
    return url.toString();
  }
}
function getWindow() {
  if (typeof window === "undefined") {
    return void 0;
  }
  return window;
}
function getWebPageManifest() {
  var _a2;
  const origin = (_a2 = getWindow()) === null || _a2 === void 0 ? void 0 : _a2.location.origin;
  if (origin) {
    return origin + "/tonconnect-manifest.json";
  }
  return "";
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class InjectedProvider {
  constructor(storage, injectedWalletKey) {
    this.injectedWalletKey = injectedWalletKey;
    this.type = "injected";
    this.unsubscribeCallback = null;
    this.listenSubscriptions = false;
    this.listeners = [];
    const window2 = InjectedProvider.window;
    if (!InjectedProvider.isWindowContainsWallet(window2, injectedWalletKey)) {
      throw new WalletNotInjectedError();
    }
    this.connectionStorage = new BridgeConnectionStorage(storage);
    this.injectedWallet = window2[injectedWalletKey].tonconnect;
  }
  static fromStorage(storage) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const bridgeConnectionStorage = new BridgeConnectionStorage(storage);
      const connection = yield bridgeConnectionStorage.getInjectedConnection();
      return new InjectedProvider(storage, connection.jsBridgeKey);
    });
  }
  static isWalletInjected(injectedWalletKey) {
    return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);
  }
  static isInsideWalletBrowser(injectedWalletKey) {
    if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {
      return this.window[injectedWalletKey].tonconnect.isWalletBrowser;
    }
    return false;
  }
  static isWindowContainsWallet(window2, injectedWalletKey) {
    return !!window2 && injectedWalletKey in window2 && typeof window2[injectedWalletKey] === "object" && "tonconnect" in window2[injectedWalletKey];
  }
  connect(message) {
    this._connect(PROTOCOL_VERSION, message);
  }
  restoreConnection() {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const connectEvent = yield this.injectedWallet.restoreConnection();
        if (connectEvent.event === "connect") {
          this.makeSubscriptions();
          this.listeners.forEach((listener) => listener(connectEvent));
        } else {
          yield this.connectionStorage.removeConnection();
        }
      } catch (e) {
        yield this.connectionStorage.removeConnection();
        console.error(e);
      }
    });
  }
  closeConnection() {
    if (this.listenSubscriptions) {
      this.injectedWallet.disconnect();
    }
    this.closeAllListeners();
  }
  disconnect() {
    this.closeAllListeners();
    this.injectedWallet.disconnect();
    return this.connectionStorage.removeConnection();
  }
  closeAllListeners() {
    var _a2;
    this.listenSubscriptions = false;
    this.listeners = [];
    (_a2 = this.unsubscribeCallback) === null || _a2 === void 0 ? void 0 : _a2.call(this);
  }
  listen(eventsCallback) {
    this.listeners.push(eventsCallback);
    return () => this.listeners = this.listeners.filter((listener) => listener !== eventsCallback);
  }
  sendRequest(request2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.injectedWallet.send(Object.assign(Object.assign({}, request2), { id: "0" }));
    });
  }
  _connect(protocolVersion, message) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);
        if (connectEvent.event === "connect") {
          yield this.updateSession();
          this.makeSubscriptions();
        }
        this.listeners.forEach((listener) => listener(connectEvent));
      } catch (e) {
        console.debug(e);
        const connectEventError = {
          event: "connect_error",
          payload: {
            code: 0,
            message: e === null || e === void 0 ? void 0 : e.toString()
          }
        };
        this.listeners.forEach((listener) => listener(connectEventError));
      }
    });
  }
  makeSubscriptions() {
    this.listenSubscriptions = true;
    this.unsubscribeCallback = this.injectedWallet.listen((e) => {
      if (this.listenSubscriptions) {
        this.listeners.forEach((listener) => listener(e));
      }
      if (e.event === "disconnect") {
        this.disconnect();
      }
    });
  }
  updateSession() {
    return this.connectionStorage.storeConnection({
      type: "injected",
      jsBridgeKey: this.injectedWalletKey
    });
  }
}
InjectedProvider.window = getWindow();
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DefaultStorage {
  constructor() {
    const window2 = getWindow();
    if (!(window2 === null || window2 === void 0 ? void 0 : window2.localStorage)) {
      throw new LocalstorageNotFoundError();
    }
    this.window = window2;
  }
  getItem(key2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return Promise.resolve(this.window.localStorage.getItem(key2));
    });
  }
  removeItem(key2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      this.window.localStorage.removeItem(key2);
      return Promise.resolve();
    });
  }
  setItem(key2, value) {
    this.window.localStorage.setItem(key2, value);
    return Promise.resolve();
  }
}
function isWalletInfoInjected(value) {
  return "jsBridgeKey" in value;
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class WalletsListManager {
  constructor(walletsListSource) {
    this.walletsListCache = null;
    this.walletsListSource = "https://raw.githubusercontent.com/ton-connect/wallets-list/main/wallets.json";
    if (walletsListSource) {
      this.walletsListSource = walletsListSource;
    }
  }
  getWallets() {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (!this.walletsListCache) {
        this.walletsListCache = this.fetchWalletsList();
        this.walletsListCache.catch(() => this.walletsListCache = null);
      }
      return this.walletsListCache;
    });
  }
  getEmbeddedWallet() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const walletsList = yield this.getWallets();
      const embeddedWallets = walletsList.filter((item) => isWalletInfoInjected(item) && item.embedded);
      if (embeddedWallets.length !== 1) {
        return null;
      }
      return embeddedWallets[0];
    });
  }
  fetchWalletsList() {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const walletsResponse = yield fetch(this.walletsListSource);
        const walletsList = yield walletsResponse.json();
        if (!Array.isArray(walletsList) || !walletsList.every((wallet) => this.isCorrectWalletConfigDTO(wallet))) {
          throw new FetchWalletsError("Wrong wallets list format");
        }
        return this.walletConfigDTOListToWalletConfigList(walletsList);
      } catch (e) {
        throw new FetchWalletsError(e);
      }
    });
  }
  walletConfigDTOListToWalletConfigList(walletConfigDTO) {
    return walletConfigDTO.map((walletConfigDTO2) => {
      const walletConfig = {
        name: walletConfigDTO2.name,
        imageUrl: walletConfigDTO2.image,
        aboutUrl: walletConfigDTO2.about_url,
        tondns: walletConfigDTO2.tondns
      };
      walletConfigDTO2.bridge.forEach((bridge) => {
        if (bridge.type === "sse") {
          walletConfig.bridgeUrl = bridge.url;
          walletConfig.universalLink = walletConfigDTO2.universal_url;
          walletConfig.deepLink = walletConfigDTO2.deepLink;
        }
        if (bridge.type === "js") {
          const jsBridgeKey = bridge.key;
          walletConfig.jsBridgeKey = jsBridgeKey;
          walletConfig.injected = InjectedProvider.isWalletInjected(jsBridgeKey);
          walletConfig.embedded = InjectedProvider.isInsideWalletBrowser(jsBridgeKey);
        }
      });
      return walletConfig;
    });
  }
  isCorrectWalletConfigDTO(value) {
    if (!value || !(typeof value === "object")) {
      return false;
    }
    const containsName = "name" in value;
    const containsImage = "image" in value;
    const containsAbout = "about_url" in value;
    if (!containsName || !containsImage || !containsAbout) {
      return false;
    }
    if (!("bridge" in value) || !Array.isArray(value.bridge) || !value.bridge.length) {
      return false;
    }
    const bridge = value.bridge;
    if (bridge.some((item) => !item || typeof item !== "object" || !("type" in item))) {
      return false;
    }
    const sseBridge = bridge.find((item) => item.type === "sse");
    if (sseBridge) {
      if (!("url" in sseBridge) || !sseBridge.url || !value.universal_url) {
        return false;
      }
    }
    const jsBridge = bridge.find((item) => item.type === "js");
    if (jsBridge) {
      if (!("key" in jsBridge) || !jsBridge.key) {
        return false;
      }
    }
    return true;
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = globalThis && globalThis.__rest || function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
};
class TonConnect {
  constructor(options) {
    this.walletsList = new WalletsListManager();
    this._wallet = null;
    this.provider = null;
    this.statusChangeSubscriptions = [];
    this.statusChangeErrorSubscriptions = [];
    this.dappSettings = {
      manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest(),
      storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()
    };
    this.walletsList = new WalletsListManager(options === null || options === void 0 ? void 0 : options.walletsListSource);
    if (!this.dappSettings.manifestUrl) {
      throw new DappMetadataError("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
    }
    this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage);
  }
  /**
   * Returns available wallets list.
   */
  static getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Shows if the wallet is connected right now.
   */
  get connected() {
    return this._wallet !== null;
  }
  /**
   * Current connected account or null if no account is connected.
   */
  get account() {
    var _a2;
    return ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.account) || null;
  }
  /**
   * Current connected wallet or null if no account is connected.
   */
  get wallet() {
    return this._wallet;
  }
  set wallet(value) {
    this._wallet = value;
    this.statusChangeSubscriptions.forEach((callback) => callback(this._wallet));
  }
  /**
   * Returns available wallets list.
   */
  getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Allows to subscribe to connection status changes and handle connection errors.
   * @param callback will be called after connections status changes with actual wallet or null.
   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
   * @returns unsubscribe callback.
   */
  onStatusChange(callback, errorsHandler) {
    this.statusChangeSubscriptions.push(callback);
    if (errorsHandler) {
      this.statusChangeErrorSubscriptions.push(errorsHandler);
    }
    return () => {
      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((item) => item !== callback);
      if (errorsHandler) {
        this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((item) => item !== errorsHandler);
      }
    };
  }
  connect(wallet, request2) {
    var _a2;
    if (this.connected) {
      throw new WalletAlreadyConnectedError();
    }
    (_a2 = this.provider) === null || _a2 === void 0 ? void 0 : _a2.closeConnection();
    this.provider = this.createProvider(wallet);
    return this.provider.connect(this.createConnectRequest(request2));
  }
  /**
   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
   */
  restoreConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      const [bridgeConnectionType, embeddedWallet] = yield Promise.all([
        this.bridgeConnectionStorage.storedConnectionType(),
        this.walletsList.getEmbeddedWallet()
      ]);
      switch (bridgeConnectionType) {
        case "http":
          this.provider = yield BridgeProvider.fromStorage(this.dappSettings.storage);
          break;
        case "injected":
          this.provider = yield InjectedProvider.fromStorage(this.dappSettings.storage);
          break;
        default:
          if (embeddedWallet) {
            this.provider = yield this.createProvider(embeddedWallet);
          } else {
            return;
          }
      }
      this.provider.listen(this.walletEventsListener.bind(this));
      return this.provider.restoreConnection();
    });
  }
  /**
   * Asks connected wallet to sign and send the transaction.
   * @param transaction transaction to send.
   * @returns signed transaction boc that allows you to find the transaction in the blockchain.
   * If user rejects transaction, method will throw the corresponding error.
   */
  sendTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      this.checkConnection();
      this.checkFeatureSupport("SendTransaction");
      const { validUntil } = transaction, tx = __rest(transaction, ["validUntil"]);
      const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), { valid_until: validUntil })));
      if (sendTransactionParser.isError(response)) {
        return sendTransactionParser.parseAndThrowError(response);
      }
      return sendTransactionParser.convertFromRpcResponse(response);
    });
  }
  /**
   * Disconnect form thw connected wallet and drop current session.
   */
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.connected) {
        throw new WalletNotConnectedError();
      }
      yield this.provider.disconnect();
      this.onWalletDisconnected();
    });
  }
  createProvider(wallet) {
    let provider;
    if (isWalletConnectionSourceJS(wallet)) {
      provider = new InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);
    } else {
      provider = new BridgeProvider(this.dappSettings.storage, wallet);
    }
    provider.listen(this.walletEventsListener.bind(this));
    return provider;
  }
  walletEventsListener(e) {
    switch (e.event) {
      case "connect":
        this.onWalletConnected(e.payload);
        break;
      case "connect_error":
        this.onWalletConnectError(e.payload);
        break;
      case "disconnect":
        this.onWalletDisconnected();
    }
  }
  onWalletConnected(connectEvent) {
    const tonAccountItem = connectEvent.items.find((item) => item.name === "ton_addr");
    const tonProofItem = connectEvent.items.find((item) => item.name === "ton_proof");
    if (!tonAccountItem) {
      throw new TonConnectError("ton_addr connection item was not found");
    }
    const wallet = {
      device: connectEvent.device,
      provider: this.provider.type,
      account: {
        address: tonAccountItem.address,
        chain: tonAccountItem.network,
        walletStateInit: tonAccountItem.walletStateInit
      }
    };
    if (tonProofItem) {
      wallet.connectItems = {
        tonProof: tonProofItem
      };
    }
    this.wallet = wallet;
  }
  onWalletConnectError(connectEventError) {
    const error = connectErrorsParser.parseError(connectEventError);
    this.statusChangeErrorSubscriptions.forEach((errorsHandler) => errorsHandler(error));
    console.debug(error);
    if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {
      console.error(error);
      throw error;
    }
  }
  onWalletDisconnected() {
    this.wallet = null;
  }
  checkConnection() {
    if (!this.connected) {
      throw new WalletNotConnectedError();
    }
  }
  checkFeatureSupport(feature) {
    var _a2;
    if (!((_a2 = this.wallet) === null || _a2 === void 0 ? void 0 : _a2.device.features.includes(feature))) {
      throw new WalletNotSupportFeatureError();
    }
  }
  createConnectRequest(request2) {
    const items = [
      {
        name: "ton_addr"
      }
    ];
    if (request2 === null || request2 === void 0 ? void 0 : request2.tonProof) {
      items.push({
        name: "ton_proof",
        payload: request2.tonProof
      });
    }
    return {
      manifestUrl: this.dappSettings.manifestUrl,
      items
    };
  }
}
TonConnect.walletsList = new WalletsListManager();
TonConnect.isWalletInjected = (walletJSKey) => InjectedProvider.isWalletInjected(walletJSKey);
TonConnect.isInsideWalletBrowser = (walletJSKey) => InjectedProvider.isInsideWalletBrowser(walletJSKey);
for (let ord = 0; ord <= 255; ord++) {
  let s2 = ord.toString(16);
  if (s2.length < 2) {
    s2 = "0" + s2;
  }
}
class TonKeeper extends Wallet$1 {
  constructor() {
    super();
    this.available = true;
    this.connector = new TonConnect({
      manifestUrl: "https://raw.githubusercontent.com/bifrost-defi/bifrost/main/tonconnect-manifest.json"
    });
  }
  async connectInjected() {
    throw new Error("Injected TonKeeper is not supported.");
  }
  async connectExternal(cb) {
    const walletsList = await TonConnect.getWallets();
    const walletConnectionSource = {
      universalLink: walletsList[0].universalLink,
      bridgeUrl: walletsList[0].bridgeUrl
    };
    this.connector.onStatusChange((wallet) => {
      if (this.connector.connected && wallet) {
        this.address = dist.Address.parseRaw(wallet.account.address).toString();
        cb(this.address);
      }
    }, console.error);
    return this.connector.connect(walletConnectionSource);
  }
}
Ethereum.init({
  MetaMask: new MetaMask()
});
Tezos.init({
  TempleWallet: new TempleWallet()
});
TON.init({
  TonKeeper: new TonKeeper()
});
const matchers = {};
const nodes = [
  () => __vitePreload(() => import("./0-d1c422c6.js"), true ? ["./0-d1c422c6.js","./_layout-a7d677aa.js","../components/pages/_layout.svelte-8b8d505f.js","./index-64643071.js","./index-872a1312.js","../assets/_layout-755d2fce.css"] : void 0, import.meta.url),
  () => __vitePreload(() => import("./1-e38741e9.js"), true ? ["./1-e38741e9.js","../components/error.svelte-e4420b85.js","./index-64643071.js","./stores-1fb1289c.js","./singletons-8a040551.js","./paths-51e4d197.js"] : void 0, import.meta.url),
  () => __vitePreload(() => import("./2-9bde166e.js"), true ? ["./2-9bde166e.js","../components/pages/_page.svelte-ae8b0cb5.js","./index-64643071.js","./index-872a1312.js","./paths-51e4d197.js","./pages.crossfade-ed74b118.js"] : void 0, import.meta.url),
  () => __vitePreload(() => import("./3-f8dee5c5.js"), true ? ["./3-f8dee5c5.js","../components/pages/swap/_page.svelte-1efb4ca2.js","./index-64643071.js","./stores-1fb1289c.js","./singletons-8a040551.js","./paths-51e4d197.js","./pages.crossfade-ed74b118.js","./index-872a1312.js","./bignumber-d04f630d.js"] : void 0, import.meta.url)
];
const server_loads = [];
const dictionary = {
  "/": [2],
  "/swap": [3]
};
const hooks = {
  handleError: ({ error }) => {
    console.error(error);
  }
};
let HttpError = class HttpError2 {
  /**
   * @param {number} status
   * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
   */
  constructor(status, body) {
    this.status = status;
    if (typeof body === "string") {
      this.body = { message: body };
    } else if (body) {
      this.body = body;
    } else {
      this.body = { message: `Error: ${status}` };
    }
  }
  toString() {
    return JSON.stringify(this.body);
  }
};
let Redirect = class Redirect2 {
  /**
   * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
   * @param {string} location
   */
  constructor(status, location2) {
    this.status = status;
    this.location = location2;
  }
};
async function unwrap_promises(object) {
  var _a2;
  for (const key2 in object) {
    if (typeof ((_a2 = object[key2]) == null ? void 0 : _a2.then) === "function") {
      return Object.fromEntries(
        await Promise.all(Object.entries(object).map(async ([key3, value]) => [key3, await value]))
      );
    }
  }
  return object;
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
const UNDEFINED = -1;
const HOLE = -2;
const NAN = -3;
const POSITIVE_INFINITY = -4;
const NEGATIVE_INFINITY = -5;
const NEGATIVE_ZERO = -6;
function unflatten(parsed, revivers) {
  if (typeof parsed === "number")
    return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = parsed;
  const hydrated = Array(values.length);
  function hydrate(index, standalone = false) {
    if (index === UNDEFINED)
      return void 0;
    if (index === NAN)
      return NaN;
    if (index === POSITIVE_INFINITY)
      return Infinity;
    if (index === NEGATIVE_INFINITY)
      return -Infinity;
    if (index === NEGATIVE_ZERO)
      return -0;
    if (standalone)
      throw new Error(`Invalid input`);
    if (index in hydrated)
      return hydrated[index];
    const value = values[index];
    if (!value || typeof value !== "object") {
      hydrated[index] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers == null ? void 0 : revivers[type];
        if (reviver) {
          return hydrated[index] = reviver(hydrate(value[1]));
        }
        switch (type) {
          case "Date":
            hydrated[index] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated[index] = set2;
            for (let i2 = 1; i2 < value.length; i2 += 1) {
              set2.add(hydrate(value[i2]));
            }
            break;
          case "Map":
            const map2 = /* @__PURE__ */ new Map();
            hydrated[index] = map2;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              map2.set(hydrate(value[i2]), hydrate(value[i2 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index] = obj;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              obj[value[i2]] = hydrate(value[i2 + 1]);
            }
            break;
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index] = array;
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          const n = value[i2];
          if (n === HOLE)
            continue;
          array[i2] = hydrate(n);
        }
      }
    } else {
      const object = {};
      hydrated[index] = object;
      for (const key2 in value) {
        const n = value[key2];
        object[key2] = hydrate(n);
      }
    }
    return hydrated[index];
  }
  return hydrate(0);
}
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
const routes = parse$1(nodes, server_loads, dictionary, matchers);
const default_layout_loader = nodes[0];
const default_error_loader = nodes[1];
default_layout_loader();
default_error_loader();
const scroll_positions = get(SCROLL_KEY) ?? {};
const snapshots = get(SNAPSHOT_KEY) ?? {};
function update_scroll_positions(index) {
  scroll_positions[index] = scroll_state();
}
function create_client({ target }) {
  var _a2;
  const container = document.documentElement;
  const invalidated = [];
  const components = [];
  let load_cache = null;
  const callbacks = {
    /** @type {Array<(navigation: import('types').BeforeNavigate) => void>} */
    before_navigate: [],
    /** @type {Array<(navigation: import('types').AfterNavigate) => void>} */
    after_navigate: []
  };
  let current = {
    branch: [],
    error: null,
    // @ts-ignore - we need the initial value to be null
    url: null
  };
  let hydrated = false;
  let started = false;
  let autoscroll = true;
  let updating = false;
  let navigating = false;
  let hash_navigating = false;
  let force_invalidation = false;
  let root;
  let current_history_index = (_a2 = history.state) == null ? void 0 : _a2[INDEX_KEY];
  if (!current_history_index) {
    current_history_index = Date.now();
    history.replaceState(
      { ...history.state, [INDEX_KEY]: current_history_index },
      "",
      location.href
    );
  }
  const scroll = scroll_positions[current_history_index];
  if (scroll) {
    history.scrollRestoration = "manual";
    scrollTo(scroll.x, scroll.y);
  }
  let page;
  let token;
  let pending_invalidate;
  async function invalidate() {
    pending_invalidate = pending_invalidate || Promise.resolve();
    await pending_invalidate;
    pending_invalidate = null;
    const url = new URL(location.href);
    const intent = get_navigation_intent(url, true);
    load_cache = null;
    await update6(intent, url, []);
  }
  function capture_snapshot(index) {
    if (components.some((c2) => c2 == null ? void 0 : c2.snapshot)) {
      snapshots[index] = components.map((c2) => {
        var _a3;
        return (_a3 = c2 == null ? void 0 : c2.snapshot) == null ? void 0 : _a3.capture();
      });
    }
  }
  function restore_snapshot(index) {
    var _a3;
    (_a3 = snapshots[index]) == null ? void 0 : _a3.forEach((value, i2) => {
      var _a4, _b;
      (_b = (_a4 = components[i2]) == null ? void 0 : _a4.snapshot) == null ? void 0 : _b.restore(value);
    });
  }
  async function goto(url, {
    noScroll = false,
    replaceState = false,
    keepFocus = false,
    state: state2 = {},
    invalidateAll = false
  }, redirect_chain, nav_token) {
    if (typeof url === "string") {
      url = new URL(url, get_base_uri(document));
    }
    return navigate({
      url,
      scroll: noScroll ? scroll_state() : null,
      keepfocus: keepFocus,
      redirect_chain,
      details: {
        state: state2,
        replaceState
      },
      nav_token,
      accepted: () => {
        if (invalidateAll) {
          force_invalidation = true;
        }
      },
      blocked: () => {
      },
      type: "goto"
    });
  }
  async function preload_data(intent) {
    load_cache = {
      id: intent.id,
      promise: load_route(intent).then((result) => {
        if (result.type === "loaded" && result.state.error) {
          load_cache = null;
        }
        return result;
      })
    };
    return load_cache.promise;
  }
  async function preload_code(...pathnames) {
    const matching = routes.filter((route) => pathnames.some((pathname) => route.exec(pathname)));
    const promises = matching.map((r2) => {
      return Promise.all([...r2.layouts, r2.leaf].map((load) => load == null ? void 0 : load[1]()));
    });
    await Promise.all(promises);
  }
  async function update6(intent, url, redirect_chain, previous_history_index, opts, nav_token = {}, callback) {
    var _a3, _b;
    token = nav_token;
    let navigation_result = intent && await load_route(intent);
    if (!navigation_result) {
      navigation_result = await server_fallback(
        url,
        { id: null },
        await handle_error(new Error(`Not found: ${url.pathname}`), {
          url,
          params: {},
          route: { id: null }
        }),
        404
      );
    }
    url = (intent == null ? void 0 : intent.url) || url;
    if (token !== nav_token)
      return false;
    if (navigation_result.type === "redirect") {
      if (redirect_chain.length > 10 || redirect_chain.includes(url.pathname)) {
        navigation_result = await load_root_error_page({
          status: 500,
          error: await handle_error(new Error("Redirect loop"), {
            url,
            params: {},
            route: { id: null }
          }),
          url,
          route: { id: null }
        });
      } else {
        goto(
          new URL(navigation_result.location, url).href,
          {},
          [...redirect_chain, url.pathname],
          nav_token
        );
        return false;
      }
    } else if (((_b = (_a3 = navigation_result.props) == null ? void 0 : _a3.page) == null ? void 0 : _b.status) >= 400) {
      const updated = await stores.updated.check();
      if (updated) {
        await native_navigation(url);
      }
    }
    invalidated.length = 0;
    force_invalidation = false;
    updating = true;
    if (previous_history_index) {
      update_scroll_positions(previous_history_index);
      capture_snapshot(previous_history_index);
    }
    if (opts && opts.details) {
      const { details } = opts;
      const change = details.replaceState ? 0 : 1;
      details.state[INDEX_KEY] = current_history_index += change;
      history[details.replaceState ? "replaceState" : "pushState"](details.state, "", url);
      if (!details.replaceState) {
        let i2 = current_history_index + 1;
        while (snapshots[i2] || scroll_positions[i2]) {
          delete snapshots[i2];
          delete scroll_positions[i2];
          i2 += 1;
        }
      }
    }
    load_cache = null;
    if (started) {
      current = navigation_result.state;
      if (navigation_result.props.page) {
        navigation_result.props.page.url = url;
      }
      root.$set(navigation_result.props);
    } else {
      initialize(navigation_result);
    }
    if (opts) {
      const { scroll: scroll2, keepfocus } = opts;
      const { activeElement } = document;
      await tick();
      const changed_focus = (
        // reset focus only if any manual focus management didn't override it
        document.activeElement !== activeElement && // also refocus when activeElement is body already because the
        // focus event might not have been fired on it yet
        document.activeElement !== document.body
      );
      if (!keepfocus && !changed_focus) {
        await reset_focus();
      }
      if (autoscroll) {
        const deep_linked = url.hash && document.getElementById(decodeURIComponent(url.hash.slice(1)));
        if (scroll2) {
          scrollTo(scroll2.x, scroll2.y);
        } else if (deep_linked) {
          deep_linked.scrollIntoView();
        } else {
          scrollTo(0, 0);
        }
      }
    } else {
      await tick();
    }
    autoscroll = true;
    if (navigation_result.props.page) {
      page = navigation_result.props.page;
    }
    if (callback)
      callback();
    updating = false;
  }
  function initialize(result) {
    var _a3;
    current = result.state;
    const style = document.querySelector("style[data-sveltekit]");
    if (style)
      style.remove();
    page = result.props.page;
    root = new Root({
      target,
      props: { ...result.props, stores, components },
      hydrate: true
    });
    restore_snapshot(current_history_index);
    const navigation = {
      from: null,
      to: {
        params: current.params,
        route: { id: ((_a3 = current.route) == null ? void 0 : _a3.id) ?? null },
        url: new URL(location.href)
      },
      willUnload: false,
      type: "enter"
    };
    callbacks.after_navigate.forEach((fn) => fn(navigation));
    started = true;
  }
  async function get_navigation_result_from_branch({
    url,
    params,
    branch,
    status,
    error,
    route,
    form
  }) {
    let slash = "never";
    for (const node2 of branch) {
      if ((node2 == null ? void 0 : node2.slash) !== void 0)
        slash = node2.slash;
    }
    url.pathname = normalize_path(url.pathname, slash);
    url.search = url.search;
    const result = {
      type: "loaded",
      state: {
        url,
        params,
        branch,
        error,
        route
      },
      props: {
        // @ts-ignore Somehow it's getting SvelteComponent and SvelteComponentDev mixed up
        constructors: compact(branch).map((branch_node) => branch_node.node.component)
      }
    };
    if (form !== void 0) {
      result.props.form = form;
    }
    let data2 = {};
    let data_changed = !page;
    let p2 = 0;
    for (let i2 = 0; i2 < Math.max(branch.length, current.branch.length); i2 += 1) {
      const node2 = branch[i2];
      const prev = current.branch[i2];
      if ((node2 == null ? void 0 : node2.data) !== (prev == null ? void 0 : prev.data))
        data_changed = true;
      if (!node2)
        continue;
      data2 = { ...data2, ...node2.data };
      if (data_changed) {
        result.props[`data_${p2}`] = data2;
      }
      p2 += 1;
    }
    const page_changed = !current.url || url.href !== current.url.href || current.error !== error || form !== void 0 && form !== page.form || data_changed;
    if (page_changed) {
      result.props.page = {
        error,
        params,
        route: {
          id: (route == null ? void 0 : route.id) ?? null
        },
        status,
        url: new URL(url),
        form: form ?? null,
        // The whole page store is updated, but this way the object reference stays the same
        data: data_changed ? data2 : page.data
      };
    }
    return result;
  }
  async function load_node({ loader, parent, url, params, route, server_data_node }) {
    var _a3, _b, _c;
    let data2 = null;
    const uses = {
      dependencies: /* @__PURE__ */ new Set(),
      params: /* @__PURE__ */ new Set(),
      parent: false,
      route: false,
      url: false
    };
    const node2 = await loader();
    if ((_a3 = node2.universal) == null ? void 0 : _a3.load) {
      let depends = function(...deps) {
        for (const dep of deps) {
          const { href } = new URL(dep, url);
          uses.dependencies.add(href);
        }
      };
      const load_input = {
        route: {
          get id() {
            uses.route = true;
            return route.id;
          }
        },
        params: new Proxy(params, {
          get: (target2, key2) => {
            uses.params.add(key2);
            return target2[key2];
          }
        }),
        data: (server_data_node == null ? void 0 : server_data_node.data) ?? null,
        url: make_trackable(url, () => {
          uses.url = true;
        }),
        async fetch(resource, init5) {
          let requested;
          if (resource instanceof Request) {
            requested = resource.url;
            init5 = {
              // the request body must be consumed in memory until browsers
              // implement streaming request bodies and/or the body getter
              body: resource.method === "GET" || resource.method === "HEAD" ? void 0 : await resource.blob(),
              cache: resource.cache,
              credentials: resource.credentials,
              headers: resource.headers,
              integrity: resource.integrity,
              keepalive: resource.keepalive,
              method: resource.method,
              mode: resource.mode,
              redirect: resource.redirect,
              referrer: resource.referrer,
              referrerPolicy: resource.referrerPolicy,
              signal: resource.signal,
              ...init5
            };
          } else {
            requested = resource;
          }
          const resolved = new URL(requested, url);
          depends(resolved.href);
          if (resolved.origin === url.origin) {
            requested = resolved.href.slice(url.origin.length);
          }
          return started ? subsequent_fetch(requested, resolved.href, init5) : initial_fetch(requested, init5);
        },
        setHeaders: () => {
        },
        // noop
        depends,
        parent() {
          uses.parent = true;
          return parent();
        }
      };
      {
        data2 = await node2.universal.load.call(null, load_input) ?? null;
      }
      data2 = data2 ? await unwrap_promises(data2) : null;
    }
    return {
      node: node2,
      loader,
      server: server_data_node,
      universal: ((_b = node2.universal) == null ? void 0 : _b.load) ? { type: "data", data: data2, uses } : null,
      data: data2 ?? (server_data_node == null ? void 0 : server_data_node.data) ?? null,
      slash: ((_c = node2.universal) == null ? void 0 : _c.trailingSlash) ?? (server_data_node == null ? void 0 : server_data_node.slash)
    };
  }
  function has_changed(parent_changed, route_changed, url_changed, uses, params) {
    if (force_invalidation)
      return true;
    if (!uses)
      return false;
    if (uses.parent && parent_changed)
      return true;
    if (uses.route && route_changed)
      return true;
    if (uses.url && url_changed)
      return true;
    for (const param of uses.params) {
      if (params[param] !== current.params[param])
        return true;
    }
    for (const href of uses.dependencies) {
      if (invalidated.some((fn) => fn(new URL(href))))
        return true;
    }
    return false;
  }
  function create_data_node(node2, previous) {
    if ((node2 == null ? void 0 : node2.type) === "data") {
      return {
        type: "data",
        data: node2.data,
        uses: {
          dependencies: new Set(node2.uses.dependencies ?? []),
          params: new Set(node2.uses.params ?? []),
          parent: !!node2.uses.parent,
          route: !!node2.uses.route,
          url: !!node2.uses.url
        },
        slash: node2.slash
      };
    } else if ((node2 == null ? void 0 : node2.type) === "skip") {
      return previous ?? null;
    }
    return null;
  }
  async function load_route({ id: id2, invalidating, url, params, route }) {
    if ((load_cache == null ? void 0 : load_cache.id) === id2) {
      return load_cache.promise;
    }
    const { errors, layouts, leaf } = route;
    const loaders = [...layouts, leaf];
    errors.forEach((loader) => loader == null ? void 0 : loader().catch(() => {
    }));
    loaders.forEach((loader) => loader == null ? void 0 : loader[1]().catch(() => {
    }));
    let server_data = null;
    const url_changed = current.url ? id2 !== current.url.pathname + current.url.search : false;
    const route_changed = current.route ? route.id !== current.route.id : false;
    let parent_invalid = false;
    const invalid_server_nodes = loaders.map((loader, i2) => {
      var _a3;
      const previous = current.branch[i2];
      const invalid = !!(loader == null ? void 0 : loader[0]) && ((previous == null ? void 0 : previous.loader) !== loader[1] || has_changed(parent_invalid, route_changed, url_changed, (_a3 = previous.server) == null ? void 0 : _a3.uses, params));
      if (invalid) {
        parent_invalid = true;
      }
      return invalid;
    });
    if (invalid_server_nodes.some(Boolean)) {
      try {
        server_data = await load_data(url, invalid_server_nodes);
      } catch (error) {
        return load_root_error_page({
          status: error instanceof HttpError ? error.status : 500,
          error: await handle_error(error, { url, params, route: { id: route.id } }),
          url,
          route
        });
      }
      if (server_data.type === "redirect") {
        return server_data;
      }
    }
    const server_data_nodes = server_data == null ? void 0 : server_data.nodes;
    let parent_changed = false;
    const branch_promises = loaders.map(async (loader, i2) => {
      var _a3;
      if (!loader)
        return;
      const previous = current.branch[i2];
      const server_data_node = server_data_nodes == null ? void 0 : server_data_nodes[i2];
      const valid = (!server_data_node || server_data_node.type === "skip") && loader[1] === (previous == null ? void 0 : previous.loader) && !has_changed(parent_changed, route_changed, url_changed, (_a3 = previous.universal) == null ? void 0 : _a3.uses, params);
      if (valid)
        return previous;
      parent_changed = true;
      if ((server_data_node == null ? void 0 : server_data_node.type) === "error") {
        throw server_data_node;
      }
      return load_node({
        loader: loader[1],
        url,
        params,
        route,
        parent: async () => {
          var _a4;
          const data2 = {};
          for (let j2 = 0; j2 < i2; j2 += 1) {
            Object.assign(data2, (_a4 = await branch_promises[j2]) == null ? void 0 : _a4.data);
          }
          return data2;
        },
        server_data_node: create_data_node(
          // server_data_node is undefined if it wasn't reloaded from the server;
          // and if current loader uses server data, we want to reuse previous data.
          server_data_node === void 0 && loader[0] ? { type: "skip" } : server_data_node ?? null,
          loader[0] ? previous == null ? void 0 : previous.server : void 0
        )
      });
    });
    for (const p2 of branch_promises)
      p2.catch(() => {
      });
    const branch = [];
    for (let i2 = 0; i2 < loaders.length; i2 += 1) {
      if (loaders[i2]) {
        try {
          branch.push(await branch_promises[i2]);
        } catch (err) {
          if (err instanceof Redirect) {
            return {
              type: "redirect",
              location: err.location
            };
          }
          let status = 500;
          let error;
          if (server_data_nodes == null ? void 0 : server_data_nodes.includes(err)) {
            status = err.status ?? status;
            error = err.error;
          } else if (err instanceof HttpError) {
            status = err.status;
            error = err.body;
          } else {
            const updated = await stores.updated.check();
            if (updated) {
              return await native_navigation(url);
            }
            error = await handle_error(err, { params, url, route: { id: route.id } });
          }
          const error_load = await load_nearest_error_page(i2, branch, errors);
          if (error_load) {
            return await get_navigation_result_from_branch({
              url,
              params,
              branch: branch.slice(0, error_load.idx).concat(error_load.node),
              status,
              error,
              route
            });
          } else {
            return await server_fallback(url, { id: route.id }, error, status);
          }
        }
      } else {
        branch.push(void 0);
      }
    }
    return await get_navigation_result_from_branch({
      url,
      params,
      branch,
      status: 200,
      error: null,
      route,
      // Reset `form` on navigation, but not invalidation
      form: invalidating ? void 0 : null
    });
  }
  async function load_nearest_error_page(i2, branch, errors) {
    while (i2--) {
      if (errors[i2]) {
        let j2 = i2;
        while (!branch[j2])
          j2 -= 1;
        try {
          return {
            idx: j2 + 1,
            node: {
              node: await errors[i2](),
              loader: errors[i2],
              data: {},
              server: null,
              universal: null
            }
          };
        } catch (e) {
          continue;
        }
      }
    }
  }
  async function load_root_error_page({ status, error, url, route }) {
    const params = {};
    let server_data_node = null;
    const default_layout_has_server_load = server_loads[0] === 0;
    if (default_layout_has_server_load) {
      try {
        const server_data = await load_data(url, [true]);
        if (server_data.type !== "data" || server_data.nodes[0] && server_data.nodes[0].type !== "data") {
          throw 0;
        }
        server_data_node = server_data.nodes[0] ?? null;
      } catch {
        if (url.origin !== location.origin || url.pathname !== location.pathname || hydrated) {
          await native_navigation(url);
        }
      }
    }
    const root_layout = await load_node({
      loader: default_layout_loader,
      url,
      params,
      route,
      parent: () => Promise.resolve({}),
      server_data_node: create_data_node(server_data_node)
    });
    const root_error = {
      node: await default_error_loader(),
      loader: default_error_loader,
      universal: null,
      server: null,
      data: null
    };
    return await get_navigation_result_from_branch({
      url,
      params,
      branch: [root_layout, root_error],
      status,
      error,
      route: null
    });
  }
  function get_navigation_intent(url, invalidating) {
    if (is_external_url(url, base$4))
      return;
    const path = get_url_path(url);
    for (const route of routes) {
      const params = route.exec(path);
      if (params) {
        const id2 = url.pathname + url.search;
        const intent = { id: id2, invalidating, route, params: decode_params(params), url };
        return intent;
      }
    }
  }
  function get_url_path(url) {
    return decode_pathname(url.pathname.slice(base$4.length) || "/");
  }
  function before_navigate({ url, type, intent, delta }) {
    var _a3, _b;
    let should_block = false;
    const navigation = {
      from: {
        params: current.params,
        route: { id: ((_a3 = current.route) == null ? void 0 : _a3.id) ?? null },
        url: current.url
      },
      to: {
        params: (intent == null ? void 0 : intent.params) ?? null,
        route: { id: ((_b = intent == null ? void 0 : intent.route) == null ? void 0 : _b.id) ?? null },
        url
      },
      willUnload: !intent,
      type
    };
    if (delta !== void 0) {
      navigation.delta = delta;
    }
    const cancellable = {
      ...navigation,
      cancel: () => {
        should_block = true;
      }
    };
    if (!navigating) {
      callbacks.before_navigate.forEach((fn) => fn(cancellable));
    }
    return should_block ? null : navigation;
  }
  async function navigate({
    url,
    scroll: scroll2,
    keepfocus,
    redirect_chain,
    details,
    type,
    delta,
    nav_token,
    accepted,
    blocked
  }) {
    const intent = get_navigation_intent(url, false);
    const navigation = before_navigate({ url, type, delta, intent });
    if (!navigation) {
      blocked();
      return;
    }
    const previous_history_index = current_history_index;
    accepted();
    navigating = true;
    if (started) {
      stores.navigating.set(navigation);
    }
    await update6(
      intent,
      url,
      redirect_chain,
      previous_history_index,
      {
        scroll: scroll2,
        keepfocus,
        details
      },
      nav_token,
      () => {
        navigating = false;
        callbacks.after_navigate.forEach(
          (fn) => fn(navigation)
        );
        stores.navigating.set(null);
      }
    );
  }
  async function server_fallback(url, route, error, status) {
    if (url.origin === location.origin && url.pathname === location.pathname && !hydrated) {
      return await load_root_error_page({
        status,
        error,
        url,
        route
      });
    }
    return await native_navigation(url);
  }
  function native_navigation(url) {
    location.href = url.href;
    return new Promise(() => {
    });
  }
  function setup_preload() {
    let mousemove_timeout;
    container.addEventListener("mousemove", (event) => {
      const target2 = event.target;
      clearTimeout(mousemove_timeout);
      mousemove_timeout = setTimeout(() => {
        preload2(target2, 2);
      }, 20);
    });
    function tap2(event) {
      preload2(event.composedPath()[0], 1);
    }
    container.addEventListener("mousedown", tap2);
    container.addEventListener("touchstart", tap2, { passive: true });
    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            preload_code(
              get_url_path(new URL(entry.target.href))
            );
            observer.unobserve(entry.target);
          }
        }
      },
      { threshold: 0 }
    );
    function preload2(element2, priority) {
      const a2 = find_anchor(element2, container);
      if (!a2)
        return;
      const { url, external } = get_link_info(a2, base$4);
      if (external)
        return;
      const options = get_router_options(a2);
      if (!options.reload) {
        if (priority <= options.preload_data) {
          const intent = get_navigation_intent(url, false);
          if (intent) {
            {
              preload_data(intent);
            }
          }
        } else if (priority <= options.preload_code) {
          preload_code(get_url_path(url));
        }
      }
    }
    function after_navigate() {
      observer.disconnect();
      for (const a2 of container.querySelectorAll("a")) {
        const { url, external } = get_link_info(a2, base$4);
        if (external)
          continue;
        const options = get_router_options(a2);
        if (options.reload)
          continue;
        if (options.preload_code === PRELOAD_PRIORITIES.viewport) {
          observer.observe(a2);
        }
        if (options.preload_code === PRELOAD_PRIORITIES.eager) {
          preload_code(get_url_path(url));
        }
      }
    }
    callbacks.after_navigate.push(after_navigate);
    after_navigate();
  }
  return {
    after_navigate: (fn) => {
      onMount(() => {
        callbacks.after_navigate.push(fn);
        return () => {
          const i2 = callbacks.after_navigate.indexOf(fn);
          callbacks.after_navigate.splice(i2, 1);
        };
      });
    },
    before_navigate: (fn) => {
      onMount(() => {
        callbacks.before_navigate.push(fn);
        return () => {
          const i2 = callbacks.before_navigate.indexOf(fn);
          callbacks.before_navigate.splice(i2, 1);
        };
      });
    },
    disable_scroll_handling: () => {
      if (updating || !started) {
        autoscroll = false;
      }
    },
    goto: (href, opts = {}) => {
      return goto(href, opts, []);
    },
    invalidate: (resource) => {
      if (typeof resource === "function") {
        invalidated.push(resource);
      } else {
        const { href } = new URL(resource, location.href);
        invalidated.push((url) => url.href === href);
      }
      return invalidate();
    },
    invalidateAll: () => {
      force_invalidation = true;
      return invalidate();
    },
    preload_data: async (href) => {
      const url = new URL(href, get_base_uri(document));
      const intent = get_navigation_intent(url, false);
      if (!intent) {
        throw new Error(`Attempted to preload a URL that does not belong to this app: ${url}`);
      }
      await preload_data(intent);
    },
    preload_code,
    apply_action: async (result) => {
      if (result.type === "error") {
        const url = new URL(location.href);
        const { branch, route } = current;
        if (!route)
          return;
        const error_load = await load_nearest_error_page(
          current.branch.length,
          branch,
          route.errors
        );
        if (error_load) {
          const navigation_result = await get_navigation_result_from_branch({
            url,
            params: current.params,
            branch: branch.slice(0, error_load.idx).concat(error_load.node),
            status: result.status ?? 500,
            error: result.error,
            route
          });
          current = navigation_result.state;
          root.$set(navigation_result.props);
          tick().then(reset_focus);
        }
      } else if (result.type === "redirect") {
        goto(result.location, { invalidateAll: true }, []);
      } else {
        const props = {
          form: result.data,
          page: { ...page, form: result.data, status: result.status }
        };
        root.$set(props);
        if (result.type === "success") {
          tick().then(reset_focus);
        }
      }
    },
    _start_router: () => {
      var _a3;
      history.scrollRestoration = "manual";
      addEventListener("beforeunload", (e) => {
        var _a4;
        let should_block = false;
        if (!navigating) {
          const navigation = {
            from: {
              params: current.params,
              route: { id: ((_a4 = current.route) == null ? void 0 : _a4.id) ?? null },
              url: current.url
            },
            to: null,
            willUnload: true,
            type: "leave",
            cancel: () => should_block = true
          };
          callbacks.before_navigate.forEach((fn) => fn(navigation));
        }
        if (should_block) {
          e.preventDefault();
          e.returnValue = "";
        } else {
          history.scrollRestoration = "auto";
        }
      });
      addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          update_scroll_positions(current_history_index);
          set(SCROLL_KEY, scroll_positions);
          capture_snapshot(current_history_index);
          set(SNAPSHOT_KEY, snapshots);
        }
      });
      if (!((_a3 = navigator.connection) == null ? void 0 : _a3.saveData)) {
        setup_preload();
      }
      container.addEventListener("click", (event) => {
        if (event.button || event.which !== 1)
          return;
        if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey)
          return;
        if (event.defaultPrevented)
          return;
        const a2 = find_anchor(event.composedPath()[0], container);
        if (!a2)
          return;
        const { url, external, target: target2 } = get_link_info(a2, base$4);
        if (!url)
          return;
        if (target2 === "_parent" || target2 === "_top") {
          if (window.parent !== window)
            return;
        } else if (target2 && target2 !== "_self") {
          return;
        }
        const options = get_router_options(a2);
        const is_svg_a_element = a2 instanceof SVGAElement;
        if (!is_svg_a_element && url.protocol !== location.protocol && !(url.protocol === "https:" || url.protocol === "http:"))
          return;
        if (external || options.reload) {
          const navigation = before_navigate({ url, type: "link" });
          if (!navigation) {
            event.preventDefault();
          }
          navigating = true;
          return;
        }
        const [nonhash, hash3] = url.href.split("#");
        if (hash3 !== void 0 && nonhash === location.href.split("#")[0]) {
          hash_navigating = true;
          update_scroll_positions(current_history_index);
          current.url = url;
          stores.page.set({ ...page, url });
          stores.page.notify();
          return;
        }
        navigate({
          url,
          scroll: options.noscroll ? scroll_state() : null,
          keepfocus: false,
          redirect_chain: [],
          details: {
            state: {},
            replaceState: url.href === location.href
          },
          accepted: () => event.preventDefault(),
          blocked: () => event.preventDefault(),
          type: "link"
        });
      });
      container.addEventListener("submit", (event) => {
        if (event.defaultPrevented)
          return;
        const form = HTMLFormElement.prototype.cloneNode.call(event.target);
        const submitter = event.submitter;
        const method = (submitter == null ? void 0 : submitter.formMethod) || form.method;
        if (method !== "get")
          return;
        const url = new URL(
          (submitter == null ? void 0 : submitter.hasAttribute("formaction")) && (submitter == null ? void 0 : submitter.formAction) || form.action
        );
        if (is_external_url(url, base$4))
          return;
        const event_form = event.target;
        const { noscroll, reload } = get_router_options(event_form);
        if (reload)
          return;
        event.preventDefault();
        event.stopPropagation();
        const data2 = new FormData(event_form);
        const submitter_name = submitter == null ? void 0 : submitter.getAttribute("name");
        if (submitter_name) {
          data2.append(submitter_name, (submitter == null ? void 0 : submitter.getAttribute("value")) ?? "");
        }
        url.search = new URLSearchParams(data2).toString();
        navigate({
          url,
          scroll: noscroll ? scroll_state() : null,
          keepfocus: false,
          redirect_chain: [],
          details: {
            state: {},
            replaceState: false
          },
          nav_token: {},
          accepted: () => {
          },
          blocked: () => {
          },
          type: "form"
        });
      });
      addEventListener("popstate", async (event) => {
        var _a4;
        if ((_a4 = event.state) == null ? void 0 : _a4[INDEX_KEY]) {
          if (event.state[INDEX_KEY] === current_history_index)
            return;
          const scroll2 = scroll_positions[event.state[INDEX_KEY]];
          if (current.url.href.split("#")[0] === location.href.split("#")[0]) {
            scroll_positions[current_history_index] = scroll_state();
            current_history_index = event.state[INDEX_KEY];
            scrollTo(scroll2.x, scroll2.y);
            return;
          }
          const delta = event.state[INDEX_KEY] - current_history_index;
          let blocked = false;
          await navigate({
            url: new URL(location.href),
            scroll: scroll2,
            keepfocus: false,
            redirect_chain: [],
            details: null,
            accepted: () => {
              current_history_index = event.state[INDEX_KEY];
            },
            blocked: () => {
              history.go(-delta);
              blocked = true;
            },
            type: "popstate",
            delta
          });
          if (!blocked) {
            restore_snapshot(current_history_index);
          }
        }
      });
      addEventListener("hashchange", () => {
        if (hash_navigating) {
          hash_navigating = false;
          history.replaceState(
            { ...history.state, [INDEX_KEY]: ++current_history_index },
            "",
            location.href
          );
        }
      });
      for (const link of document.querySelectorAll("link")) {
        if (link.rel === "icon")
          link.href = link.href;
      }
      addEventListener("pageshow", (event) => {
        if (event.persisted) {
          stores.navigating.set(null);
        }
      });
    },
    _hydrate: async ({
      status = 200,
      error,
      node_ids,
      params,
      route,
      data: server_data_nodes,
      form
    }) => {
      hydrated = true;
      const url = new URL(location.href);
      {
        ({ params = {}, route = { id: null } } = get_navigation_intent(url, false) || {});
      }
      let result;
      try {
        const branch_promises = node_ids.map(async (n, i2) => {
          const server_data_node = server_data_nodes[i2];
          return load_node({
            loader: nodes[n],
            url,
            params,
            route,
            parent: async () => {
              const data2 = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                Object.assign(data2, (await branch_promises[j2]).data);
              }
              return data2;
            },
            server_data_node: create_data_node(server_data_node)
          });
        });
        result = await get_navigation_result_from_branch({
          url,
          params,
          branch: await Promise.all(branch_promises),
          status,
          error,
          form,
          route: routes.find(({ id: id2 }) => id2 === route.id) ?? null
        });
      } catch (error2) {
        if (error2 instanceof Redirect) {
          await native_navigation(new URL(error2.location, location.href));
          return;
        }
        result = await load_root_error_page({
          status: error2 instanceof HttpError ? error2.status : 500,
          error: await handle_error(error2, { url, params, route }),
          url,
          route
        });
      }
      initialize(result);
    }
  };
}
async function load_data(url, invalid) {
  var _a2;
  const data_url = new URL(url);
  data_url.pathname = add_data_suffix(url.pathname);
  data_url.searchParams.append(
    "x-sveltekit-invalidated",
    invalid.map((x2) => x2 ? "1" : "").join("_")
  );
  const res = await native_fetch(data_url.href);
  const data2 = await res.json();
  if (!res.ok) {
    throw new HttpError(res.status, data2);
  }
  (_a2 = data2.nodes) == null ? void 0 : _a2.forEach((node2) => {
    if ((node2 == null ? void 0 : node2.type) === "data") {
      node2.data = unflatten(node2.data);
      node2.uses = {
        dependencies: new Set(node2.uses.dependencies ?? []),
        params: new Set(node2.uses.params ?? []),
        parent: !!node2.uses.parent,
        route: !!node2.uses.route,
        url: !!node2.uses.url
      };
    }
  });
  return data2;
}
function handle_error(error, event) {
  if (error instanceof HttpError) {
    return error.body;
  }
  return hooks.handleError({ error, event }) ?? { message: event.route.id != null ? "Internal Error" : "Not Found" };
}
function reset_focus() {
  const autofocus = document.querySelector("[autofocus]");
  if (autofocus) {
    autofocus.focus();
  } else {
    const root = document.body;
    const tabindex = root.getAttribute("tabindex");
    root.tabIndex = -1;
    root.focus({ preventScroll: true });
    if (tabindex !== null) {
      root.setAttribute("tabindex", tabindex);
    } else {
      root.removeAttribute("tabindex");
    }
    return new Promise((resolve) => {
      setTimeout(() => {
        var _a2;
        resolve((_a2 = getSelection()) == null ? void 0 : _a2.removeAllRanges());
      });
    });
  }
}
async function start({ assets, env, hydrate, target, version: version2 }) {
  set_assets(assets);
  set_version(version2);
  const client = create_client({
    target
  });
  init$1({ client });
  if (hydrate) {
    await client._hydrate(hydrate);
  } else {
    client.goto(location.href, { replaceState: true });
  }
  client._start_router();
}
export {
  buildURL$1 as a,
  buildFullPath as b,
  axios as c,
  start as d,
  settle as s,
  utils$m as u
};
